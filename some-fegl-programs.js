webpackJsonp([18,90],{1045:function(s,n){s.exports={content:'<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true"><span class="icon icon-link"></span></a>前言</h1>\n<p>这是一篇不太正规的「计算机图形学论文」，其实论文谈不上，因为根本上不到研究的层次，就是自己瞎捣鼓。\n主要介绍了几个与图形学相关的程序，皆采用前端技术实现，点击即可查看。</p>\n<ul>\n<li><a href="http://moyuyc.github.io/htm/painter/">简单的绘图程序</a></li>\n<li><a href="http://moyuyc.github.io/2016/04/26/canvas%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%B1%E7%93%A3/">三次贝赛尔曲线应用-绘制平面动态花瓣</a></li>\n<li><a href="/htm/bezier.html">动态绘制三次贝赛尔曲线</a></li>\n<li><a href="http://moyuyc.xyz/play_3d/play_3d_demo1.html">三维几何体的基本变换与组合变换应用</a></li>\n</ul>\n<!--more-->\n<h1 id="主要内容"><a href="#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9" aria-hidden="true"><span class="icon icon-link"></span></a>主要内容</h1>\n<h2 id="简单的绘图程序"><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F" aria-hidden="true"><span class="icon icon-link"></span></a>简单的绘图程序</h2>\n<h3 id="介绍"><a href="#%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span class="icon icon-link"></span></a>介绍</h3>\n<p>主要运用HTML5 canvas API与相关图形学知识实现的绘图程序（还包括部分图像处理功能，不介绍）。\n能够选择图形类型（Pen/Line/Circle）,画笔颜色（随机生成）,画笔宽度, 图形对象拖拽移动，图形种子填充算法。</p>\n<h3 id="演示图片"><a href="#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87" aria-hidden="true"><span class="icon icon-link"></span></a>演示图片</h3>\n<img src="/images/gif1.gif" alt="img" width="1142" height="747" />\n<h3 id="代码解释"><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A" aria-hidden="true"><span class="icon icon-link"></span></a>代码解释</h3>\n<p><code>Shape.js ： 主要包含一些图形类</code></p>\n<p>点类代码</p>\n<pre><code data-query="{}" data-lang="">Point: function (x, y) {\n    this.x = x;\n    this.y = y;\n    this.distance = function (p) {\n        p = p?p:new Shape.Point(0,0);\n        return Math.sqrt(Math.pow(p.x-this.x,2)+Math.pow(p.y-this.y,2));\n    };\n    this.move = function(offsetX,offsetY){\n        this.x+=offsetX;this.y+=offsetY;\n    };\n    this.draw = function (paint, color, linewidth) {\n        this.color = color?color:this.color;\n        this.linewidth = linewidth?linewidth:this.linewidth;\n        paint.strokeStyle = this.color ? this.color : \'black\';\n        paint.lineWidth = this.linewidth!=null ? this.linewidth : 1;\n        paint.beginPath();\n        paint.moveTo(this.x, this.y);\n        paint.lineTo(this.x + 1, this.y + 1);\n        paint.stroke();\n        paint.save();\n        return this;\n    }\n}\n</code></pre>\n<p>线段类代码</p>\n<pre><code data-query="{}" data-lang="">Line: function (p1, p2) {\n    this.sp = p1;\n    this.ep = p2;\n    //this.color;this.linewidth;\n    this.move = function(offsetX,offsetY){\n        this.sp.x+=offsetX;this.sp.y+=offsetY;\n        this.ep.x+=offsetX;this.ep.y+=offsetY;\n    };\n    // 不足：未考虑线宽，用户较难选中\n    this.isIn = function (point) {\n        var x = point.x, y = point.y;\n        if((y-this.sp.y)*(x-this.ep.x)==(y-this.ep.y)*(x-this.sp.x))\n            return true;\n        return false;\n    };\n    // 中点划线法\n    this.draw = function (paint, color, linewidth) {\n        this.color = color?color:this.color;\n        this.linewidth = linewidth!=null?linewidth:this.linewidth;\n        color = this.color; linewidth = this.linewidth;\n        var ep = this.ep, sp = this.sp,\n            dX = ep.x - sp.x,\n            dY = ep.y - sp.y,\n            a = sp.y - ep.y,\n            b = ep.x - sp.x;\n        if (Math.abs(dX) >= Math.abs(dY)) {\n            if (dX >= 0 &#x26;&#x26; dY >= 0) {\n                var d = b + 2 * a, d1 = 2 * a, d2 = 2 * (a + b);\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x + 1, y = sp.y; x &#x3C; ep.x; x++) {\n                    if (d >= 0) d = d + d1;\n                    else {\n                        y++;\n                        d = d + d2;\n                    }\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n            else if (dX >= 0 &#x26;&#x26; dY &#x3C;= 0) {\n                var d = -b + a &#x3C;&#x3C; 1, d1 = (a - b) &#x3C;&#x3C; 1, d2 = a &#x3C;&#x3C; 1;\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x + 1, y = sp.y; x &#x3C; ep.x; x++) {\n                    if (d >= 0) {\n                        y--;\n                        d = d + d1;\n                    }\n                    else d = d + d2;\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n            else if (dX &#x3C;= 0 &#x26;&#x26; dY &#x3C;= 0) {\n                var d = -b - 2 * a, d1 = -2 * a, d2 = -2 * (a + b);\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\n                    if (d >= 0) d = d + d1;\n                    else {\n                        y--;\n                        d = d + d2;\n                    }\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n            else {\n                var d = b - 2 * a, d1 = 2 * (b - a), d2 = -2 * a;\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\n                    if (d >= 0) {\n                        y++;\n                        d = d + d1;\n                    }\n                    else d = d + d2;\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n        }\n        else {\n            if (dX >= 0 &#x26;&#x26; dY >= 0) {\n                var d = a + 2 * b, d1 = 2 * (a + b), d2 = 2 * b;\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x, y = sp.y + 1; y &#x3C; ep.y; y++) {\n                    if (d >= 0) {\n                        x++;\n                        d = d + d1;\n                    }\n                    else {\n                        d = d + d2;\n                    }\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n            else if (dX >= 0 &#x26;&#x26; dY &#x3C;= 0) {\n                var d = a - 2 * b, d1 = -2 * b, d2 = 2 * (a - b);\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\n                    if (d >= 0)      d = d + d1;\n                    else {\n                        x++;\n                        d = d + d2;\n                    }\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n\n            }\n            else if (dX &#x3C;= 0 &#x26;&#x26; dY &#x3C;= 0) {\n                var d = -a - 2 * b, d1 = -2 * (a + b), d2 = -2 * b;\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\n                    if (d >= 0) {\n                        x--;\n                        d = d + d1;\n                    }\n                    else               d = d + d2;\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n\n            }\n            else {\n                var d = -a + 2 * b, d1 = 2 * b, d2 = 2 * (b - a);\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\n                for (var x = sp.x, y = sp.y + 1; y &#x3C; ep.y; y++) {\n                    if (d >= 0)           d = d + d1;\n                    else {\n                        x--;\n                        d = d + d2;\n                    }\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\n                }\n            }\n        }\n        return this;\n    }\n}\n</code></pre>\n<p>圆类代码</p>\n<pre><code data-query="{}" data-lang="">Circle: function (cp, r) {\n    this.cp = cp;\n    this.r = r;\n    this.move = function(offsetX,offsetY){\n        this.cp.x+=offsetX;this.cp.y+=offsetY;\n    };\n    //this.color;this.linewidth;\n    this.isIn = function (point) {\n        var x = point.x, y = point.y;\n        return (x-this.cp.x)*(x-this.cp.x)+(y-this.cp.y)*(y-this.cp.y)&#x3C;=this.r*this.r;\n    };\n    // 八分法画圆\n    this.draw = function (paint, color, linewidth) {\n        this.color = color?color:this.color;\n        this.linewidth = linewidth?linewidth:this.linewidth;\n        color = this.color; linewidth = this.linewidth;\n        //console.log(color);\n        var r = this.r, cp = this.cp,\n            d = 1 - r, p = new Shape.Point(0, r);\n        while (p.x &#x3C;= p.y) {\n            new Shape.Point(cp.x + p.x, cp.y + p.y).draw(paint, color, linewidth);\n            new Shape.Point(cp.x + p.x, cp.y - p.y).draw(paint, color, linewidth);\n            new Shape.Point(cp.x - p.x, cp.y + p.y).draw(paint, color, linewidth);\n            new Shape.Point(cp.x - p.x, cp.y - p.y).draw(paint, color, linewidth);\n            new Shape.Point(cp.x + p.y, cp.y + p.x).draw(paint, color, linewidth);\n            new Shape.Point(cp.x + p.y, cp.y - p.x).draw(paint, color, linewidth);\n            new Shape.Point(cp.x - p.y, cp.y + p.x).draw(paint, color, linewidth);\n            new Shape.Point(cp.x - p.y, cp.y - p.x).draw(paint, color, linewidth);\n            p.x++;\n            if (d &#x3C; 0) d = d + 2 * p.x + 1;\n            else {\n                p.y--;\n                d = d + 2 * p.x - 2 * p.y + 1;\n            }\n        }\n        return this;\n    };\n    //种子填充算法 深度优先搜索，基于栈，isam表示是否含动画填充效果\n    this.dfsFill = function (paint,p,color,isam) {\n        isam = isam || false;\n        var stack = [p],hashmap = {},container=[];\n        while (stack.length !== 0){\n            p = stack.pop();\n            if(isam)\n                container.push(p);\n            else\n                p.draw(paint,color);\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\n                .forEach(ele=>{\n                    if(this.isIn(ele) &#x26;&#x26; !hashmap[ele]) {\n                        stack.push(ele);\n                        hashmap[ele] = hashmap[ele]+1 || 0;\n                    }\n                });\n        }\n        console.log(hashmap);\n        if(isam) {\n            var animate = requestAnimationFrame;\n            animate(function () {\n                if (!container.length) return;\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                animate(arguments.callee);\n            })\n        }\n    };\n    //种子填充算法 广度优先搜索，基于队列。\n    this.bfsFill = function (paint,p,color,isam) {\n        isam = isam || false;\n        var queue = [p],hashmap = {},container=[];\n        while (queue.length !== 0){\n            p = queue.shift();\n            if(isam)\n                container.push(p);\n            else\n                p.draw(paint,color);\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\n                .forEach(ele=>{\n                    if(this.isIn(ele) &#x26;&#x26; !hashmap[ele]) {\n                        queue.push(ele);\n                        hashmap[ele] = hashmap[ele]+1 || 0;\n                    }\n                });\n        }\n        console.log(hashmap);\n        if(isam) {\n            var animate = requestAnimationFrame;\n            animate(function () {\n                if (!container.length) return;\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\n                animate(arguments.callee);\n            })\n        }\n    }\n}\n</code></pre>\n<p>路径类代码</p>\n<pre><code data-query="{}" data-lang="">Path: function (points) {\n    this.ps = points;\n    this.move = function(offsetX,offsetY){\n        for(var i = 0;i&#x3C;this.ps.length;i++){\n            this.ps[i].x+=offsetX;\n            this.ps[i].y+=offsetY;\n        }\n    };\n    this.isIn = function (point) {\n        var p = this.ps[0];\n        for(var i=1;i&#x3C;this.ps.length;i++){\n            if(new Shape.Line(p,this.ps[i]).isIn(point))\n                return true;\n            p = this.ps[i];\n        }\n        return false;\n    };\n    // 调用canvas提供的api\n    this.draw = function (paint,color,linewidth) {\n        this.color = color?color:this.color;\n        this.linewidth = linewidth?linewidth:this.linewidth;\n        color = this.color; linewidth = this.linewidth;\n        //console.log(color);\n        var arr = this.ps;\n        if(arr.length==0)  return;\n        paint.beginPath();\n        paint.strokeStyle = color ? color : \'black\';\n        paint.lineWidth = linewidth ? linewidth : 1;\n        paint.moveTo(arr[0].x,arr[0].y);\n        for(var i =1;i&#x3C;arr.length;i++){\n            paint.lineTo(arr[i].x,arr[i].y);\n        }\n        paint.stroke();\n        return this;\n    }\n}\n</code></pre>\n<p><code>canvas.js: 包含其他一些对事件的绑定或者对控件的控制等代码</code></p>\n<p>选中图形进行拖动函数</p>\n<pre><code data-query="{}" data-lang="">dragMoveHandle = function () {\n    var f1 = function(e){\n    var x = e.offsetX, y = e.offsetY;\n    var v = Tool.getInFirstShape(new Shape.Point(x,y));\n    if(v){\n    var f2 = function (e2) {\n        if(e2.buttons==1){\n        var offsetx = e2.offsetX-x, offsety = e2.offsetY-y;\n        x=e2.offsetX; y = e2.offsetY;\n        v.move(offsetx,offsety);\n        Tool.refresh();\n        }\n    },f3 = function (e3) {\n        var offsetx = e3.offsetX-x, offsety = e3.offsetY-y;\n        v.move(offsetx,offsety);\n        Tool.refresh();\n        // e3.stopPropagation();\n        $(this).off(\'mousemove\',f2).off(\'mouseup\',f3);\n    };\n    $(paint.canvas).on(\'mousemove\',f2).on(\'mouseup\',f3).off(\'mousedown\',f1);\n    }else\n    $(\'[role=opType-item]\').removeClass(\'active\');\n}\n$(paint.canvas).on(\'mousedown\',f1)\n}\n</code></pre>\n<p>关于Tool对象</p>\n<pre><code data-query="{}" data-lang="">Tool = {\n    getInFirstShape : function(p){\n        var f = function(d){\n            for(var i =0;i&#x3C; d.length;i++){\n                if(d[i].isIn(p))//点p是否在d[i]图形对象中？\n                    return d[i];\n            }\n            return false;\n        };\n        var r;\n        for(var d in paint.data)\n            //paint.data 表示存在于画布中的所有图形对象\n            if((r=f(paint.data[d]))!=false)\n                return r;\n    },\n    // 重新绘制\n    refresh : function () {\n        paint.clearRect(0,0,paint.canvas.width,paint.canvas.height);\n        for(var i =0;i&#x3C;paint.data.Paths.length;i++)\n            paint.data.Paths[i].draw(paint);\n        for(var i =0;i&#x3C;paint.data.Lines.length;i++)\n            paint.data.Lines[i].draw(paint);\n        for(var i =0;i&#x3C;paint.data.Circles.length;i++)\n            paint.data.Circles[i].draw(paint);\n    }\n}\n</code></pre>\n<h3 id="不足之处"><a href="#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84" aria-hidden="true"><span class="icon icon-link"></span></a>不足之处</h3>\n<ol>\n<li>对于<code>Line</code>的<code>isIn</code>方法，未考虑到线宽的因素，用户很难准确选中线段</li>\n<li>对于拖动图形的事件处理逻辑较复杂。</li>\n<li>对于图形类中未使用到<code>js</code>中的原型与原型继承，降低了代码复用度。</li>\n</ol>\n<h2 id="三次贝赛尔曲线应用-绘制平面动态花瓣"><a href="#%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%BA%94%E7%94%A8-%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E5%8A%A8%E6%80%81%E8%8A%B1%E7%93%A3" aria-hidden="true"><span class="icon icon-link"></span></a>三次贝赛尔曲线应用-绘制平面动态花瓣</h2>\n<h3 id="介绍-1"><a href="#%E4%BB%8B%E7%BB%8D-1" aria-hidden="true"><span class="icon icon-link"></span></a>介绍</h3>\n<p>主要运用HTML5 canvas API与相关图形学知识实现的平面动态花瓣绘制。</p>\n<h3 id="演示图片-1"><a href="#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-1" aria-hidden="true"><span class="icon icon-link"></span></a>演示图片</h3>\n<img src="/images/gif2.gif" alt="img" width="992" height="604" />\n<h3 id="代码解释-1"><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1" aria-hidden="true"><span class="icon icon-link"></span></a>代码解释</h3>\n<ul>\n<li>核心代码</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Flower</span>(<span class="hljs-params">c,petals,size,x,y,rotate</span>)</span>{\n\t<span class="hljs-keyword">this</span>.c = c || [<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>];\n\t<span class="hljs-keyword">this</span>.petals = petals || <span class="hljs-number">4</span>;\n\t<span class="hljs-keyword">this</span>.size = size || <span class="hljs-number">5</span>;\n\t<span class="hljs-keyword">this</span>.x = x || <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">this</span>.y = y || <span class="hljs-number">0</span>;\n\t<span class="hljs-keyword">this</span>.rotate = rotate || <span class="hljs-number">0</span>;\n}\nFlower.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n\t<span class="hljs-keyword">var</span> _rad = <span class="hljs-keyword">this</span>.size,_num_pts=<span class="hljs-keyword">this</span>.petals,_x=<span class="hljs-keyword">this</span>.x,_y=<span class="hljs-keyword">this</span>.y,c=<span class="hljs-keyword">this</span>.c;\n\tctx.save();\n\tctx.shadowBlur = <span class="hljs-number">30</span>; <span class="hljs-comment">//阴影程度</span>\n\tctx.lineWidth = <span class="hljs-number">1</span>;\n\tctx.shadowColor = utils.rgba(c[<span class="hljs-number">0</span>],c[<span class="hljs-number">1</span>],c[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>); <span class="hljs-comment">//阴影颜色</span>\n\tctx.fillStyle = utils.rgba(c[<span class="hljs-number">0</span>],c[<span class="hljs-number">1</span>],c[<span class="hljs-number">2</span>],<span class="hljs-number">.6</span>); <span class="hljs-comment">//填充颜色</span>\n\tc2 = c.map(<span class="hljs-function">(<span class="hljs-params">x</span>)=></span><span class="hljs-built_in">Math</span>.floor(x/<span class="hljs-number">1.6</span>));           <span class="hljs-comment">//lambda表达式写法</span>\n\tctx.strokeStyle = utils.rgba(c2[<span class="hljs-number">0</span>],c2[<span class="hljs-number">1</span>],c2[<span class="hljs-number">2</span>],<span class="hljs-number">1</span>);  <span class="hljs-comment">//边框颜色</span>\n\t<span class="hljs-keyword">var</span> pts = [];\n\t<span class="hljs-keyword">var</span> _a = <span class="hljs-keyword">this</span>.rotate+(tick*<span class="hljs-number">1</span>);\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &#x3C;= _num_pts ; i++){<span class="hljs-comment">//增量法提高效率</span>\n\t\tpts.push({<span class="hljs-attr">x</span>:utils.P2L(_rad, _a).x,<span class="hljs-attr">y</span>:utils.P2L(_rad, _a).y}); <span class="hljs-comment">//P2L将极坐标转换为平面坐标</span>\n\t\t_a += (<span class="hljs-number">360</span>/_num_pts);\n\t}\n\t<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ; i&#x3C;= _num_pts; i+=<span class="hljs-number">2</span>){\n\t\tidx= i%_num_pts;\n\t\tctx.beginPath();<span class="hljs-comment">//开始绘制</span>\n\t\tctx.moveTo(_x,_y);<span class="hljs-comment">//起点为(_x,_y)</span>\n\t\tctx.bezierCurveTo(_x+pts[i<span class="hljs-number">-1</span>].x,_y+pts[i<span class="hljs-number">-1</span>].y,_x+pts[idx+<span class="hljs-number">1</span>].x,_y+pts[idx+<span class="hljs-number">1</span>].y,_x,_y);<span class="hljs-comment">//绘制贝塞尔曲线</span>\n\t\tctx.stroke();<span class="hljs-comment">//闭合图形边框</span>\n\t\tctx.fill();<span class="hljs-comment">//填充图形</span>\n\t}\n\tctx.restore();\n}\nHTMLCanvasElement.prototype.magicBg = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n\t<span class="hljs-keyword">var</span> ctx = <span class="hljs-keyword">this</span>.getContext(<span class="hljs-string">\'2d\'</span>);\n\t<span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.grd){\n\t\t<span class="hljs-comment">//实现从画布中心往外呈圆形扩散，渐变。</span>\n\t\t<span class="hljs-keyword">this</span>.grd=ctx.createRadialGradient(<span class="hljs-keyword">this</span>.width/<span class="hljs-number">2</span>,<span class="hljs-keyword">this</span>.height/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.width/<span class="hljs-number">2</span>,<span class="hljs-keyword">this</span>.height/<span class="hljs-number">2</span>,<span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.width,<span class="hljs-keyword">this</span>.height)/<span class="hljs-number">1.2</span>);\n\t\t<span class="hljs-keyword">this</span>.grd.addColorStop(<span class="hljs-number">0</span>,<span class="hljs-string">"rgba(255,255,255,.25)"</span>);\n\t\t<span class="hljs-keyword">this</span>.grd.addColorStop(<span class="hljs-number">1</span>,<span class="hljs-keyword">this</span>.utils.rgba(<span class="hljs-number">200</span>+<span class="hljs-keyword">this</span>.utils.randomInt(<span class="hljs-number">56</span>),<span class="hljs-number">200</span>+<span class="hljs-keyword">this</span>.utils.randomInt(<span class="hljs-number">56</span>),<span class="hljs-number">200</span>+<span class="hljs-keyword">this</span>.utils.randomInt(<span class="hljs-number">56</span>),<span class="hljs-number">.65</span>));\n\t}\n\tctx.save();\n\tctx.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.width,<span class="hljs-keyword">this</span>.height);\n\tctx.fillStyle = <span class="hljs-keyword">this</span>.grd;\n\tctx.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.width,<span class="hljs-keyword">this</span>.height);\n\tctx.restore();\n}</code></pre>\n<ul>\n<li>Flower对象解释</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>c</code></td>\n<td>花瓣的颜色</td>\n<td>[\n255,255,255\n]</td>\n<td>Array</td>\n</tr>\n<tr>\n<td><code>petals</code></td>\n<td>花瓣个数</td>\n<td>4</td>\n<td>Number</td>\n</tr>\n<tr>\n<td><code>size</code></td>\n<td>半径大小</td>\n<td>5</td>\n<td>Number</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>中心 x 坐标</td>\n<td>0</td>\n<td>Number</td>\n</tr>\n<tr>\n<td><code>y</code></td>\n<td>中心 y 坐标</td>\n<td>0</td>\n<td>Number</td>\n</tr>\n<tr>\n<td><code>rotate</code></td>\n<td>绕中心旋转角度</td>\n<td>0</td>\n<td>Number(单位：度)</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>Flower.draw</code> 方法解释</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>变量</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_rad</code></td>\n<td>radix，对应\n<code>size</code></td>\n</tr>\n<tr>\n<td><code>_num_pts</code></td>\n<td>对应\n<code>petals</code></td>\n</tr>\n<tr>\n<td><code>_x</code></td>\n<td>对应\n<code>x</code></td>\n</tr>\n<tr>\n<td><code>_y</code></td>\n<td>对应\n<code>y</code></td>\n</tr>\n<tr>\n<td><code>c</code></td>\n<td>对应\n<code>c</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>关于贝塞尔曲线，<a href="http://bbs.csdn.net/topics/390358020">参考资料</a></li>\n</ul>\n<img src="/images/bezier3.gif" alt="IMG" width="240" height="100" />\n<center>图：三次贝塞尔曲线动态绘制效果</center>\n<img src="http://obu9je6ng.bkt.clouddn.com/FqrMRZZXMInLzy27Mc6CCWwHrC_v?imageslim" alt="ClipboardImage" width="746" height="725" />\n<center>图：花瓣与其贝塞尔曲线控制点</center>\n- 怎么使用？\n1.\t`<script src=\'drawflower.js\'></script>`\n2.\t`canvas.drawFlower(option);`\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-comment">//default option</span>\n{\n\t<span class="hljs-attr">animate</span>:<span class="hljs-literal">false</span>,\n\t<span class="hljs-attr">rotate</span>:<span class="hljs-number">90</span>,\n\t<span class="hljs-attr">randomSize</span>:<span class="hljs-literal">true</span>,\n\t<span class="hljs-attr">randomColor</span>:<span class="hljs-literal">true</span>,\n\t<span class="hljs-attr">randomPetals</span>: <span class="hljs-literal">true</span>,\n\t<span class="hljs-attr">pos</span>:{\n\t\t<span class="hljs-attr">x</span>:<span class="hljs-keyword">this</span>.width/<span class="hljs-number">2</span>,\n\t\t<span class="hljs-attr">y</span>:<span class="hljs-keyword">this</span>.height/<span class="hljs-number">2</span>\n\t}\n}</code></pre>\n<p>or</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">{\n\t<span class="hljs-attr">animate</span>:<span class="hljs-literal">true</span>,\n\t<span class="hljs-attr">rotate</span>:<span class="hljs-number">-20</span>,\n\t<span class="hljs-attr">randomSize</span>:<span class="hljs-literal">false</span>,\n\t<span class="hljs-attr">size</span>:<span class="hljs-number">10</span>,\n\t<span class="hljs-attr">randomColor</span>:<span class="hljs-literal">false</span>,\n\t<span class="hljs-attr">color</span>:[<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>],\n\t<span class="hljs-attr">randomPetals</span>: <span class="hljs-literal">false</span>,\n\t<span class="hljs-attr">petals</span>:<span class="hljs-number">6</span>,\n\t<span class="hljs-attr">pos</span>:{\n\t\t<span class="hljs-attr">x</span>:<span class="hljs-number">0</span>,\n\t\t<span class="hljs-attr">y</span>:<span class="hljs-number">0</span>\n\t}\n}</code></pre>\n<h2 id="动态绘制三次贝赛尔曲线"><a href="#%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF" aria-hidden="true"><span class="icon icon-link"></span></a>动态绘制三次贝赛尔曲线</h2>\n<h3 id="介绍-2"><a href="#%E4%BB%8B%E7%BB%8D-2" aria-hidden="true"><span class="icon icon-link"></span></a>介绍</h3>\n<p>应用canvas API, 事件绑定, 达到动态绘制三次贝赛尔曲线效果。</p>\n<h3 id="演示图片-2"><a href="#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-2" aria-hidden="true"><span class="icon icon-link"></span></a>演示图片</h3>\n<img src="/images/gif3.gif" alt="img" width="792" height="649" />\n<h3 id="代码解释-2"><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2" aria-hidden="true"><span class="icon icon-link"></span></a>代码解释</h3>\n<p>自己定义的<code>Pos</code> <code>Rect</code> <code>Circle</code> 类</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Pos</span>(<span class="hljs-params">x,y</span>)</span>{<span class="hljs-keyword">this</span>.x=x;<span class="hljs-keyword">this</span>.y=y;}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">p,r</span>)</span>{<span class="hljs-keyword">this</span>.p=p;<span class="hljs-keyword">this</span>.r=r;}\nCircle.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sty</span>)</span>{\n    ctx.save();\n    ctx.strokeStyle=sty||<span class="hljs-string">\'blue\'</span>;\n    ctx.beginPath();\n    ctx.arc(<span class="hljs-keyword">this</span>.p.x, <span class="hljs-keyword">this</span>.p.y, <span class="hljs-keyword">this</span>.r, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);\n    ctx.stroke();\n    ctx.restore();\n}\n<span class="hljs-comment">// p is in Circle?</span>\nCircle.prototype.around=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>)</span>{\n    <span class="hljs-keyword">return</span> (p.x-<span class="hljs-keyword">this</span>.p.x)*(p.x-<span class="hljs-keyword">this</span>.p.x)+ (p.y-<span class="hljs-keyword">this</span>.p.y)*(p.y-<span class="hljs-keyword">this</span>.p.y)&#x3C;=<span class="hljs-keyword">this</span>.r*<span class="hljs-keyword">this</span>.r;\n}\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rect</span>(<span class="hljs-params">p,w,h</span>)</span>{<span class="hljs-keyword">this</span>.p=p;<span class="hljs-keyword">this</span>.w=w;<span class="hljs-keyword">this</span>.h=h;};\nRect.prototype.draw = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">style</span>) </span>{\n    ctx.save();\n    ctx.strokeStyle=style||<span class="hljs-string">\'blue\'</span>;\n    <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">this</span>.w>>> <span class="hljs-number">1</span>,t = <span class="hljs-keyword">this</span>.h>>><span class="hljs-number">1</span>;\n    ctx.strokeRect(<span class="hljs-keyword">this</span>.p.x-v, <span class="hljs-keyword">this</span>.p.y-t,<span class="hljs-keyword">this</span>.w,<span class="hljs-keyword">this</span>.h);\n    ctx.restore();\n}\n<span class="hljs-comment">// p is in Rect?</span>\nRect.prototype.around = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>{\n    <span class="hljs-keyword">var</span> v = <span class="hljs-keyword">this</span>.w>>> <span class="hljs-number">1</span>,t = <span class="hljs-keyword">this</span>.h>>><span class="hljs-number">1</span>;\n    <span class="hljs-keyword">return</span> p.x>=<span class="hljs-keyword">this</span>.p.x-v &#x26;&#x26; p.x&#x3C;=<span class="hljs-keyword">this</span>.p.x+v &#x26;&#x26; p.y>=<span class="hljs-keyword">this</span>.p.y-t &#x26;&#x26; p.y&#x3C;=<span class="hljs-keyword">this</span>.p.y+t;\n}</code></pre>\n<p>初始化</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">var</span> midP = <span class="hljs-keyword">new</span> Pos(<span class="hljs-built_in">window</span>.innerWidth>>><span class="hljs-number">1</span>,<span class="hljs-built_in">window</span>.innerHeight>>><span class="hljs-number">1</span>),\n    sP = <span class="hljs-keyword">new</span> Circle(<span class="hljs-keyword">new</span> Pos(midP.x<span class="hljs-number">-100</span>,midP.y<span class="hljs-number">-100</span>),<span class="hljs-number">4</span>),\n    cP1= <span class="hljs-keyword">new</span> Rect(<span class="hljs-keyword">new</span> Pos(midP.x<span class="hljs-number">-80</span>,midP.y+<span class="hljs-number">10</span>),<span class="hljs-number">8</span>,<span class="hljs-number">8</span>),\n    cP2= <span class="hljs-keyword">new</span> Rect(<span class="hljs-keyword">new</span> Pos(midP.x+<span class="hljs-number">80</span>,midP.y+<span class="hljs-number">20</span>),<span class="hljs-number">8</span>,<span class="hljs-number">8</span>),\n    eP = <span class="hljs-keyword">new</span> Circle(<span class="hljs-keyword">new</span> Pos(midP.x+<span class="hljs-number">100</span>,midP.y+<span class="hljs-number">100</span>),<span class="hljs-number">4</span>);</code></pre>\n<p>绘制三次贝塞尔曲线</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawBezier</span>(<span class="hljs-params">ps</span>)</span>{\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(ps[<span class="hljs-number">0</span>].x,ps[<span class="hljs-number">0</span>].y);\n    ctx.bezierCurveTo(ps[<span class="hljs-number">1</span>].x,ps[<span class="hljs-number">1</span>].y,ps[<span class="hljs-number">2</span>].x,ps[<span class="hljs-number">2</span>].y,ps[<span class="hljs-number">3</span>].x,ps[<span class="hljs-number">3</span>].y);\n    ctx.stroke();\n    <span class="hljs-comment">// 自己实现的绘制虚线方法</span>\n    ctx.dashedLineTo(ps[<span class="hljs-number">0</span>].x,ps[<span class="hljs-number">0</span>].y,ps[<span class="hljs-number">1</span>].x,ps[<span class="hljs-number">1</span>].y);\n    ctx.dashedLineTo(ps[<span class="hljs-number">3</span>].x,ps[<span class="hljs-number">3</span>].y,ps[<span class="hljs-number">2</span>].x,ps[<span class="hljs-number">2</span>].y);\n    ctx.restore();\n}</code></pre>\n<p><code>ctx.dashedLineTo</code>方法</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">CanvasRenderingContext2D.prototype.dashedLineTo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fromX, fromY, toX, toY, pattern</span>) </span>{\n    <span class="hljs-comment">// default interval distance -> 5px</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pattern === <span class="hljs-string">"undefined"</span>) {\n        pattern = <span class="hljs-number">5</span>;\n    }\n    <span class="hljs-comment">// calculate the delta x and delta y</span>\n    <span class="hljs-keyword">var</span> dx = (toX - fromX);\n    <span class="hljs-keyword">var</span> dy = (toY - fromY);\n    <span class="hljs-keyword">var</span> distance = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.sqrt(dx*dx + dy*dy));\n    <span class="hljs-keyword">var</span> dashlineInteveral = (pattern &#x3C;= <span class="hljs-number">0</span>) ? distance : (distance/pattern);\n    <span class="hljs-keyword">var</span> deltay = (dy/distance) * pattern;\n    <span class="hljs-keyword">var</span> deltax = (dx/distance) * pattern;\n\n    <span class="hljs-comment">// draw dash line</span>\n    <span class="hljs-keyword">this</span>.beginPath();\n    <span class="hljs-keyword">var</span> f = <span class="hljs-number">1</span>;\n    <span class="hljs-keyword">while</span> (dashlineInteveral--><span class="hljs-number">0</span>){\n        <span class="hljs-keyword">if</span>(f) {\n            <span class="hljs-keyword">this</span>.lineTo(fromX, fromY);\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">this</span>.moveTo(fromX, fromY);\n        }\n        fromX += deltax; fromY += deltay; <span class="hljs-comment">// 增量法</span>\n        f = <span class="hljs-number">1</span>-f;\n    }\n    <span class="hljs-keyword">this</span>.stroke();\n};</code></pre>\n<p>鼠标事件绑定处理</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">canvas.addEventListener(<span class="hljs-string">\'mousedown\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e1</span>) </span>{\n    <span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Pos(e1.offsetX,e1.offsetY),c;\n    [sP,cP1,cP2,eP].every(<span class="hljs-function"><span class="hljs-params">ele</span>=></span>{\n        <span class="hljs-keyword">if</span>(ele.around(p1)){\n            c = ele;\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n        }\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    });\n    <span class="hljs-keyword">if</span>(c){\n        c.draw(<span class="hljs-string">\'red\'</span>);\n        canvas.addEventListener(<span class="hljs-string">\'mousemove\'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{\n            <span class="hljs-keyword">this</span>.mousemove = <span class="hljs-built_in">arguments</span>.callee;\n            <span class="hljs-keyword">if</span>(e.buttons===<span class="hljs-number">1</span>){<span class="hljs-comment">// left mouse pressed down</span>\n                <span class="hljs-keyword">var</span> pos = <span class="hljs-keyword">new</span> Pos(e.offsetX,e.offsetY);\n                c.p = pos;\n                rePaint([c]);\n                c.draw(<span class="hljs-string">\'red\'</span>);\n            }\n        });\n    }\n})\ncanvas.addEventListener(<span class="hljs-string">\'mouseup\'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{\n    <span class="hljs-keyword">this</span>.removeEventListener(<span class="hljs-string">\'mousemove\'</span>,<span class="hljs-keyword">this</span>.mousemove);\n    rePaint();\n});</code></pre>\n<p><code>rePaint(ignores)</code> 重新绘制函数</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-comment">// ignores 为跳过不重绘的点(Circle/Rect)</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rePaint</span>(<span class="hljs-params">ignores</span>)</span>{\n    ctx.save();\n    ctx.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,canvas.width,canvas.height);\n    <span class="hljs-keyword">if</span>(ignores==<span class="hljs-literal">null</span>){\n        cP1.draw();\n        cP2.draw();\n        sP.draw();\n        eP.draw();\n    }\n    <span class="hljs-keyword">else</span> {\n        [sP,cP1,cP2,eP].forEach(<span class="hljs-function"><span class="hljs-params">el</span>=></span>{\n            <span class="hljs-keyword">if</span>(ignores.indexOf(el)==<span class="hljs-number">-1</span>)\n                el.draw();\n        });\n    }\n    drawBezier([sP.p,cP1.p,cP2.p,eP.p]);\n    ctx.restore();\n}</code></pre>\n<h2 id="三维几何体的基本变换与组合变换应用"><a href="#%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2%E5%BA%94%E7%94%A8" aria-hidden="true"><span class="icon icon-link"></span></a>三维几何体的基本变换与组合变换应用</h2>\n<h3 id="介绍-3"><a href="#%E4%BB%8B%E7%BB%8D-3" aria-hidden="true"><span class="icon icon-link"></span></a>介绍</h3>\n<p>运用前端WebGL框架<a href="http://three.org">threejs</a>，结合相关矩阵变换知识完成。</p>\n<h3 id="演示图片-3"><a href="#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-3" aria-hidden="true"><span class="icon icon-link"></span></a>演示图片</h3>\n<img src="/images/gif4.gif" alt="img" width="1920" height="995" />\n<h3 id="代码解释-3"><a href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3" aria-hidden="true"><span class="icon icon-link"></span></a>代码解释</h3>\n<p><a href="/htm/4%E4%B8%89%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A25%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2.doc">三维基本变换组合变换文档参考下载</a></p>\n<ol>\n<li>\n<p>基本变换之平移变换\n<img src="http://obu9je6ng.bkt.clouddn.com/FlInRAsxX_jMvJHaZQvaKK0vF2O8?imageslim" alt="ClipboardImage" width="586" height="156" /></p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">var</span> matD = <span class="hljs-keyword">new</span> THREE.Matrix4();\n<span class="hljs-comment">//thressjs 封装的API，产生平移变换矩阵</span>\nmatD.makeTranslation(myctls[<span class="hljs-number">0</span>].x,myctls[<span class="hljs-number">0</span>].y,myctls[<span class="hljs-number">0</span>].z);\n<span class="hljs-comment">// mesh为几何体，将其矩阵与平移变换矩阵相乘</span>\nmesh.matrix.multiply(matD);</code></pre>\n</li>\n<li>\n<p>基本变换之比例变换\n<img src="http://obu9je6ng.bkt.clouddn.com/FpnmgsA3Km1IRwmog3nOD45TsJRb?imageslim" alt="ClipboardImage" width="531" height="141" /></p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">matD.makeScale(myctls[<span class="hljs-number">1</span>].x,myctls[<span class="hljs-number">1</span>].y,myctls[<span class="hljs-number">1</span>].z);\nmesh.matrix.multiply(matD);</code></pre>\n</li>\n<li>\n<p>组合变换之关于任意向量旋转</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">var</span> v3 = myctls[<span class="hljs-number">2</span>].vector.toVector3();\nmatD.makeRotationAxis(v3.normalize(),myctls[<span class="hljs-number">2</span>].degree/<span class="hljs-number">360</span>*<span class="hljs-built_in">Math</span>.PI)\nmesh.matrix.multiply(matD);</code></pre>\n</li>\n<li>\n<p>...</p>\n</li>\n</ol>\n<h1 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true"><span class="icon icon-link"></span></a>总结</h1>\n<ol>\n<li>学习巩固了相关图形学的知识。</li>\n<li>学习了相关前端技术对图形的处理方法。</li>\n<li>对于WebGL简单入门了，以后可以往更酷炫的3D效果靠近。</li>\n</ol>\n',
extra:{}}}});