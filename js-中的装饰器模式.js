webpackJsonp([73,113],{1191:function(s,a){s.exports={content:"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=背景><a href=#%E8%83%8C%E6%99%AF aria-hidden=true><span class=\"icon icon-link\"></span></a>背景</h2><p>使用过 mobx + mobx-react 的同学对于 ES 的新特性<strong>装饰器</strong>肯定不陌生。我在第一次使用装饰器的时候，我就对它爱不释手，书写起来简单优雅，太适合我这种爱装 X 且懒的同学了。今天我就带着大家深入浅出这个优雅的语法特性：装饰器。</p><h2 id=预备知识><a href=#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86 aria-hidden=true><span class=\"icon icon-link\"></span></a>预备知识</h2><ul><li>全球统一为 ECMAScript 新特性、语法制定统一标准的组织委员会是 TC39；</li><li>对于单个的新特性，TC39 有专门的<a href=https://tc39.es/process-document/>标准和阶段</a>去跟进该特性，也就是我们常说的 stage-0 到 stage-4，其中的新特性的成熟完备性从低到高；</li></ul><p>普及完一些必要的知识点后，我们继续进入到我们的主题：装饰器。</p><h2 id=演变过程><a href=#%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B aria-hidden=true><span class=\"icon icon-link\"></span></a>演变过程</h2><p>装饰器的制定过程也不是一帆风顺的，而且就算是2020年初的现在，这个备受争议的语法特性官方标准还在讨论制定当中，目前仍处于 <a href=https://github.com/tc39/proposal-decorators>stage-2: 草稿状态</a>。</p><p>但目前市面上 Babel、TypeScript 编译支持的装饰器语法主要包括两种方式，一个是 传统方式(legacy) 和目前<a href=https://tc39.es/proposal-decorators/>标准方式</a>。</p><p>由于目前标准还不是很成熟，编译器的支持并不全面，所以市面上大部分的装饰器库，大都只是兼容 legacy 方式，如 Mobx，如下为 Mobx 官网中的一段话：</p><blockquote><p>Note that the legacy mode is important (as is putting the decorators proposal first). Non-legacy mode is <a href=https://github.com/mobxjs/mobx/pull/1732>WIP</a>.</p></blockquote><p>下面我就从实际场景出发，来使用装饰器模式来实现我们常见的一些业务场景。</p><p><strong>注意：由于新版标准可以说是在 legacy 的方式下改造出来的，legacy 更加灵活，标准方式则主张静态配置去扩展实现装饰器功能</strong></p><h2 id=实际场景><a href=#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF aria-hidden=true><span class=\"icon icon-link\"></span></a>实际场景</h2><h3 id=需求><a href=#%E9%9C%80%E6%B1%82 aria-hidden=true><span class=\"icon icon-link\"></span></a>需求</h3><p>我希望实现一个 validate 修饰器，用于定义成员变量的校验规则，使用如下</p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-keyword>import</span> {validate, check} <span class=hljs-keyword>from</span> <span class=hljs-string>'validate'</span>\n\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Person</span> </span>{\n   @validate(<span class=hljs-function><span class=hljs-params>val</span> =></span> ![<span class=hljs-string>'M'</span>, <span class=hljs-string>'W'</span>].includes(val) &amp&amp <span class=hljs-string>'需要为 M 或者 W'</span>)\n   gender = <span class=hljs-string>'M'</span>\n}\n\n<span class=hljs-keyword>const</span> person = <span class=hljs-keyword>new</span> Person();\nperson.gender = <span class=hljs-literal>null</span>;\ncheck(person); <span class=hljs-comment>// => [{ name: 'gender', error: '需要为 M 或者 W' }]</span></code></pre><p>以上这种方式，相比于运行时 validate，如下</p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> check = <span class=hljs-function>(<span class=hljs-params>person</span>) =></span> {\n   <span class=hljs-keyword>const</span> errors = [];\n   <span class=hljs-keyword>if</span> (![<span class=hljs-string>'M'</span>, <span class=hljs-string>'W'</span>].includes(person.gender)) {\n      errors.push({<span class=hljs-attr>name</span>: <span class=hljs-string>'gender'</span>, <span class=hljs-attr>error</span>: <span class=hljs-string>'需要为 M 或者 W'</span>});\n   }\n   <span class=hljs-keyword>return</span> errors;\n}</code></pre><p>装饰器的方式能够更快捷的维护校验逻辑，更加具有表驱动程序的优势，只需要改配置即可。但是对于没有接触过装饰器模式模式的同学，深入改造装饰器内部的逻辑就有一定门坎了（但是不怕，这篇文章帮助大家降低门坎）。</p><h3 id=实现><a href=#%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\"icon icon-link\"></span></a>实现</h3><p><strong>由于目前 Babel 编译对于新版标准支持不是很完全，对于标准的装饰器模式实现有一定程度的影响，所以本文主要介绍 legacy 方式的实现</strong>，相信对于大家后续实现标准的装饰器也是有帮助的！</p><h4 id=思路整理><a href=#%E6%80%9D%E8%B7%AF%E6%95%B4%E7%90%86 aria-hidden=true><span class=\"icon icon-link\"></span></a>思路整理</h4><p>按照 api 的使用用例，我们可以知道，对于 person 实例是已经注入了 validate 校验逻辑的，然后在 <code>check</code> 方法中提取校验逻辑并执行即可。</p><pre><code data-query={} data-lang>@validate // 注入校验逻辑\n    |\n  check   // 提取校验逻辑并执行\n    |\n返回校验结果\n</code></pre><p>首先我们在 babel 配置中需要如下配置：</p><pre><code data-query={} data-lang>\"plugins\": [\n  [\n    \"@babel/proposal-decorators\",\n    {\n      \"legacy\": true\n    }\n  ],\n  [\"@babel/proposal-class-properties\", { \"loose\": true }]\n]\n</code></pre><p>对于我们需要实现的 <code>@validate</code> 装饰器结构如下：</p><pre><code data-query={} data-lang>// rule 为外界自定义校验逻辑\nfunction validate(rule) {\n  // target 为原型，也就是 Person.prototype\n  // keyName 为修饰的成员名，如 `gender`\n  // descriptor 为该成员的是修饰实体\n  return (target, keyName, descriptor) => {\n     // 注入 rule\n     target['check'] = target['check'] || {};\n     target['check'][keyName] = rule;\n     return descriptor;\n  }\n}\n</code></pre><p>根据上述逻辑，执行完 <code>@validate</code> 之后，在 <code>Person.prototype</code> 中会注入 <code>'check'</code> 属性，同时我们在 <code>check</code> 方法中拿到该属性即可进行校验。</p><p>那么我们是不是完成了该方法呢？其实还远远不够：</p><ol><li>首先，对于隐式注入的 <code>check</code> 属性需要足够隐藏，同时属性名 <code>check</code> 未免太容易被实例属性覆盖，从而不能通过原型链找到该属性</li><li>在类继承模式下，<code>check</code> 属性可能会丢失，甚至会污染校验规则</li></ol><p>首先我们来看第一个问题：改造我们的代码</p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> getInjectPropName =\n  <span class=hljs-keyword>typeof</span> <span class=hljs-built_in>Symbol</span> === <span class=hljs-string>'function'</span> ? <span class=hljs-function><span class=hljs-params>name</span> =></span> <span class=hljs-built_in>Symbol</span>.for(<span class=hljs-string>`[[<span class=hljs-subst>${name}</span>]]`</span>) : <span class=hljs-function><span class=hljs-params>name</span> =></span> <span class=hljs-string>`[[<span class=hljs-subst>${name}</span>]]`</span>\n\n<span class=hljs-keyword>const</span> addHideProps = <span class=hljs-function>(<span class=hljs-params>target, name, value</span>) =></span> {\n  <span class=hljs-built_in>Object</span>.defineProperty(target, name, {\n    <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,\n    <span class=hljs-attr>configurable</span>: <span class=hljs-literal>true</span>,\n    <span class=hljs-attr>writable</span>: <span class=hljs-literal>true</span>,\n    value\n  })\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>validate</span>(<span class=hljs-params>rule</span>) </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-function>(<span class=hljs-params>target, keyName, descriptor</span>) =></span> {\n     <span class=hljs-keyword>const</span> name = getInjectPropName(<span class=hljs-string>'check'</span>);\n     addHideProps(target, name, target[name] || {});\n     target[name][keyName] = rule;\n     <span class=hljs-keyword>return</span> descriptor;\n  }\n}</code></pre><p>相比于之前的代码实现，这样 <code>Object.keys(Person.prototype)</code> 不会包含 <code>check</code> 属性，同时也大大降低了属性命名冲突的问题。</p><p>对于第二个问题，类继承模式下的装饰器书写。如下例子：</p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Person</span> </span>{\n   @validate(<span class=hljs-function><span class=hljs-params>val</span> =></span> ![<span class=hljs-string>'M'</span>, <span class=hljs-string>'W'</span>].includes(val) &amp&amp <span class=hljs-string>'需要为 M 或者 W'</span>)\n   gender = <span class=hljs-string>'M'</span>\n\n   @validate(<span class=hljs-function><span class=hljs-params>a</span> =></span> !(a > <span class=hljs-number>10</span>) &amp&amp <span class=hljs-string>'需要大于10'</span>)\n   age = <span class=hljs-number>12</span>\n} \n\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Man</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Person</span> </span>{\n   @validate(<span class=hljs-function><span class=hljs-params>val</span> =></span> ![<span class=hljs-string>'M'</span>].includes(val) &amp&amp <span class=hljs-string>'需要为 M'</span>)\n   gender = <span class=hljs-string>'M'</span>\n}</code></pre><p>其中的原型链模型图如下</p><pre><code class=\"hljs language-text\"data-query={} data-lang=text>       person instance     +-------------------+\n          +----------+     |<span class=hljs-string>  Person.prototype </span>|\n          |<span class=hljs-string>__proto___+------>------------------+\n          </span>|<span class=hljs-string>         </span>|<span class=hljs-string>+     </span>|<span class=hljs-string>   rules           </span>|\n          +----------+     +-------+--+-+------+\n          |<span class=hljs-string>          </span>|<span class=hljs-string>             ^  ^ ^\n          </span>|<span class=hljs-string>          </span>|<span class=hljs-string>             </span>|<span class=hljs-string>  </span>|<span class=hljs-string> </span>|\n          |<span class=hljs-string>          </span>|<span class=hljs-string>                </span>|<span class=hljs-string> </span>|\n          +----------+             |<span class=hljs-string>  </span>|\n          |<span class=hljs-string> rules    +- -- -- -- --   </span>|<span class=hljs-string> </span>|\n          +----------+                |<span class=hljs-string>\n                                      </span>|<span class=hljs-string> </span>|\n                                      |<span class=hljs-string> </span>|\n                       person instance+\n                          +----------+  |<span class=hljs-string>\n                          </span>|<span class=hljs-string>__proto___</span>|<span class=hljs-string>  </span>|\nman instance              |<span class=hljs-string>         </span>|<span class=hljs-string>+\n        +-----------+     +----------+  </span>|\n        |<span class=hljs-string>__proto__  </span>|<span class=hljs-string>     </span>|<span class=hljs-string>          </span>|<span class=hljs-string>  </span>|\n        |<span class=hljs-string>           +---->+          </span>|\n        +-----------+     |<span class=hljs-string>          </span>|<span class=hljs-string>  </span>|\n        |<span class=hljs-string>           </span>|<span class=hljs-string>     +----------+\n        </span>|<span class=hljs-string>           </span>|<span class=hljs-string>     </span>|<span class=hljs-string> rules    </span>|<span class=hljs-string>  </span>|\n        |<span class=hljs-string>           </span>|<span class=hljs-string>     +---^------+\n        </span>|<span class=hljs-string>           </span>|<span class=hljs-string>                   </span>|\n        |<span class=hljs-string>           </span>|<span class=hljs-string>                   </span>|\n        +-----------+\n        |<span class=hljs-string> rules     </span>|<span class=hljs-string> - - - - - -- - - -+\n        +-----------+</span></code></pre><p>可以看到 man instance 和 person instance 共享同一份 rules，同时 <code>Man</code> 中的 <code>validate</code> 已经污染了共享的这份 rules，导致 <code>person instance</code> 校验逻辑</p><p>所以我们需要把原型模型修改为如下模式：</p><pre><code class=\"hljs language-text\"data-query={} data-lang=text>       person instance     +-------------------+\n          +----------+     |<span class=hljs-string>  Person.prototype </span>|\n          |<span class=hljs-string>__proto___+------>------------------+\n          </span>|<span class=hljs-string>         </span>|<span class=hljs-string>+     </span>|<span class=hljs-string>   rules           </span>|\n          +----------+     +-------+-----------+\n          |<span class=hljs-string>          </span>|<span class=hljs-string>             ^\n          </span>|<span class=hljs-string>          </span>|<span class=hljs-string>             </span>|\n          |<span class=hljs-string>          </span>|\n          +----------+             |<span class=hljs-string>\n          </span>|<span class=hljs-string> rules    +- -- -- -- --\n          +----------+\n\n\n                       person instance2\n                         Man.prototype\n                          +----------+\n                          </span>|<span class=hljs-string>__proto___</span>|\nman instance              |<span class=hljs-string>          </span>|\n        +-----------+     +----------+\n        |<span class=hljs-string>__proto__  </span>|<span class=hljs-string>     </span>|<span class=hljs-string>          </span>|\n        |<span class=hljs-string>           +---->+          </span>|\n        +-----------+     |<span class=hljs-string>          </span>|\n        |<span class=hljs-string>           </span>|<span class=hljs-string>     +----------+\n        </span>|<span class=hljs-string>           </span>|<span class=hljs-string>     </span>|<span class=hljs-string> rules    </span>|\n        |<span class=hljs-string>           </span>|<span class=hljs-string>     +---+------+\n        </span>|<span class=hljs-string>           </span>|<span class=hljs-string>         ^\n        </span>|<span class=hljs-string>           </span>|<span class=hljs-string>         </span>|\n        +-----------+         |<span class=hljs-string>\n        </span>|<span class=hljs-string> rules     </span>|<span class=hljs-string> - - - - +\n        +-----------+</span></code></pre><p>可以看到 <code>man instance</code> 和 <code>person instance</code> 都有一份 <code>rules</code> 在其原型链上，这样就不会有污染的问题，同时也不会丢失校验规则</p><p>修改我们的代码：</p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> getInjectPropName =\n  <span class=hljs-keyword>typeof</span> <span class=hljs-built_in>Symbol</span> === <span class=hljs-string>'function'</span> ? <span class=hljs-function><span class=hljs-params>name</span> =></span> <span class=hljs-built_in>Symbol</span>.for(<span class=hljs-string>`[[<span class=hljs-subst>${name}</span>]]`</span>) : <span class=hljs-function><span class=hljs-params>name</span> =></span> <span class=hljs-string>`[[<span class=hljs-subst>${name}</span>]]`</span>\n\n<span class=hljs-keyword>const</span> addHideProps = <span class=hljs-function>(<span class=hljs-params>target, name, value</span>) =></span> {\n  <span class=hljs-built_in>Object</span>.defineProperty(target, name, {\n    <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,\n    <span class=hljs-attr>configurable</span>: <span class=hljs-literal>true</span>,\n    <span class=hljs-attr>writable</span>: <span class=hljs-literal>true</span>,\n    value\n  })\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>validate</span>(<span class=hljs-params>rule</span>) </span>{\n  <span class=hljs-keyword>return</span> <span class=hljs-function>(<span class=hljs-params>target, keyName, descriptor</span>) =></span> {\n     <span class=hljs-keyword>const</span> name = getInjectPropName(<span class=hljs-string>'check'</span>);\n     <span class=hljs-comment>// 没有注入过 rules</span>\n     <span class=hljs-keyword>if</span> (!target[name]) {\n        addHideProps(target, name, {});\n     } <span class=hljs-keyword>else</span> {\n        <span class=hljs-comment>// 已经注入，但是是注入在 target.__proto__ 中</span>\n        <span class=hljs-comment>// 也就是继承模式</span>\n        <span class=hljs-keyword>if</span> (!target.hasOwnProperty(name)) {\n           <span class=hljs-comment>// 浅拷贝一份至 own</span>\n           addHideProps(target, name, {...target[name]})\n        }\n     }\n\n     target[name][keyName] = rule;\n     <span class=hljs-keyword>return</span> descriptor;\n  }\n}</code></pre><p>如上，才算是我们完备的代码！而且 mobx 也是有相同场景的考虑的。</p><h2 id=总结><a href=#%E6%80%BB%E7%BB%93 aria-hidden=true><span class=\"icon icon-link\"></span></a>总结</h2><p>总结是把以上模式沉淀为 <a href=https://github.com/imcuttle/decorate-utils>decorate-utils</a> 方便我们自定义自己的修饰器</p>",extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=js-中的装饰器模式.js.map