<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> 自研协同文档服务 - Dozo  - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="1722186545"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">自研协同文档服务 - Dozo </h1><div class="post-info" data-reactid="12"><time datetime="2020-05-17T15:16:28+00:00" data-reactid="13">May 17, 2020 3:16 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p data-reactid="17"><!-- react-text: 18 -->最近一段时间，疫情爆发，对于全球工作人员复工提出了新的挑战！<!-- /react-text --><strong data-reactid="19">远程办公，远程授课</strong><!-- react-text: 20 -->成为刚需。 对于远程办公，肯定离不开一个词：<!-- /react-text --><strong data-reactid="21">协同</strong><!-- react-text: 22 -->。对于我们日常工作最常见的工作输出载体：文档，也离不开协同<!-- /react-text --></p><p data-reactid="23"><!-- react-text: 24 -->如下图，为个人实现的协同编辑服务 - Dozo 的示意图： <!-- /react-text --><img src="https://i.loli.net/2020/05/17/ypOQxwzKYXtHloE.gif" alt="dozo.gif" data-reactid="25"/></p><p data-reactid="26">相比于市面上成熟的商用协同产品：如 yuque、feishu、腾讯文档、石墨文档...，只能是小巫见大巫，但是对于个人使用，团队内使用还是值得一试的，后续将会开源，敬请期待。</p><p data-reactid="27">下面将对 Dozo 的功能、架构设计和实现展开说明。</p><h2 id="dozo-功能介绍" data-reactid="28"><a href="#dozo-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" aria-hidden="true" data-reactid="29"><span class="icon icon-link" data-reactid="30"></span></a><!-- react-text: 31 -->Dozo 功能介绍<!-- /react-text --></h2><h3 id="协同编辑" data-reactid="32"><a href="#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91" aria-hidden="true" data-reactid="33"><span class="icon icon-link" data-reactid="34"></span></a><!-- react-text: 35 -->协同编辑<!-- /react-text --></h3><p data-reactid="36">如上图，Dozo 能够协同编辑，会实时同步其他用户的编辑光标</p><h3 id="评论" data-reactid="37"><a href="#%E8%AF%84%E8%AE%BA" aria-hidden="true" data-reactid="38"><span class="icon icon-link" data-reactid="39"></span></a><!-- react-text: 40 -->评论<!-- /react-text --></h3><p data-reactid="41"><!-- react-text: 42 -->如下图，Dozo 文档支持行评论 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/PeGhkHyu1zWpo8b.png" alt="image.png" data-reactid="43"/></p><h3 id="分享" data-reactid="44"><a href="#%E5%88%86%E4%BA%AB" aria-hidden="true" data-reactid="45"><span class="icon icon-link" data-reactid="46"></span></a><!-- react-text: 47 -->分享<!-- /react-text --></h3><p data-reactid="48"><!-- react-text: 49 -->如下图，Dozo 文档支持对外分享，发送分享链接至被分享人 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/jQErMP8evfynwKm.png" alt="image.png" data-reactid="50"/></p><p data-reactid="51">可以设置密码，设置外部访问的权限：可读或可写</p><h3 id="权限控制" data-reactid="52"><a href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6" aria-hidden="true" data-reactid="53"><span class="icon icon-link" data-reactid="54"></span></a><!-- react-text: 55 -->权限控制<!-- /react-text --></h3><p data-reactid="56"><!-- react-text: 57 -->除了分享文档设置读写权限以外，还可以设置文档权限，可以设置为 完全公开、组织内可见、私有，如下 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/1zRK98CYQjxvmHb.png" alt="image.png" data-reactid="58"/></p><p data-reactid="59"><!-- react-text: 60 -->同时，组织的拥有者和管理员，能够管理组织成员 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/jgDLZSnzvJ95xYa.png" alt="image.png" data-reactid="61"/></p><h3 id="内容搜索" data-reactid="62"><a href="#%E5%86%85%E5%AE%B9%E6%90%9C%E7%B4%A2" aria-hidden="true" data-reactid="63"><span class="icon icon-link" data-reactid="64"></span></a><!-- react-text: 65 -->内容搜索<!-- /react-text --></h3><p data-reactid="66"><!-- react-text: 67 -->Dozo 基于 Elasticsearch 实现了自己权限内的内容搜索 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/FytTm3NIJa5KcZw.png" alt="image.png" data-reactid="68"/></p><h3 id="文稿模板" data-reactid="69"><a href="#%E6%96%87%E7%A8%BF%E6%A8%A1%E6%9D%BF" aria-hidden="true" data-reactid="70"><span class="icon icon-link" data-reactid="71"></span></a><!-- react-text: 72 -->文稿模板<!-- /react-text --></h3><p data-reactid="73"><!-- react-text: 74 -->可以设置文稿类型为模板，从而可以从新文稿中选择模板 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/LsA56fkSI4ytJgU.png" alt="image.png" data-reactid="75"/></p><p data-reactid="76"><img src="https://i.loli.net/2020/05/20/FGkby4IKRwLhaf5.png" alt="image.png" data-reactid="77"/></p><h3 id="消息通知" data-reactid="78"><a href="#%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5" aria-hidden="true" data-reactid="79"><span class="icon icon-link" data-reactid="80"></span></a><!-- react-text: 81 -->消息通知<!-- /react-text --></h3><p data-reactid="82">当有人对你的文稿评论，或者文档中 @ 你，你将会收到邮件通知</p><p data-reactid="83"><img src="https://i.loli.net/2020/05/20/K7LbPip3ahlv9Vs.png" alt="image.png" data-reactid="84"/></p><h2 id="dozo-架构设计--实现" data-reactid="85"><a href="#dozo-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E5%AE%9E%E7%8E%B0" aria-hidden="true" data-reactid="86"><span class="icon icon-link" data-reactid="87"></span></a><!-- react-text: 88 -->Dozo 架构设计 &amp; 实现<!-- /react-text --></h2><h3 id="dozo-前端" data-reactid="89"><a href="#dozo-%E5%89%8D%E7%AB%AF" aria-hidden="true" data-reactid="90"><span class="icon icon-link" data-reactid="91"></span></a><!-- react-text: 92 -->Dozo 前端<!-- /react-text --></h3><ul data-reactid="93"><li data-reactid="94">React</li><li data-reactid="95">Antd</li><li data-reactid="96">Mobx</li><li data-reactid="97">Socket.IO Client</li><li data-reactid="98">Slate.js</li></ul><h3 id="dozo-后端" data-reactid="99"><a href="#dozo-%E5%90%8E%E7%AB%AF" aria-hidden="true" data-reactid="100"><span class="icon icon-link" data-reactid="101"></span></a><!-- react-text: 102 -->Dozo 后端<!-- /react-text --></h3><ul data-reactid="103"><li data-reactid="104">Express</li><li data-reactid="105">Socket.IO</li><li data-reactid="106">Redis</li><li data-reactid="107">Elasticsearch</li><li data-reactid="108">MySQL</li></ul><h3 id="协同编辑的实现" data-reactid="109"><a href="#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E7%9A%84%E5%AE%9E%E7%8E%B0" aria-hidden="true" data-reactid="110"><span class="icon icon-link" data-reactid="111"></span></a><!-- react-text: 112 -->协同编辑的实现<!-- /react-text --></h3><p data-reactid="113"><!-- react-text: 114 -->前端使用 <!-- /react-text --><code data-reactid="115">slate.js</code><!-- react-text: 116 --> 实现富文本编辑器，其中 <!-- /react-text --><code data-reactid="117">slate.js</code><!-- react-text: 118 --> 能够将每一次的操作抽象成自己的数据模型 <!-- /react-text --><code data-reactid="119">Operation</code><!-- react-text: 120 -->，于是我们只需要每一次操作，传递该操作的 <!-- /react-text --><code data-reactid="121">operation</code><!-- react-text: 122 --> 数据至服务端，通过服务端广播该 <!-- /react-text --><code data-reactid="123">operation</code><!-- react-text: 124 --> 至其他客户端即可。这样就能达到不同客户端之间的操作同步，同时我们还需要把文稿进行持久化存储。<!-- /react-text --></p><p data-reactid="125"><!-- react-text: 126 -->在第一个连接建立后，服务端从数据库中读取文稿数据至内存中，并输出至客户端；当服务端获取来自客户端的 <!-- /react-text --><code data-reactid="127">operation</code><!-- react-text: 128 --> 之后，更新于服务端内存中的文稿对象；并且会节流的写入数据库，防止服务崩溃导致数据丢失；同时在某一篇文稿的客户端连接全部断开后，会把服务端文稿写入数据库；这样能有效的减少数据库的写操作。<!-- /react-text --></p><h3 id="分布式--集群" data-reactid="129"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F--%E9%9B%86%E7%BE%A4" aria-hidden="true" data-reactid="130"><span class="icon icon-link" data-reactid="131"></span></a><!-- react-text: 132 -->分布式 &amp; 集群<!-- /react-text --></h3><p data-reactid="133"><!-- react-text: 134 -->Dozo 服务的架构如下，由 8 个分布式子服务组成，各个节点又可以构成各自的集群，如下图 <!-- /react-text --><img src="https://i.loli.net/2020/05/20/GVq7U8R1Pb4wHhX.png" alt="未命名绘图.png" data-reactid="135"/></p><p data-reactid="136">其中：</p><ul data-reactid="137"><li data-reactid="138">web: HTTP Web Service，负责主要的业务逻辑</li><li data-reactid="139">fileman: 负责文件处理上传、存储</li><li data-reactid="140">static: 前端静态服务</li><li data-reactid="141">ws: Websocket service，协同实现的服务端关键</li><li data-reactid="142">worker: 负责处理其他任务，如发送通知，邮件；推送文档数据至 elasticsearch</li><li data-reactid="143">其他 redis / elasticsearch / mysql 服务就不多介绍了，第三方十分主流的服务</li></ul><h4 id="多节点集群的搭建" data-reactid="144"><a href="#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA" aria-hidden="true" data-reactid="145"><span class="icon icon-link" data-reactid="146"></span></a><!-- react-text: 147 -->多节点集群的搭建<!-- /react-text --></h4><p data-reactid="148">使用多节点集群和负载均衡，可以大幅度减少单节点的并发数；其中 web / fileman / static 服务多节点集群的搭建比较简单，直接搭配负载均衡，分流到不同节点即可；但是对于 websocket 服务来说，多节点服务并不简单！</p><p data-reactid="149">其中有以下问题：</p><ol data-reactid="150"><li data-reactid="151"><p data-reactid="152">对于 socket.io 来说，建立连接之前，会一段（多个）HTTP请求响应的通信，这时候需要始终保存与固定的 ws 服务通信，所以不能通过简单的轮询来负载均衡，需要通过 ip 网段映射表来分流（会话保持），可就是同一个 ip 始终走同一个 ws 服务；</p></li><li data-reactid="153"><p data-reactid="154"><!-- react-text: 155 -->多个不同 ws 服务之间需要共享数据，共享 socket 通道；<!-- /react-text --><br data-reactid="156"/><!-- react-text: 157 -->如，ws1 服务有 a b 客户端连接，ws2 服务有 c d 客户端连接；这时候 ws1 如何才能知道整体 ws 服务当前有多少客户端连接？ ws1 可以通过 redis 发布 getSockets 消息，ws2 在订阅 getSockets 消息后，返回 ws2 所有的 sockets，从而 ws1 通过 ws2.sockets 和 ws1.sockets 合并，即可获取整体 ws 服务的 sockets；<!-- /react-text --><br data-reactid="158"/><!-- react-text: 159 -->又如，ws1 服务需要对整体 ws 客户端广播发送 hello 消息，除了需要对自身 ws1 进程中的 sockets 进行广播；还需要广播消息 <!-- /react-text --><code data-reactid="160">{type: &#x27;broadcase&#x27;, value: &#x27;hello&#x27;}</code><!-- react-text: 161 -->, ws2 / ws3 /... 接受消息后，也在当前进程广播消息 <!-- /react-text --><code data-reactid="162">hello</code><!-- react-text: 163 -->；<!-- /react-text --></p></li><li data-reactid="164"><p data-reactid="165"><!-- react-text: 166 -->在上文提到的协同编辑实现原理的简单介绍中，我们知道 ws 服务进程在内存中是有文稿数据的；这样设计在单节点的时候就没有问题的，但是多节点情境下，该方案是不可行的，随时可能会有数据不同步，数据覆盖的问题出现；<!-- /react-text --><br data-reactid="167"/><!-- react-text: 168 -->鉴于以上问题，所以考虑把文稿数据存入单节点 redis 中，通过对单节点 redis 内存的读写操作，避免数据覆盖问题；<!-- /react-text --></p><p data-reactid="169"><strong data-reactid="170">但是</strong><!-- react-text: 171 -->这样问题就解决了吗？如某时刻有客户端操作发送至 ws1 节点，ws1 服务端正常的流程如下：<!-- /react-text --></p><pre data-reactid="172"><code data-query="{}" data-lang="data-lang" data-reactid="173">async applyOperation(operation) {
   // 从 redis 获取文稿
   const doc = await redis.getDocument()  // 1
   // 更新 doc
   applyOperationToDoc(doc, operation)  // 2
   // 写入 doc
   await redis.setDocument(doc) // 3
}
</code></pre><p data-reactid="174">当 ws1 节点完成 1 之后，进入 2 之前，这时 ws2 也收到 operation，同时 ws2 也完成 1；这样后续 ws1 / ws2 接着后续流程，可以看到，很可能会丢失掉某批次客户端的操作，至于该问题如何解决，先卖个关子，后续持续完善。</p></li></ol></article></div><div class="gitment-container" data-reactid="175"></div><div class="paginator" data-reactid="176"><a title="Web 前端 敏感数据加密 &amp; 安全保护策略" class="prev" href="/web-前端-敏感数据加密-安全保护策略" data-reactid="177">Prev</a><a title="自定义 React.createElement" class="next" href="/自定义-react-createelement" data-reactid="178">Next</a></div></div></main><footer data-reactid="179"><div class="copyright" data-reactid="180"><p data-reactid="181"><!-- react-text: 182 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="183">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
