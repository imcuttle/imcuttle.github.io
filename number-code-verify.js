webpackJsonp([52,113],{1212:function(a,e){a.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id=verifycode><a href=#verifycode aria-hidden=true><span class="icon icon-link"></span></a>VerifyCode</h1><p>Java 实现的数字验证码识别, ...准确率不是很高, 模式识别和去噪处理的不是很好, 但学习入门已经够了，</p><p>而且！！！已经运用至之前做的教务系统的验证码识别</p><!--more--><p>整体的流程结构</p><img src=false alt=ClipboardImage width=823 height=595 data-src=http://obu9je6ng.bkt.clouddn.com/FjF5YYLISm4gTezikrNep3RISdDW?imageslim><h1 id=识别思路><a href=#%E8%AF%86%E5%88%AB%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>识别思路</h1><p>首先，得到图片数据，如</p><img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/Fq0DWmDYGc-hjV-gW7UJArsx2ClO?imageslim><p>然后我试着对图片进行各种处理，比如...</p><ol><li><p>变成灰化图 <img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/FubU9uTrN3cnPhPnuO5bOQykn5eG?imageslim></p></li><li><p>去噪...好像效果不明显 <img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/Ft_mbtLqREICr8bOaFyi5zEC0W2b?imageslim></p></li><li><p>对灰化图去噪 <img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/FosHgQkXuW3B-xmlrhUK6aqYfeIC?imageslim></p></li><li><p>灰化图转成二值图（阈值128） <img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/Fm7deFoygmibuLpMu3fD87I6_Pjn?imageslim></p></li><li><p>原图转成二值图（阈值128） <img src=false alt=ClipboardImage width=66 height=26 data-src=http://obu9je6ng.bkt.clouddn.com/Fm7deFoygmibuLpMu3fD87I6_Pjn?imageslim></p></li><li><p>对二值图膨胀运算 <img src=false alt=ClipboardImage width=70 height=30 data-src=http://obu9je6ng.bkt.clouddn.com/FhITj_7bt_Wq_h1p8TeThRlaL3Wi?imageslim></p></li><li><p>对二值图腐蚀运算 <img src=false alt=ClipboardImage width=70 height=30 data-src=http://obu9je6ng.bkt.clouddn.com/Fjgst5D9y5GEDzhmDlyyn7EZomQs?imageslim></p></li><li><p>对二值图开运算 (先腐蚀后膨胀) <img src=false alt=ClipboardImage width=70 height=30 data-src=http://obu9je6ng.bkt.clouddn.com/FhJ9RJll2ol5i2imagXHgvQSNPib?imageslim></p></li><li><p>对二值图闭运算 (先膨胀后腐蚀) <img src=false alt=ClipboardImage width=70 height=30 data-src=http://obu9je6ng.bkt.clouddn.com/FrdLH6OY1OsJ8v11HhpaiON_q43d?imageslim></p></li></ol><p>多次实验对比后，发现还是对原图的二值化图最好处理。</p><p>然后，便是将图片中的数字分割为固定大小的图片（固定大小是为了后续的模式学习与识别）</p><p>其实在这里我可以使用一种比较无赖的方式处理，将这种有规律的数字验证码按照像素点位置进行分割，</p><p>但是这样做就没意思了...，所以我选择了用深度优先搜索算法（利用堆栈结构，如果递归，会导致栈溢出），</p><p>并且带标记（防止重复处理处理过的点），将八连通的集合分割出来</p><img src=false alt=ClipboardImage width=427 height=347 data-src=http://obu9je6ng.bkt.clouddn.com/FkK1GV7Np4iV8QNWLqvupBvPD9S3?imageslim> <img src=false alt=ClipboardImage width=632 height=530 data-src=http://obu9je6ng.bkt.clouddn.com/Fu5_Ay5Jkg1eiU6i4X5vpNOU3krr?imageslim><p>效果如下</p><img src=false alt=ClipboardImage width=10 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/FgwUfefH7e0ruE-yCg4iVDnlNFwN?imageslim> <img src=false alt=ClipboardImage width=8 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/FrQ5LqtTGxpX7vPTxSRkAtpYQUzV?imageslim> <img src=false alt=ClipboardImage width=11 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/FkhARQBT0IdX6-S2euZ7i0pHH42X?imageslim> <img src=false alt=ClipboardImage width=11 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/FlXueQN2XdLsPvHne09vp7Bczmo4?imageslim><p>当然二值图中的噪点会影响字符的划分</p><p>最后便是模式识别算法的选择了，我没有选中书上与网上说的基于向量距离的方法，而是自己想了一个方法，所以识别能力有限...</p><p>思路是：先将将一些已知数字的样本进行存储为一串字符串，白色存为"0"，黑色为"1"</p><p>效果如下</p><img src=false alt=ClipboardImage width=10 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/FkB74y5to0WAqFUxD9Ot8NiDmmd4?imageslim><pre><code data-query={} data-lang>0111111111\n0111111111\n0111111111\n1100000011\n1000000011\n0000000110\n0000000110\n0000001100\n0001001100\n0000001100\n0000011000\n0000011000\n0000011000\n0000110000\n0000110000\n0000110000\n</code></pre><img src=false alt=ClipboardImage width=10 height=16 data-src=http://obu9je6ng.bkt.clouddn.com/Fh2IM_GGns3WCSWAQ_FKWEyiij5s?imageslim><pre><code data-query={} data-lang>0000000110\n0000000110\n0000001110\n0000011110\n0000101110\n0001001110\n0001001110\n0010001110\n0100001110\n1000001110\n1111111111\n1111111111\n0000001110\n0000001110\n0000001110\n0000001110\n</code></pre><p>将图像编码完成后，对比待识别图片与10种数字样本之间字符"1"的位置吻合度，最高的即为识别出来的数字</p><img src=false alt=ClipboardImage width=697 height=523 data-src=http://obu9je6ng.bkt.clouddn.com/Fv0mcAA5fwfpfmtsEeuDVIccS3ev?imageslim><p>但是这种方法容易将3，5，8识别错误，或者因为分割的不成功而导致的识别错误。</p><p>最后！提下Node调用Java的方法</p><p>目前我用的是<code>child_process</code>创建新进程，在新进程调用Java，传人图片文件地址进行处理。</p><p>但是！这种方法每次都需要重新启动Java，训练样本需要重新载入，效率是个问题。</p><p>2016/07/25更新!!! 改用 <code>WebService</code> 进行通信!</p><h1 id=代码地址><a href=#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80 aria-hidden=true><span class="icon icon-link"></span></a>代码地址</h1><ul><li><p>Java源码 <a href=https://github.com/moyuyc/VerifyCode>VerifyCode</a></p></li><li><p>一键查分（运用该技术） <a href=https://github.com/moyuyc/njnu-quick-get-score>njnu-quick-get-score</a></p></li></ul><h1 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>参考资料</h1><p>形态学运算</p><p><a href=http://blog.csdn.net/bagboy_taobao_com/article/details/5574159>http://blog.csdn.net/bagboy_taobao_com/article/details/5574159</a> <a href=http://blog.csdn.net/hellousb2010/article/details/37939809>http://blog.csdn.net/hellousb2010/article/details/37939809</a></p><p>字符分割</p><p><a href=https://www.zhihu.com/question/19702292>https://www.zhihu.com/question/19702292</a> <a href=http://www.voidcn.com/blog/beechina/article/p-5761020.html>http://www.voidcn.com/blog/beechina/article/p-5761020.html</a></p><p>PDF 299 模式识别</p>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=number-code-verify.js.map