webpackJsonp([7,90],{1056:function(s,n){s.exports={content:'<p>题目：刷脸签到系统<br>\n姓名：余聪</p>\n<p>最近几周主要完成了web前端页面的开发，与后端接口的开发。</p>\n<p>界面如下：\n1. 学生签到\n<img src="https://ooo.0o0.ooo/2017/01/22/588485d5c5134.jpg" alt="学生签到-1" width="1440" height="810">\n<img src="https://ooo.0o0.ooo/2017/01/22/58848618b06ff.jpg" alt="学生签到-2" width="1440" height="810"></p>\n<ol start="2">\n<li>\n<p>人脸录入\n<img src="https://ooo.0o0.ooo/2017/04/11/58ecc6f371fe7.jpg" width="1345" height="721"/></p>\n</li>\n<li>\n<p>关于\n<img src="https://ooo.0o0.ooo/2017/01/22/588486cf622d8.jpg" alt="" width="1440" height="810"></p>\n</li>\n<li>\n<p>管理员入口\n<img src="https://ooo.0o0.ooo/2017/01/22/588486ef8446d.jpg" alt="" width="1440" height="810"></p>\n</li>\n</ol>\n<p>前后端架构如下图：\n<img src="https://ooo.0o0.ooo/2017/04/11/58ecc1672afba.jpg" width="379" height="219"/></p>\n<img src="https://ooo.0o0.ooo/2017/01/22/58848833b7414.jpg" alt="系统模块" width="770" height="401">\n<h2 id="前端"><a href="#%E5%89%8D%E7%AB%AF" aria-hidden="true"><span class="icon icon-link"></span></a>前端</h2>\n<ol>\n<li>\n<p>前端采用SPA（ single page web application，单页web应用 ）架构。<br>\nSPA是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。 浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由 JavaScript 来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。</p>\n</li>\n<li>\n<p>使用主流 Webpack 构建，进行前端模块自动化管理。</p>\n</li>\n<li>\n<p>使用Facebook提出的 React 框架进行 View 开发， 将 HTML DOM 进行上层抽象，提出 Virtual DOM 概念，一套理念，实现了Server render, Web UI, mobile UI 的统一。 Learn Once, Write Anywhere\n<img src="https://ooo.0o0.ooo/2017/01/23/5884d71e7ed1d.jpg" alt="ClipboardImage" width="623" height="396"></p>\n</li>\n<li>\n<p>使用 HTML5 的 getUserMedia 方法，调用计算机音频视频等硬件设备。为了安全问题，Chrome 只能在本地地址上调用该方法</p>\n</li>\n<li>\n<p>WebWorker: 利用 Web Worker 起一个进程代码，主要做的是输入图片数据，输出人脸的位置大小，就是 JavaScript 版的人脸检测，之所以起另一个线程，是因为对于视频的人脸检测，对于实时性要求也比较高，检测也比较耗时，为了效率考虑使用了Web Worker多进程。</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ol>\n<h2 id="后端"><a href="#%E5%90%8E%E7%AB%AF" aria-hidden="true"><span class="icon icon-link"></span></a>后端</h2>\n<ol>\n<li>采用 nodeJs 作为后端，采用 JavaScript 脚本语言开发。 nodeJs 具有异步事件驱动、非阻塞（non-blocking）IO 特性，采用 Google 的 V8 引擎来执行代码。</li>\n<li>isomorphic render（同构渲染）： 指的是前后端使用同一份代码。前端通过 Webpack 实现 CommonJs 的模块规范（Node亦是 CommonJs ）+ React 提出的 JSX ，使得 NodeJs 通过解析请求的 URL，适配 react-router 中的前端路由规则，得到 routing Props，还可以 dispatch(action) 同步或异步（一般是 isomorphic-fetch ），又或是直接读取数据，从而更新 store ，最后 nodeJs 通过 store 中的 state 渲染 JSX ，产生静态的 HTML，从而实现了前后端的同构渲染。<img src="https://ooo.0o0.ooo/2017/01/23/5884dc559b020.jpg" alt="isomorphic render" width="640" height="400"></li>\n<li>Express（Node.js Web 应用程序框架），很方便的定义 restful api. 十分适合 spa 的架构</li>\n<li>...</li>\n</ol>\n<h2 id="文件结构"><a href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84" aria-hidden="true"><span class="icon icon-link"></span></a>文件结构</h2>\n<pre><code data-query="{}" data-lang="">app/ # 前端目录\n├── App.js          # 父组件(Container)\n├── common/         # 一些通用的资源或模块\n├── components/     # 一些封装的组件\n├── index.tpl.html  # html模板\n├── main.js         # 入口文件\n├── pages/          # 所有页面\n├── reducers/       # 数据修改集合\n├── router.js       # 路由定义\n└── workers/        # WebWorker：用于前端页面的人脸检测，多线程\n\ngp-njnu-photos-backend/ # 后端代码目录\n├── cache.json          # 学生帐号和密码验证结果的缓存\n├── cpptest/            # 一些c++ opencv测试的代码\n├── data/               # 一些数据文件：级联分类器/预处理后的人脸/人脸特征数据/...\n├── database/           # 数据库访问代码，主要是人脸录入表\n├── index.js            # 入口\n├── lib/                # 一些 library\n├── opencv/             # node-opencv \n├── package.json        \n├── pretreat/           # 预处理代码\n├── provider.js         # 开发环境下的入口\n├── readme.md           # 说明\n├── routes/             # express路由定义\n├── server.js           # http服务 入口\n├── ssl/                # https 证书\n└── test/               # 一些测试\n</code></pre>\n<h2 id="部分代码解读"><a href="#%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB" aria-hidden="true"><span class="icon icon-link"></span></a>部分代码解读</h2>\n<h3 id="开发环境（热部署）脚本"><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88%E7%83%AD%E9%83%A8%E7%BD%B2%EF%BC%89%E8%84%9A%E6%9C%AC" aria-hidden="true"><span class="icon icon-link"></span></a>开发环境（热部署）脚本</h3>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-comment">// gp-njnu-photos-backend/provider.js</span>\n<span class="hljs-comment">// language: javascript</span>\n<span class="hljs-comment">// env: node</span>\n<span class="hljs-comment">// usage: (cd gp-njnu-photos-backend &#x26;&#x26; npm run dev:w)</span>\n\n<span class="hljs-keyword">var</span> cp = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'child_process\'</span>)\n<span class="hljs-keyword">var</span> p = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'path\'</span>)\n<span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'fs\'</span>)\n\n<span class="hljs-keyword">const</span> isDir = <span class="hljs-function">(<span class="hljs-params">filepath</span>) =></span> fs.statSync(filepath).isDirectory()\n\n<span class="hljs-comment">/* 去除掉 非文件夹，node_modules文件夹，`.`开头的文件夹 */</span>\n<span class="hljs-keyword">const</span> children = fs.readdirSync(__dirname).filter(<span class="hljs-function"><span class="hljs-params">n</span>=></span>n!=<span class="hljs-string">\'node_modules\'</span> &#x26;&#x26; !n.startsWith(<span class="hljs-string">\'.\'</span>) &#x26;&#x26; isDir(p.join(__dirname, n)));\n\n[__dirname].concat(children).forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =></span> fs.watch(dir, watchHandle))\n\n<span class="hljs-comment">/* 监听到文件被修改则触发 */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">watchHandle</span> (<span class="hljs-params">type, filename</span>) </span>{\n    <span class="hljs-comment">// 无视不是js文件和点开头命名的文件</span>\n    <span class="hljs-keyword">if</span>(filename.startsWith(<span class="hljs-string">\'.\'</span>) || !filename.endsWith(<span class="hljs-string">".js"</span>)) {\n        <span class="hljs-keyword">return</span>;\n    }\n\n    <span class="hljs-built_in">console</span>.log(type, filename);\n    <span class="hljs-comment">// 杀死内存中的服务器进程</span>\n    serverProcess.kill(<span class="hljs-string">\'SIGINT\'</span>);\n    serverProcess = runServer();\n}\n\n<span class="hljs-keyword">var</span> serverProcess = runServer();\n<span class="hljs-comment">/* fork index.js 进程 */</span>\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runServer</span>(<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">return</span> cp.fork(<span class="hljs-string">\'./index.js\'</span>, process.argv, {<span class="hljs-attr">stdio</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">\'ipc\'</span>]})\n}</code></pre>\n<h3 id="服务器自动更新代码"><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81" aria-hidden="true"><span class="icon icon-link"></span></a>服务器自动更新代码</h3>\n<ul>\n<li>服务器端  </li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-comment">// gp-njnu-photos-backend/routes/control.js</span>\n\n<span class="hljs-comment">/* 访问 /api/ctrl/pull 服务器执行 git pull，从 github 更新代码 */</span>\nctrl.all(<span class="hljs-string">\'/pull\'</span>, (req, res) => {\n    res.writeHead(<span class="hljs-number">200</span>, {\n        <span class="hljs-string">\'Content-Type\'</span>: <span class="hljs-string">\'text/event-stream\'</span>,\n        <span class="hljs-string">\'Cache-Control\'</span>: <span class="hljs-string">\'no-cache\'</span>,\n        <span class="hljs-string">\'Connection\'</span>: <span class="hljs-string">\'keep-alive\'</span>\n    });\n    <span class="hljs-keyword">var</span> ls = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'child_process\'</span>).spawn(<span class="hljs-string">\'git\'</span>, [<span class="hljs-string">\'pull\'</span>, <span class="hljs-string">\'origin\'</span>, <span class="hljs-string">\'master\'</span>])\n    ls.stdout.on(<span class="hljs-string">\'data\'</span>, (data) => {\n        data = data.toString()\n        <span class="hljs-built_in">console</span>.log(data)\n        res.write(<span class="hljs-string">`<span class="hljs-subst">${data}</span>`</span>);\n    });\n\n    ls.stderr.on(<span class="hljs-string">\'data\'</span>, (data) => {\n        data = data.toString()\n        <span class="hljs-built_in">console</span>.log(data)\n        res.write(<span class="hljs-string">`<span class="hljs-subst">${data}</span>`</span>);\n    });\n    ls.on(<span class="hljs-string">\'close\'</span>, (code) => {\n        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`child process exited with code <span class="hljs-subst">${code}</span>`</span>)\n        res.end(<span class="hljs-string">`child process exited with code <span class="hljs-subst">${code}</span>`</span>);\n    });\n\n})</code></pre>\n<ul>\n<li>本机（开发机）</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-meta">#!/bin/bash</span>\n\nmsg=<span class="hljs-string">"from bash"</span>\n<span class="hljs-keyword">if</span> [ -n <span class="hljs-string">"$1"</span> ]; then\n    msg=$<span class="hljs-number">1</span>\n    # 重新 build 前端代码\n    (cd gp-njnu-photos-app &#x26;&#x26; npm run build)\nfi\n\ngit add .\ngit commit -m <span class="hljs-string">"$msg"</span>\ngit push\n\n# 如果push成功（exitcode=<span class="hljs-number">0</span>），则访问远端 /api/ctrl/pull，从而服务器也更新了代码\n<span class="hljs-keyword">if</span> [ $? = <span class="hljs-number">0</span> ]; then\n    curl https:<span class="hljs-comment">//face.moyuyc.xyz/api/ctrl/pull</span>\nfi</code></pre>\n',extra:{}}}});