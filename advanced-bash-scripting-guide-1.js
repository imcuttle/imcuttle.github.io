webpackJsonp([85,90],{978:function(n,a){n.exports={content:'<p>原文：<a href="http://www.tldp.org/LDP/abs/abs-guide.pdf">Advanced Bash-Scripting Guide</a></p>\n<p>部分<a href="https://github.com/moyuyc/advanced-bash-scripting-learning">学习代码</a></p>\n<p>只做部分翻译，一些个人遗漏的点。</p>\n<h3 id="关于脚本头"><a href="#%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E5%A4%B4" aria-hidden="true"><span class="icon icon-link"></span></a>关于脚本头</h3>\n<p>Bash 中头部 <code>#!</code> ，如果没有用上 Bash 专用的语法（比如 A=abc，赋值语句），是可以被不加上。</p>\n<p><code>#!/bin/sh</code> 调用的是默认的 Shell 解释器，在 Linux 中是 <code>/bin/bash</code></p>\n<h3 id="参数个数到数组长度"><a href="#%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%88%B0%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6" aria-hidden="true"><span class="icon icon-link"></span></a>参数个数到数组长度</h3>\n<p>下面脚本中，<code>$#</code> 是参数数组的长度，可以用下面脚本判断参数的输入</p>\n<pre><code class="hljs language-sh" data-query="{}" data-lang="sh"><span class="hljs-meta">#!/bin/sh\n</span>\nE_WRONG_ARGS=85\nscript_parameters=<span class="hljs-string">"-a -h -m -z"</span>\nNumber_of_expected_args=1\n<span class="hljs-comment"># -a = all, -h = help, etc.</span>\n<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne <span class="hljs-variable">$Number_of_expected_args</span> ]\n<span class="hljs-keyword">then</span>\n <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: `basename <span class="hljs-variable">$0</span>` <span class="hljs-variable">$script_parameters</span>"</span>\n <span class="hljs-comment"># `basename $0` is the script\'s filename.</span>\n <span class="hljs-built_in">exit</span> <span class="hljs-variable">$E_WRONG_ARGS</span>\n<span class="hljs-keyword">fi</span></code></pre>\n<p>上面例子可以看到<code>#</code>可以表示一个数组（字符串）的长度，如下例</p>\n<pre><code data-query="{}" data-lang="">arr=(a b c) &#x26;&#x26; str=string &#x26;&#x26; echo ${#arr}-${#str} # 3-6\n</code></pre>\n<h3 id="脚本的执行方法"><a href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>脚本的执行方法</h3>\n<p>比如有<code>sh scriptname.sh</code> <code>bash scriptname.sh</code>，当然还有 <code>sh &#x3C; scriptname.sh</code>  ( 这种方法不建议，因为不能在脚本中读 <code>stdin</code> )。最方便的方法还是，直接用<code>chmod</code>变成可执行（executable）文件。</p>\n<pre><code data-query="{}" data-lang="">chmod 555 scriptname # readable/executable for all\nchmod +rx scriptname # readable/executable for all\nchmod u+rx scriptname # readable/executable for user\n</code></pre>\n<h3 id="字符-"><a href="#%E5%AD%97%E7%AC%A6-" aria-hidden="true"><span class="icon icon-link"></span></a>字符 <code>#</code></h3>\n<ol>\n<li>\n<p>普通字符<code>#</code>\necho "hello\\n# comment\\nworld" | \\\nsed -e \'/#/d\' | # 删除带有<code>#</code>字符的行 \\<br>\ntr -d \'\\n\' | # 删除换行符 \\<br>\nsed -e \'s/world/,Bash scripting/g\'  # 字符替换</p>\n</li>\n<li>\n<p>字符串匹配\nstr=abc123456123ABC\necho ${str#<em>123}  # 删除 str 中匹配</em>123的 最短匹配\necho ${str##<em>123} # 删除 str 中匹配</em>123的 贪心匹配</p>\n</li>\n<li>\n<p>数字表达式\necho $((2#101011))  # 二进制的101011</p>\n</li>\n</ol>\n<h3 id="字符--1"><a href="#%E5%AD%97%E7%AC%A6--1" aria-hidden="true"><span class="icon icon-link"></span></a>字符 <code>;</code></h3>\n<p>在同一行中执行多条指令</p>\n<pre><code data-query="{}" data-lang="">echo one; echo two\n\nif [ true ]; then  # ; 不能少, if/then 两条指令\n    echo "true statement"\nfi\n</code></pre>\n<h3 id="双分号-"><a href="#%E5%8F%8C%E5%88%86%E5%8F%B7-" aria-hidden="true"><span class="icon icon-link"></span></a>双分号 <code>;;</code></h3>\n<p>在 case 选项中</p>\n<pre><code data-query="{}" data-lang="">variable=abc\ncase "$variable" in\n    abc)  echo "\\$variable = abc" ;;\n    xyz)  echo "\\$variable = xyz" ;;\nesac\n</code></pre>\n<h3 id="逗号-"><a href="#%E9%80%97%E5%8F%B7-" aria-hidden="true"><span class="icon icon-link"></span></a>逗号 <code>,</code></h3>\n<p>字符串的拼接</p>\n<pre><code data-query="{}" data-lang="">ls /usr{,/lib} # 列出 `/usr` 和 `/usr/lib` 下的文件\nmv file{,B}.txt # file.txt -> fileB.txt\n</code></pre>\n<h3 id="冒号-"><a href="#%E5%86%92%E5%8F%B7-" aria-hidden="true"><span class="icon icon-link"></span></a>冒号 <code>:</code></h3>\n<p>nop 操作，空操作，退出状态为0</p>\n<pre><code data-query="{}" data-lang="">not-exist-command; echo $?\n\nnot-exist-command; :; echo $?\n</code></pre>\n<p>选择符</p>\n<pre><code data-query="{}" data-lang="">a=123\nb=456\necho ${a:-$b} # 123\n\na=\nb=456\necho ${a:-$b} # 456\n</code></pre>\n<h3 id="-与-"><a href="#-%E4%B8%8E-" aria-hidden="true"><span class="icon icon-link"></span></a>"<code></code>" 与 $()</h3>\n<p>指令运行输出结果赋值给某变量</p>\n<pre><code data-query="{}" data-lang="">files=(*); echo ${files[@]} # or ${files}\necho $(ls)\necho `ls`\n</code></pre>\n<h3 id="通配符"><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6" aria-hidden="true"><span class="icon icon-link"></span></a>通配符</h3>\n<p>在 Unix 文件系统中，有 <code>*</code>、<code>?</code>、<code>[]</code></p>\n<pre><code data-query="{}" data-lang="">echo /usr/*    # * 配对任意长，任意字符\necho /usr/li?  # ? 配对一个字符\necho /usr/li[a-z]\n</code></pre>\n<h3 id="--三目运算符"><a href="#--%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6" aria-hidden="true"><span class="icon icon-link"></span></a><code>? :</code> 三目运算符</h3>\n<pre><code data-query="{}" data-lang="">((x = 2>0?123:456)); echo $x\n</code></pre>\n<h3 id=""><code>$$</code></h3>\n<pre><code data-query="{}" data-lang="">echo $$;   # process ID\n</code></pre>\n<h3 id="-扩充"><a href="#-%E6%89%A9%E5%85%85" aria-hidden="true"><span class="icon icon-link"></span></a><code>{}</code> 扩充</h3>\n<p><code>{}</code> 内不允许任何空格，除非是转义后或是引号内</p>\n<ol>\n<li>\n<p>字符串组合\necho \\"{These,words,are,quoted}\\"   # " prefix and suffix</p>\n<pre><code data-query="{}" data-lang=""># "These" "words" "are" "quoted"\n\ncp file22.{txt,backup}\n# Copies "file22.txt" to "file22.backup"\n\necho {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z\n# Echoes characters between a and z.\necho {0..3} # 0 1 2 3\n# Echoes characters between 0 and 3.\nbase64_charset=( {A..Z} {a..z} {0..9} + / = )\n\necho {file1,file2}\\ :{\\ A," B",\' C\'}\n# file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C\necho {file1,file2} :{\\ A," B",\' C\'}\n# file1 file2 : A : B : C\n</code></pre>\n</li>\n<li>\n<p>代码块</p>\n<pre><code class="hljs language-bash" data-query="{}" data-lang="bash"><span class="hljs-meta">#!/bin/sh</span>\n<span class="hljs-comment"># readfile line by line</span>\nFile=<span class="hljs-variable">${me=`basename "$0"`}</span>\n{\n    <span class="hljs-built_in">read</span> line1\n    <span class="hljs-built_in">read</span> line2\n} &#x3C; <span class="hljs-variable">$File</span>\n<span class="hljs-built_in">echo</span> <span class="hljs-string">"First line in <span class="hljs-variable">$File</span> is:"</span>\n<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$line1</span>"</span>\n<span class="hljs-built_in">echo</span>\n<span class="hljs-built_in">echo</span> <span class="hljs-string">"Second line in <span class="hljs-variable">$File</span> is:"</span>\n<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$line2</span>"</span></code></pre>\n<pre><code class="hljs language-bash" data-query="{}" data-lang="bash"><span class="hljs-meta">#!/bin/sh</span>\n<span class="hljs-comment"># output save to out.html</span>\n{\n    <span class="hljs-built_in">echo</span> <span class="hljs-string">"&#x3C;html>"</span>\n    <span class="hljs-built_in">echo</span> <span class="hljs-string">"&#x3C;head>&#x3C;/head>"</span>\n    <span class="hljs-built_in">echo</span> <span class="hljs-string">"&#x3C;body>&#x3C;h1>Output&#x3C;/h1>&#x3C;/body>"</span>\n    <span class="hljs-built_in">echo</span> <span class="hljs-string">"&#x3C;/html>"</span>\n} > out.html\n\nopen out.html</code></pre>\n</li>\n</ol>\n<h3 id="后台进程-"><a href="#%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B-" aria-hidden="true"><span class="icon icon-link"></span></a>后台进程 <code>&#x26;</code></h3>\n<p><code>&#x26;</code> 不仅仅可以用于单条指令，对于一个完整的语句块也是可以的。</p>\n<pre><code data-query="{}" data-lang="">for i in 1 2 3 4 5 6 7 8 9 10\ndo\n  echo -n "$i "\ndone &#x26;\n</code></pre>\n<h3 id="对的误解"><a href="#%E5%AF%B9%E7%9A%84%E8%AF%AF%E8%A7%A3" aria-hidden="true"><span class="icon icon-link"></span></a>对<code>&#x26;&#x26;</code>的误解</h3>\n<p><code>&#x26;&#x26;</code> 并不是无条件的顺序执行下一条指令，而是需要上一条指令 <code>exit code</code> 等于 0。</p>\n<pre><code data-query="{}" data-lang="">(exit 1) &#x26;&#x26; echo 123  # print nothing.\n(exit 1); echo 123    # print 123.\n</code></pre>\n<h3 id="比较操作符"><a href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6" aria-hidden="true"><span class="icon icon-link"></span></a>比较操作符</h3>\n<pre><code data-query="{}" data-lang="">#!/usr/bin/env bash\n\nfiles=(*.sh)\nfile1=${files[1]}\nfile2=${files[2]}\n\nif [ $file1 -ot $file2 ]\nthen #      ^\n  echo "File $file1 is older than $file2."\nfi\n\na=123\nb=123\n\nif [ "$a" -eq "$b" ]\nthen #    ^\n  echo "$a is equal to $b."\nfi\n\nc=24\nd=47\n\nif [ "$c" -eq 24 -a "$d" -eq 47 ] # [[ "$c" = 24 &#x26;&#x26; "$d" = 47 ]]\nthen #    ^              ^\n  echo "$c equals 24 and $d equals 47."\nfi\n</code></pre>\n<h3 id="--的扩展"><a href="#--%E7%9A%84%E6%89%A9%E5%B1%95" aria-hidden="true"><span class="icon icon-link"></span></a><code>-</code> 的扩展</h3>\n<p><code>-</code> 除了是对于指令的选项，如 <code>ls -al</code> ，还可以表示 <code>stdio</code></p>\n<pre><code data-query="{}" data-lang="">tar cf - .  #stdout\n# The \'c\' option \'tar\' archiving command creates a new archive,\n# the \'f\' (file) option, followed by \'-\' designates the target file\n# as stdout, and do it in current directory tree (\'.\').\n\ntar xpvf -  #stdin\n# Unarchive (\'x\'), preserve ownership and file permissions (\'p\'),\n# and send verbose messages to stdout (\'v\'),\n# reading data from stdin (\'f\' followed by \'-\').\n\nfile -  #stdin\n\ndiff file.js - # stdin\n</code></pre>\n<p><code>cd -</code> 可以对 pwd 的切换，主要是保存了 OLDPWD</p>\n<pre><code data-query="{}" data-lang="">cd /\ncd ~\necho $OLDPWD\necho $PWD\n</code></pre>\n<h3 id="其他符号"><a href="#%E5%85%B6%E4%BB%96%E7%AC%A6%E5%8F%B7" aria-hidden="true"><span class="icon icon-link"></span></a>其他符号</h3>\n<pre><code data-query="{}" data-lang="">echo ~+   # echo $PWD\necho ~-   # echo $OLDPWD\n</code></pre>\n<h3 id="有用的快捷键"><a href="#%E6%9C%89%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE" aria-hidden="true"><span class="icon icon-link"></span></a>有用的快捷键</h3>\n<ol>\n<li>Ctl - Z  挂起前台进程</li>\n<li>Ctl - T  交换 2 个相邻字符</li>\n<li>Ctl - W  删除左边一个单词</li>\n<li>Ctl - X  选择高亮</li>\n<li>Ctl - Y  插入之前删除的文本（Ctl - W/U）</li>\n<li>Ctl - R  搜索历史指令</li>\n<li>Ctl - S  中断控制台输出</li>\n<li>Ctl - Q  恢复控制台输出</li>\n</ol>\n<h3 id="ifs-内部域分隔符"><a href="#ifs-%E5%86%85%E9%83%A8%E5%9F%9F%E5%88%86%E9%9A%94%E7%AC%A6" aria-hidden="true"><span class="icon icon-link"></span></a><code>IFS</code> 内部域分隔符</h3>\n<pre><code data-query="{}" data-lang="">#!/bin/sh\n\noutput_args_one_per_line()\n{\n    arg_list=$*\n    echo "\\$*=\'$*\'"\n    for arg in $arg_list\n    do\n        echo "[$arg]"\n    done\n}\n\nx="a b c d e"\nIFS=\' \'\noutput_args_one_per_line $x\n\nx="a b c"$\'\\t\'"d e"\nIFS=$\'\\t\'\noutput_args_one_per_line $x\n</code></pre>\n<h3 id="-与--1"><a href="#-%E4%B8%8E--1" aria-hidden="true"><span class="icon icon-link"></span></a><code>$*</code> 与 <code>$@</code></h3>\n<pre><code data-query="{}" data-lang=""> IFS=";"\n set x y z\n echo $*    # x y z\n echo "$*"  # x;y;z\n echo "$@"  # x y z\n</code></pre>\n',extra:{}}}});