<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> 多叉树的差异对比算法与应用 - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="842947300"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">多叉树的差异对比算法与应用</h1><div class="post-info" data-reactid="12"><time datetime="2019-02-03T23:43:25+00:00" data-reactid="13">Feb 3, 2019 11:43 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id="问题" data-reactid="17"><a href="#%E9%97%AE%E9%A2%98" aria-hidden="true" data-reactid="18"><span class="icon icon-link" data-reactid="19"></span></a><!-- react-text: 20 -->问题<!-- /react-text --></h2><p data-reactid="21">在书写 markdown 文本的时候，为了追求好的体验，需要在 markdown 预览页面中，高亮且定位在正在编辑的节点上，如图</p><p data-reactid="22"><img src="https://i.loli.net/2018/10/28/5bd58a95c6b7d.gif" data-reactid="23"/></p><p data-reactid="24">很显然，这个问题需要转换成两颗树（抽象语法树）的差异对比，</p><h2 id="思考" data-reactid="25"><a href="#%E6%80%9D%E8%80%83" aria-hidden="true" data-reactid="26"><span class="icon icon-link" data-reactid="27"></span></a><!-- react-text: 28 -->思考<!-- /react-text --></h2><p data-reactid="29">如例子，将树 A 与树 B 对比，相对于树 A 来说，它的哪些节点有改动呢？</p><p data-reactid="30"><img src="https://i.loli.net/2019/02/04/5c581a4fc921f.png" data-reactid="31"/></p><center data-reactid="32">树 A</center><p data-reactid="33"><img src="https://i.loli.net/2019/02/04/5c581a856fab4.png" data-reactid="34"/></p><center data-reactid="35">树 B</center><p data-reactid="36">那么首先对于某节点来说，有哪些类型的改动呢？</p><ul data-reactid="37"><li data-reactid="38">更新 (updated)</li><li data-reactid="39">删除 (removed)</li><li data-reactid="40">某节点存在新增的子节点 (has-added-child)</li><li data-reactid="41">存在子节点被更新（包括存在子节点被删除、新增、更新） (child-changed)</li></ul><p data-reactid="42">对于树 A 来说，其节点的更改类型如下图，</p><p data-reactid="43"><img src="https://i.loli.net/2019/02/07/5c5c4341682fe.png" data-reactid="44"/></p><center data-reactid="45">树 A 的节点更改类型</center><h3 id="算法" data-reactid="46"><a href="#%E7%AE%97%E6%B3%95" aria-hidden="true" data-reactid="47"><span class="icon icon-link" data-reactid="48"></span></a><!-- react-text: 49 -->算法<!-- /react-text --></h3><h4 id="基本概念" data-reactid="50"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" aria-hidden="true" data-reactid="51"><span class="icon icon-link" data-reactid="52"></span></a><!-- react-text: 53 -->基本概念<!-- /react-text --></h4><ul data-reactid="54"><li data-reactid="55"><strong data-reactid="56">E(A)</strong><!-- react-text: 57 -->：表示树 A 的 E 节点<!-- /react-text --></li><li data-reactid="58"><strong data-reactid="59">Paths(E(A))</strong><!-- react-text: 60 -->: E(A) 节点的路径<!-- /react-text --><br data-reactid="61"/><!-- react-text: 62 -->从 A(A)（根节点）向下寻找 F(A) 节点，经过 B(A) 节点和 F(A) 节点，其中 B(A) 在相对于 A(A) 索引 0 的位置，F(A) 在相对 B(A) 索引 1 的位置，所以 <!-- /react-text --><strong data-reactid="63">Paths(F(A)) = [0, 1]</strong></li><li data-reactid="64"><strong data-reactid="65">向上回溯</strong><!-- react-text: 66 -->：从节点往上依次寻找祖先节点<!-- /react-text --></li></ul><h4 id="流程描述" data-reactid="67"><a href="#%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0" aria-hidden="true" data-reactid="68"><span class="icon icon-link" data-reactid="69"></span></a><!-- react-text: 70 -->流程描述<!-- /react-text --></h4><ol data-reactid="71"><li data-reactid="72">对树 A 进行后续遍历</li><li data-reactid="73">遍历 X(A) 节点，根据 Paths(X(A)) 寻找到 Y(B)，若未找到 Y(B)，X(A) 标记为 removed，并且向上回溯，标记 child-changed；若找到，进行对比。若节点内容不同，标记为 updated，并且向上回溯，标记 child-changed；若 X(A) 孩子数小于 Y(B) 孩子数，标记为 has-added-child，并且向上回溯，标记 child-changed</li></ol><p data-reactid="74"><img src="https://i.loli.net/2019/02/07/5c5c44497df63.png" data-reactid="75"/></p><center data-reactid="76">树 A 和树 B 对比流程示意</center><p data-reactid="77">以上，只需要遍历一遍树 A (O(n)) 即可标记出所有的变化信息，但是在根据树 A 节点寻找对应树 B 节点需要 O(lgn) ~ O(n) 时间复杂度，所以最终的时间复杂度未 O(nlgn) ~ O(n^2)，下面将会讲述如何优化寻找对应树 B 节点的时间复杂度。</p><h4 id="根据路径寻找节点时间的优化" data-reactid="78"><a href="#%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%AF%BB%E6%89%BE%E8%8A%82%E7%82%B9%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96" aria-hidden="true" data-reactid="79"><span class="icon icon-link" data-reactid="80"></span></a><!-- react-text: 81 -->根据路径寻找节点时间的优化<!-- /react-text --></h4><p data-reactid="82"><!-- react-text: 83 -->还是以上面的例子为例，在第一次遍历中，需要根据路径 <!-- /react-text --><code data-reactid="84">[0, 0]</code><!-- react-text: 85 --> 定位 E(B)；第二次遍历中，根据路径 <!-- /react-text --><code data-reactid="86">[0, 1]</code><!-- react-text: 87 --> 定位 null，<!-- /react-text --><strong data-reactid="88"><!-- react-text: 89 -->但其实这个时候，我们应该是知道路径 <!-- /react-text --><code data-reactid="90">[0]</code><!-- react-text: 91 --> 和 <!-- /react-text --><code data-reactid="92">[0, 0]</code><!-- react-text: 93 --> 对应树 B 上的节点<!-- /react-text --></strong><!-- react-text: 94 -->，所以快捷使用 <!-- /react-text --><code data-reactid="95">[0]</code><!-- react-text: 96 --> 路径对应的树 B 节点，然后再定位至 <!-- /react-text --><code data-reactid="97">[0, 1]</code><!-- react-text: 98 --> 节点即可，以上便是动态规划 (Dynamic programming) 的思想。<!-- /react-text --></p><h2 id="实现与应用" data-reactid="99"><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8" aria-hidden="true" data-reactid="100"><span class="icon icon-link" data-reactid="101"></span></a><!-- react-text: 102 -->实现与应用<!-- /react-text --></h2><ul data-reactid="103"><li data-reactid="104"><a href="https://github.com/imcuttle/detect-tree-changed" data-reactid="105">detect-tree-changed</a><!-- react-text: 106 --> - 多叉树的差异对比<!-- /react-text --></li><li data-reactid="107"><a href="https://github.com/imcuttle/detect-one-changed" data-reactid="108">detect-one-changed</a><!-- react-text: 109 --> - 检测 html 和 markdown 第一个更新的 ast 节点<!-- /react-text --></li><li data-reactid="110"><a href="https://github.com/imcuttle/live-markd" data-reactid="111">live-markd</a><!-- react-text: 112 --> - Github Favorite Markdown preview with live rendering &amp; location and highlight changed block.<!-- /react-text --></li><li data-reactid="113"><a href="https://github.com/picidaejs/picidaejs" data-reactid="114">picidae</a><!-- react-text: 115 --> - The document generator which has gentle experience.<!-- /react-text --></li></ul></article></div><div class="gitment-container" data-reactid="116"></div><div class="paginator" data-reactid="117"><a title="如何实现 “灭霸” 响指动效" class="prev" href="/about-snap-fade-away" data-reactid="118">Prev</a><a title="本地实时书写 markdown + 同步定位修改节点" class="next" href="/talk-about-live-markd" data-reactid="119">Next</a></div></div></main><footer data-reactid="120"><div class="copyright" data-reactid="121"><p data-reactid="122"><!-- react-text: 123 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="124">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
