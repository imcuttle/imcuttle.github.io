webpackJsonp([15,90],{1048:function(s,n){s.exports={content:'<p>node.js 以异步方式、事件队列为标准，基本每一套与网络、IO 相关的 API 都会设计成异步的。</p>\n<p>如，一段很平常的请求代码，用 node.js 只能用异步方式。</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'https\'</span>);\n\nhttps.get(<span class="hljs-string">"https://nodejs.org/api/https.html"</span>, res => res.pipe(process.stdout))</code></pre>\n<p>异步方式不会阻塞进程，充分利用 CPU。</p>\n<p>但是，对于一些一次性的脚本、批处理，我们希望使用同步的方式。因为以上情形，对于效率要求不是十分迫切，更多的是需要清晰的代码结构，简明的代码逻辑。</p>\n<p>本人在之前的 <a href="https://github.com/moyuyc/node-markdown-image-size">markdown-image-size</a> 中，有这么个需求：</p>\n<blockquote>\n<p>浏览器在未加载完图片数据的时候，浏览器是不知道其大小的\n所以，默认大小都是 0，除非通过 style 设置了大小\n之后的某个时候，图片加载完成，浏览器得到图片大小，文章就会有跳动的感觉，阅读体验不佳</p>\n<p>解决该问题，将 markdown 文本中的 <code>![](src)</code> 和 <code>&#x3C;img src="src" /></code> 中的 <code>src</code> 匹配出来，如果是本地文件则读文件，得到图片大小；或者发送请求，得到图片数据进而得到图片大小，最后进行字符串 替换/插入，成为如下的 HTML 格式文本。</p>\n<p><code>&#x3C;img width="100" height="100" src="url" /></code></p>\n</blockquote>\n<p>在这种情况下，同步的网络请求比异步的请求会更加合适，代码更加清晰，逻辑更简单，而且对代码效率要求不高。如下，便是简化后的同步请求，文本替换的代码。</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">content.replace(<span class="hljs-regexp">/!\\[(.*)\\]\\((.*?[^\\\\])\\)/g</span>, (matched, alt, src) => {\n    <span class="hljs-comment">// get image data from src synchronously</span>\n    <span class="hljs-keyword">const</span> data = getData(src);\n    <span class="hljs-keyword">const</span> size = sizeOf(data);\n    <span class="hljs-keyword">return</span> <span class="hljs-string">`&#x3C;img alt=<span class="hljs-subst">${alt}</span> src=<span class="hljs-subst">${src}</span> width=<span class="hljs-subst">${size.width}</span> height=<span class="hljs-subst">${size.height}</span> />`</span>\n})</code></pre>\n<p>如果使用的是异步，则不能在第二个参数中直接 return 替换后的文本了，就需要更加复杂的代码逻辑（如标记文本的位置和长度，待请求结束后，进行替换）。</p>\n<p>那么具体应该如何实现 node.js 的同步请求呢？</p>\n<!--more-->\n<p>谷歌 "sync request in nodejs" </p>\n<p>搜索结果中出来一个 <a href="https://www.npmjs.com/package/sync-request">sync-request</a>，<code>npm install</code> 后果然能够同步网络请求，这顿时勾起了我的兴趣：在一个官方没有提供同步请求 api 的情况下，该第三方包是怎么实现请求的同步的呢？</p>\n<p>阅读源码之后才发现作者十分巧妙的将异步问题转化成了同步问题，分析如下。</p>\n<h2 id="sync-request"><a href="#sync-request" aria-hidden="true"><span class="icon icon-link"></span></a><code>sync-request</code></h2>\n<p>在 <a href="https://github.com/ForbesLindesay/sync-request#how-is-this-possible">readme</a> 中，作者有这样一段话：</p>\n<blockquote>\n<h3 id="how-is-this-possible"><a href="#how-is-this-possible" aria-hidden="true"><span class="icon icon-link"></span></a>How is this possible?</h3>\n<p>Internally, this uses a separate worker process that is run using childProcess.spawnSync.</p>\n<p>The worker then makes the actual request using then-request so this has almost exactly the same API as that.</p>\n<p>This can also be used in a web browser via browserify because xhr has built in support for synchronous execution. Note that this is not recommended as it will be blocking.</p>\n</blockquote>\n<p>简言之作者实际上发送请求是用的 <a href="https://github.com/then/then-request"><code>then-request</code></a>，对官方的异步 API 用 Promise 进行封装，所以其是异步请求方式。</p>\n<p>异步转化同步方式，主要是借助了 <code>childProcess.spawnSync</code> 方法，创建<strong>同步进程</strong>。</p>\n<p>阅读源码之后，基本的流程如下：</p>\n<img src="http://obu9je6ng.bkt.clouddn.com/FqF0tsO2D-38ngCbsbAbtprHwDH8?imageslim" width="748" height="453"/>\n<p>首先需要 <code>nc</code> 指令的作用，以及标准输入输出如何传递字节数组。</p>\n<p>man page 中对 <code>nc</code> 的介绍为：</p>\n<blockquote>\n<p> nc -- arbitrary TCP and UDP connections and listens<br>\nusage: nc <options> [hostname]port[s]]</p>\n</blockquote>\n<p>就是一个底层的系统调用，用于建立 TCP/UDP 连接或者监听某端口的，由于是系统调用，所以速度更快，效率更高。</p>\n<p>标准输入输出如何传递字节数组，就需要将字节数组转化成字符串，然后在处理之前转化成字节数组，默认 nodejs 实现是将 Buffer 序列化为 <code>{"type":"Buffer","data":[1,2,3,4,5]}</code>，分成2个字段表示，但是这样是不能够反序列化回来的。</p>\n<p>则需要重写 JSON 序列化的方法，主要是对 Buffer 的处理。</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringify</span> (<span class="hljs-params">o</span>) </span>{\n    <span class="hljs-keyword">if</span>(o &#x26;&#x26; Buffer.isBuffer(o)) <span class="hljs-comment">// hex, ascii 都是可以的</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">\':base64:\'</span> + o.toString(<span class="hljs-string">\'base64\'</span>));\n    <span class="hljs-keyword">if</span> (<span class="hljs-string">\'string\'</span> === <span class="hljs-keyword">typeof</span> o) {\n        <span class="hljs-comment">// 避免将 buffer 误认为 string</span>\n        <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-regexp">/^:/</span>.test(o) ? <span class="hljs-string">\':\'</span> + o : o)\n    }\n    <span class="hljs-comment">// 其他维持原样</span>\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">o</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(s, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) </span>{\n        <span class="hljs-keyword">if</span>(<span class="hljs-string">\'string\'</span> === <span class="hljs-keyword">typeof</span> value) {\n          <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/^:base64:/</span>.test(value))\n            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Buffer(value.substring(<span class="hljs-number">8</span>), <span class="hljs-string">\'hex\'</span>)\n          <span class="hljs-keyword">else</span> <span class="hljs-comment">// string</span>\n            <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^:/</span>.test(value) ? value.substring(<span class="hljs-number">1</span>) : value\n        }\n        <span class="hljs-keyword">return</span> value\n    })\n}</code></pre>\n<p>理解了以上之后，再来具体看看代码</p>\n<ul>\n<li>find-port.js<br>\n得到一个空闲的端口返回，基本原理如下（仅为部分代码）</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{\n\t\t<span class="hljs-keyword">var</span> server = net.createServer();\n\n\t\tserver.unref();\n\t\tserver.on(<span class="hljs-string">\'error\'</span>, reject);\n        <span class="hljs-comment">// port = 0, 绑定可用的端口</span>\n\t\tserver.listen(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t\t\t<span class="hljs-keyword">var</span> port = server.address().port;\n\n\t\t\tserver.close(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n\t\t\t\tresolve(port);\n\t\t\t});\n\t\t});\n\t});\n};</code></pre>\n<ul>\n<li>legacy-work.js<br>\n使用标准输入输出作为参数的来源和返回的出口，处理网络请求 (then-request) </li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">const</span> concat = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'concat-stream\'</span>);\n<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'then-request\'</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-built_in">JSON</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./json-buffer\'</span>);\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">respond</span>(<span class="hljs-params">data</span>) </span>{\n  process.stdout.write(<span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{\n    process.exit(<span class="hljs-number">0</span>);\n  });\n}\n\nprocess.stdin.pipe(concat(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stdin</span>) </span>{\n  <span class="hljs-keyword">var</span> req = <span class="hljs-built_in">JSON</span>.parse(stdin.toString());\n  request(req.method, req.url, req.options).done(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{\n    respond({<span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">response</span>: response});\n  }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{\n    respond({<span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: { <span class="hljs-attr">message</span>: err.message }});\n  });\n}));</code></pre>\n<ul>\n<li>nc-server.js<br>\n启动一个 TCP 服务端，为 nc 指令通信  </li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'net\'</span>);\n<span class="hljs-keyword">const</span> concat = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'concat-stream\'</span>);\n<span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'then-request\'</span>);\n<span class="hljs-keyword">const</span> <span class="hljs-built_in">JSON</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">\'./json-buffer\'</span>);\n\n<span class="hljs-keyword">const</span> server = net.createServer({<span class="hljs-attr">allowHalfOpen</span>: <span class="hljs-literal">true</span>}, c => {\n  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">respond</span>(<span class="hljs-params">data</span>) </span>{\n    c.end(<span class="hljs-built_in">JSON</span>.stringify(data));\n  }\n\n  c.pipe(concat(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">stdin</span>) </span>{\n    <span class="hljs-keyword">try</span> {\n      <span class="hljs-keyword">const</span> req = <span class="hljs-built_in">JSON</span>.parse(stdin.toString());\n      request(req.method, req.url, req.options).done(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{\n        respond({<span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">response</span>: response});\n      }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{\n        respond({<span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: { <span class="hljs-attr">message</span>: err.message }});\n      });\n    } <span class="hljs-keyword">catch</span> (ex) {\n      respond({<span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: { <span class="hljs-attr">message</span>: ex.message }});\n    }\n  }));\n});\n\nserver.listen(+process.argv[<span class="hljs-number">2</span>]);</code></pre>\n<p>其中 <code>{ allowHalfOpen: true }</code> 不可少，因为在执行 <code>spawnSync(\'nc\', ["127.0.0.1", nPort], {input: request})</code> 时，input 是 JSON 序列话后的字符串，输入后就到 EOF 了，相当于在 Shell 中 Ctrl+D 控制键，nc 客户端套接字就关闭了，只有允许半开套接字，客户端才能收到服务器的数据。如下图：对应为客户端的 FIN_WAIT_2 ~ TIME_WAIT 周期之间，服务器依旧可以发送数据。</p>\n<img src="http://obu9je6ng.bkt.clouddn.com/FnixeQVF2AFq-_T53WvL6Ubvk9WV?imageslim" width="600" height="509"/>\n<p>以上，便是对部分源码的解析</p>\n<p>所以，最终的请求还是通过 <code>then-request</code> 来实现的，但是对于 <code>then-request</code> 并不支持 <code>multipart/formdata</code>，因此 <code>sync-request</code> 也是不支持的。 于是本人在 fork 之后，配合 <a href="https://www.npmjs.com/package/form-data#alternative-submission-methods"><code>form-data</code></a> 提了 <a href="https://github.com/then/then-request/pull/28">pr</a>，希望作者能够早日 merge 吧。</p>\n<p>最后想说：<em>原来还可以这样实现同步！</em></p>\n',extra:{}}}});