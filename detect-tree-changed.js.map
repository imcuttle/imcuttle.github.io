{"version":3,"sources":["webpack:///detect-tree-changed.js","webpack:///./source/_articles/detect-tree-changed.md"],"names":["webpackJsonp","1164","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,knHACAC,OACAC,oBACAC","file":"detect-tree-changed.js","sourcesContent":["webpackJsonp([99,113],{\n\n/***/ 1164:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=问题><a href=#%E9%97%AE%E9%A2%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>问题</h2><p>在书写 markdown 文本的时候，为了追求好的体验，需要在 markdown 预览页面中，高亮且定位在正在编辑的节点上，如图</p><p><img src=https://i.loli.net/2018/10/28/5bd58a95c6b7d.gif></p><p>很显然，这个问题需要转换成两颗树（抽象语法树）的差异对比，</p><h2 id=思考><a href=#%E6%80%9D%E8%80%83 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思考</h2><p>如例子，将树 A 与树 B 对比，相对于树 A 来说，它的哪些节点有改动呢？</p><p align=center><img src=https://i.loli.net/2019/02/04/5c581a4fc921f.png></p><center>树 A</center><p align=center><img src=https://i.loli.net/2019/02/04/5c581a856fab4.png></p><center>树 B</center><p>那么首先对于某节点来说，有哪些类型的改动呢？</p><ul><li>更新 (updated)</li><li>删除 (removed)</li><li>某节点存在新增的子节点 (has-added-child)</li><li>存在子节点被更新（包括存在子节点被删除、新增、更新） (child-changed)</li></ul><p>对于树 A 来说，其节点的更改类型如下图，</p><p><img src=https://i.loli.net/2019/02/07/5c5c4341682fe.png></p><!-- <p align=center><img src=https://i.loli.net/2019/02/04/5c581c6eae424.png /></p> --><center>树 A 的节点更改类型</center><h3 id=算法><a href=#%E7%AE%97%E6%B3%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>算法</h3><h4 id=基本概念><a href=#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>基本概念</h4><ul><li><strong>E(A)</strong>：表示树 A 的 E 节点</li><li><strong>Paths(E(A))</strong>: E(A) 节点的路径<br>从 A(A)（根节点）向下寻找 F(A) 节点，经过 B(A) 节点和 F(A) 节点，其中 B(A) 在相对于 A(A) 索引 0 的位置，F(A) 在相对 B(A) 索引 1 的位置，所以 <strong>Paths(F(A)) = [0, 1]</strong></li><li><strong>向上回溯</strong>：从节点往上依次寻找祖先节点</li></ul><h4 id=流程描述><a href=#%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>流程描述</h4><ol><li>对树 A 进行后续遍历</li><li>遍历 X(A) 节点，根据 Paths(X(A)) 寻找到 Y(B)，若未找到 Y(B)，X(A) 标记为 removed，并且向上回溯，标记 child-changed；若找到，进行对比。若节点内容不同，标记为 updated，并且向上回溯，标记 child-changed；若 X(A) 孩子数小于 Y(B) 孩子数，标记为 has-added-child，并且向上回溯，标记 child-changed</li></ol><!-- ![](https://i.loli.net/2019/02/07/5c5c43ada9545.png) --><p><img src=https://i.loli.net/2019/02/07/5c5c44497df63.png></p><!-- <p align=center><img src=https://i.loli.net/2019/02/04/5c5855f115cb4.png /></p> --><center>树 A 和树 B 对比流程示意</center><p>以上，只需要遍历一遍树 A (O(n)) 即可标记出所有的变化信息，但是在根据树 A 节点寻找对应树 B 节点需要 O(lgn) ~ O(n) 时间复杂度，所以最终的时间复杂度未 O(nlgn) ~ O(n^2)，下面将会讲述如何优化寻找对应树 B 节点的时间复杂度。</p><h4 id=根据路径寻找节点时间的优化><a href=#%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%AF%BB%E6%89%BE%E8%8A%82%E7%82%B9%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>根据路径寻找节点时间的优化</h4><p>还是以上面的例子为例，在第一次遍历中，需要根据路径 <code>[0, 0]</code> 定位 E(B)；第二次遍历中，根据路径 <code>[0, 1]</code> 定位 null，<strong>但其实这个时候，我们应该是知道路径 <code>[0]</code> 和 <code>[0, 0]</code> 对应树 B 上的节点</strong>，所以快捷使用 <code>[0]</code> 路径对应的树 B 节点，然后再定位至 <code>[0, 1]</code> 节点即可，以上便是动态规划 (Dynamic programming) 的思想。</p><h2 id=实现与应用><a href=#%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现与应用</h2><ul><li><a href=https://github.com/imcuttle/detect-tree-changed>detect-tree-changed</a> - 多叉树的差异对比</li><li><a href=https://github.com/imcuttle/detect-one-changed>detect-one-changed</a> - 检测 html 和 markdown 第一个更新的 ast 节点</li><li><a href=https://github.com/imcuttle/live-markd>live-markd</a> - Github Favorite Markdown preview with live rendering &amp location and highlight changed block.</li><li><a href=https://github.com/picidaejs/picidaejs>picidae</a> - The document generator which has gentle experience.</li></ul>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// detect-tree-changed.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=问题><a href=#%E9%97%AE%E9%A2%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>问题</h2><p>在书写 markdown 文本的时候，为了追求好的体验，需要在 markdown 预览页面中，高亮且定位在正在编辑的节点上，如图</p><p><img src=https://i.loli.net/2018/10/28/5bd58a95c6b7d.gif></p><p>很显然，这个问题需要转换成两颗树（抽象语法树）的差异对比，</p><h2 id=思考><a href=#%E6%80%9D%E8%80%83 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思考</h2><p>如例子，将树 A 与树 B 对比，相对于树 A 来说，它的哪些节点有改动呢？</p><p align=center><img src=https://i.loli.net/2019/02/04/5c581a4fc921f.png></p><center>树 A</center><p align=center><img src=https://i.loli.net/2019/02/04/5c581a856fab4.png></p><center>树 B</center><p>那么首先对于某节点来说，有哪些类型的改动呢？</p><ul><li>更新 (updated)</li><li>删除 (removed)</li><li>某节点存在新增的子节点 (has-added-child)</li><li>存在子节点被更新（包括存在子节点被删除、新增、更新） (child-changed)</li></ul><p>对于树 A 来说，其节点的更改类型如下图，</p><p><img src=https://i.loli.net/2019/02/07/5c5c4341682fe.png></p><!-- <p align=center><img src=https://i.loli.net/2019/02/04/5c581c6eae424.png /></p> --><center>树 A 的节点更改类型</center><h3 id=算法><a href=#%E7%AE%97%E6%B3%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>算法</h3><h4 id=基本概念><a href=#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>基本概念</h4><ul><li><strong>E(A)</strong>：表示树 A 的 E 节点</li><li><strong>Paths(E(A))</strong>: E(A) 节点的路径<br>从 A(A)（根节点）向下寻找 F(A) 节点，经过 B(A) 节点和 F(A) 节点，其中 B(A) 在相对于 A(A) 索引 0 的位置，F(A) 在相对 B(A) 索引 1 的位置，所以 <strong>Paths(F(A)) = [0, 1]</strong></li><li><strong>向上回溯</strong>：从节点往上依次寻找祖先节点</li></ul><h4 id=流程描述><a href=#%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>流程描述</h4><ol><li>对树 A 进行后续遍历</li><li>遍历 X(A) 节点，根据 Paths(X(A)) 寻找到 Y(B)，若未找到 Y(B)，X(A) 标记为 removed，并且向上回溯，标记 child-changed；若找到，进行对比。若节点内容不同，标记为 updated，并且向上回溯，标记 child-changed；若 X(A) 孩子数小于 Y(B) 孩子数，标记为 has-added-child，并且向上回溯，标记 child-changed</li></ol><!-- ![](https://i.loli.net/2019/02/07/5c5c43ada9545.png) --><p><img src=https://i.loli.net/2019/02/07/5c5c44497df63.png></p><!-- <p align=center><img src=https://i.loli.net/2019/02/04/5c5855f115cb4.png /></p> --><center>树 A 和树 B 对比流程示意</center><p>以上，只需要遍历一遍树 A (O(n)) 即可标记出所有的变化信息，但是在根据树 A 节点寻找对应树 B 节点需要 O(lgn) ~ O(n) 时间复杂度，所以最终的时间复杂度未 O(nlgn) ~ O(n^2)，下面将会讲述如何优化寻找对应树 B 节点的时间复杂度。</p><h4 id=根据路径寻找节点时间的优化><a href=#%E6%A0%B9%E6%8D%AE%E8%B7%AF%E5%BE%84%E5%AF%BB%E6%89%BE%E8%8A%82%E7%82%B9%E6%97%B6%E9%97%B4%E7%9A%84%E4%BC%98%E5%8C%96 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>根据路径寻找节点时间的优化</h4><p>还是以上面的例子为例，在第一次遍历中，需要根据路径 <code>[0, 0]</code> 定位 E(B)；第二次遍历中，根据路径 <code>[0, 1]</code> 定位 null，<strong>但其实这个时候，我们应该是知道路径 <code>[0]</code> 和 <code>[0, 0]</code> 对应树 B 上的节点</strong>，所以快捷使用 <code>[0]</code> 路径对应的树 B 节点，然后再定位至 <code>[0, 1]</code> 节点即可，以上便是动态规划 (Dynamic programming) 的思想。</p><h2 id=实现与应用><a href=#%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现与应用</h2><ul><li><a href=https://github.com/imcuttle/detect-tree-changed>detect-tree-changed</a> - 多叉树的差异对比</li><li><a href=https://github.com/imcuttle/detect-one-changed>detect-one-changed</a> - 检测 html 和 markdown 第一个更新的 ast 节点</li><li><a href=https://github.com/imcuttle/live-markd>live-markd</a> - Github Favorite Markdown preview with live rendering &amp location and highlight changed block.</li><li><a href=https://github.com/picidaejs/picidaejs>picidae</a> - The document generator which has gentle experience.</li></ul>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/detect-tree-changed.md\n// module id = 1164\n// module chunks = 99"],"sourceRoot":""}