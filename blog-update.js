webpackJsonp([78,90],{985:function(n,e){n.exports={content:'<p>学生时代最后一个学期的前夕（明天就回学校了）。完成了<a href="http://blog.moyuyc.xyz">个人博客</a>的“换血”，页面风格没什么大的改版，<strong>重点是在后端数据接口的开发设计，和前端代码的重构，加上了 react 动态加载多说评论系统（使用 redux 分离数据逻辑处理代码），也加上了服务器渲染，都是为了 SEO 和首屏渲染！</strong></p>\n<p><strong>地址: <a href="http://blog.moyuyc.xyz">http://blog.moyuyc.xyz</a></strong></p>\n<p><strong>仓库地址: <a href="https://github.com/moyuyc/isomorphic-blog">isomorphic-blog</a></strong></p>\n<p>感谢陈老板的服务器！</p>\n<p>总结下开发过程中学习到的东西或者坑！</p>\n<h2 id="学习的总结"><a href="#%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%BB%E7%BB%93" aria-hidden="true"><span class="icon icon-link"></span></a>学习的总结</h2>\n<h3 id="node模块寻找"><a href="#node%E6%A8%A1%E5%9D%97%E5%AF%BB%E6%89%BE" aria-hidden="true"><span class="icon icon-link"></span></a>node模块寻找</h3>\n<p>对于该项目，前后端都需要 node package，所以对于项目包的管理是否重要！</p>\n<p>如下文件结构</p>\n<pre><code data-query="{}" data-lang="">blog/\n├── backend/\n│   ├── a.js\n│   └── node_modules/ # module => express\n├── frontend/\n│   ├── b.js\n│   └── node_modules/ # module => react\n├── outter.js\n└── node_modules/  # module => jquery\n</code></pre>\n<ul>\n<li>outter.js</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-comment">// Error: Cannot find module</span>\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'react\'</span>);\n<span class="hljs-comment">// Error: Cannot find module</span>\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>);</code></pre>\n<ul>\n<li>backend/a.js  </li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'react\'</span>);\n<span class="hljs-comment">// Error: Cannot find module</span>\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>);</code></pre>\n<ul>\n<li>frontend/b.js  </li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">\'express\'</span>);\n<span class="hljs-comment">// Error: Cannot find module</span>\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'react\'</span>);\n<span class="hljs-built_in">require</span>(<span class="hljs-string">\'jquery\'</span>);</code></pre>\n<p>如上各文件的引入包的情况，可知 node 加载非绝对路径或者相对路径的包，是首先加载该文件同级目录 <code>node_modules/</code> 寻找，然后依次向父级目录延伸，直到 <code>/</code> 根目录。</p>\n<p><em>其他文件 <code>.babelrc/.gitignore/.npmignore</code> 加载方式都是一样的！</em></p>\n<p>所以我们只需要在项目最外层 install package，书写 .babelrc ...</p>\n<p>同时一些 <code>npm script</code> 只需要写在项目最外层即可。\n只需要在最外层 <code>npm i cross-env --save</code> </p>\n<pre><code data-query="{}" data-lang="">"start": "cross-env NODE_ENV=production node backend/index.js"\n"dev": "cross-env NODE_ENV=development node backend/index.js"\n"dev:front": "cross-env NODE_ENV=development node frontend/index.js"\n</code></pre>\n<h3 id="node模块缓存清除"><a href="#node%E6%A8%A1%E5%9D%97%E7%BC%93%E5%AD%98%E6%B8%85%E9%99%A4" aria-hidden="true"><span class="icon icon-link"></span></a>node模块缓存清除</h3>\n<p>由于文章是用 markdown 文件形式存储的，如果每次请求文章内容都需要读取文件的话，简直日狗，电脑硬盘也吃不消。</p>\n<p>所以我在服务器启动之前，就进行 markdown 文件遍历解析，保存至内存中，同时监听 markdown 文件夹变化，发生变化就动态更新内存数据。</p>\n<p><em>插一句！TODO: 感觉可以起个进程单独处理文件遍历解析的工作，用 IPC 进行 JSON 数据（不带 function）传输即可，充分利用多核！</em></p>\n<p>这样每次请求只需要读取内存就 OK，速度也比较快。</p>\n<p>同时还监听了配置文件的变化，变化则需要重新加载，那么就需要清除之前的缓存了。</p>\n<pre><code data-query="{}" data-lang="">const clearCache = (modulepath) => delete require.cache[require.resolve(modulepath)]\n</code></pre>\n<p>如上代码，<code>require.resolve</code> 和 <code>path.resolve</code> 方法基本一致，都是基于 <code>process.cwd()</code> 当前环境路径，解析 <code>..</code> <code>.</code> 得到绝对路径。</p>\n<p><em>再插一句！<code>require("../path")</code> 中的路径，不是基于 <code>process.cwd()</code> 的，而是 <code>__dirname</code></em></p>\n<h3 id="配置文件-json--yaml"><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-json--yaml" aria-hidden="true"><span class="icon icon-link"></span></a>配置文件 json => yaml</h3>\n<p>配置文件升级成 yaml 格式，yaml 真是方便！json 格式太僵硬了！</p>\n<img src="http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim" width="1003" height="402"/>\n<h3 id="一些轮子"><a href="#%E4%B8%80%E4%BA%9B%E8%BD%AE%E5%AD%90" aria-hidden="true"><span class="icon icon-link"></span></a>一些轮子</h3>\n<ol>\n<li>\n<p>根据 react-router 自动生成 sitemap ，一切为了 搜！索！\n<a href="https://github.com/moyuyc/react-router-sitemap-builder">react-router-sitemap-builder</a></p>\n</li>\n<li>\n<p>更好的阅读体验！解析 markdown &#x26; HTML 图像文本，读取 URL 图片数据得到大小，替换文本！\n<img src="http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim">\n=> => =>\n<img src="http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim" width="1003" height="402"/>\n<a href="https://github.com/moyuyc/node-markdown-image-size">markdown-image-size</a></p>\n</li>\n<li>\n<p>react+多说踩坑！</p>\n</li>\n</ol>\n<img src="http://obu9je6ng.bkt.clouddn.com/FmY9Gu9I9nPbZE-40BgH8NRMd8tu?imageslim" width="842" height="577"/>\n<p>...不知怎么说，总之就是设置各种参数判断是不是脚本加载完成...</p>\n<p>具体看代码吧 <a href="https://github.com/moyuyc/isomorphic-blog/blob/master/frontend/src/components/DuoshuoComment/index.js">react-duoshuo-comment</a></p>\n<p>又水了一篇...</p>\n<h2 id="其他的一些"><a href="#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B" aria-hidden="true"><span class="icon icon-link"></span></a>其他的一些</h2>\n<ul>\n<li>\n<p>发布流程<br>\n在本地书写完 markdown 后 => git push 至 github => curl url => 服务器触发 git pull 更新文章 => 文件监听变化 => 更新数据 => 发布成功！</p>\n</li>\n<li>\n<p>SEO<br>\n谷歌真是技术杠杠的，没几天就可以搜到我的站点了，百度还是没有（都已提交网站和 sitemap.txt/robots.txt）\n<img src="http://obu9je6ng.bkt.clouddn.com/FocOlJ-S5EvxL2Qrc00zWNif6kyy?imageslim" width="580" height="628"/></p>\n</li>\n</ul>\n',extra:{}}}});