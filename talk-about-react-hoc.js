webpackJsonp([13,90],{1050:function(s,a){s.exports={content:'<h2 id="定义"><a href="#%E5%AE%9A%E4%B9%89" aria-hidden="true"><span class="icon icon-link"></span></a>定义</h2>\n<p>高阶组件（Higher Order Components, HOC）: 通过它，将一个组件包装成另一个组件</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js"><span class="hljs-keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</code></pre>\n<h2 id="两种hoc方式"><a href="#%E4%B8%A4%E7%A7%8Dhoc%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>两种HOC方式</h2>\n<h3 id="wrap方法"><a href="#wrap%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>wrap方法</h3>\n<p>如下：将 Pagination 进行一层 wrap，为了与 rd 接口对接上，同时去掉自动计算"多余"的 <code>totalPage</code></p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myPagination</span>(<span class="hljs-params">Pagination</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPagination</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n\n        render() {\n            <span class="hljs-keyword">const</span> {pageNum, pageSize, total, children, ...rest} = <span class="hljs-keyword">this</span>.props\n            <span class="hljs-keyword">return</span> (\n                <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Pagination</span>\n                    <span class="hljs-attr">currentPage</span>=<span class="hljs-string">{parseInt(pageNum,</span> <span class="hljs-attr">10</span>)}\n                    <span class="hljs-attr">currentLine</span>=<span class="hljs-string">{parseInt(pageSize,</span> <span class="hljs-attr">10</span>)}\n                    <span class="hljs-attr">totalNumber</span>=<span class="hljs-string">{parseInt(total,</span> <span class="hljs-attr">10</span>)}\n                    <span class="hljs-attr">totalPage</span>=<span class="hljs-string">{Math.ceil(parseInt(total,</span> <span class="hljs-attr">10</span>) / <span class="hljs-attr">parseInt</span>(<span class="hljs-attr">pageSize</span>, <span class="hljs-attr">10</span>))}\n                    {<span class="hljs-attr">...rest</span>}\n                ></span>\n                    {children}\n                <span class="hljs-tag">&#x3C;/<span class="hljs-name">Pagination</span>></span></span>\n            )\n        }\n    }\n}</code></pre>\n<h3 id="倒转继承方法"><a href="#%E5%80%92%E8%BD%AC%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>倒转继承方法</h3>\n<p>如下，可以用于包装 style/useable 的 api，而且对外无影响（除了静态方法）</p>\n<pre><code class="hljs language-js" data-query="{}" data-lang="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">styleUseable</span>(<span class="hljs-params">WrappedComponent</span>) </span>{\n    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enhancer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">componentClass</span> </span>{\n        componentWillMount(...args) {\n            styleInstance.use &#x26;&#x26; styleInstance.use();\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.componentWillMount) {\n                <span class="hljs-keyword">super</span>.componentWillMount.apply(<span class="hljs-keyword">this</span>, args)\n            }\n        }\n\n        componentWillUnmount(...args) {\n            styleInstance.unuse &#x26;&#x26; styleInstance.unuse();\n            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">super</span>.componentWillUnmount) {\n                <span class="hljs-keyword">super</span>.componentWillUnmount.apply(<span class="hljs-keyword">this</span>, args)\n            }\n        }\n    }\n}</code></pre>\n<h2 id="实践"><a href="#%E5%AE%9E%E8%B7%B5" aria-hidden="true"><span class="icon icon-link"></span></a>实践</h2>\n<p><a href="https://m-cuttlefish.github.io/react-mhoc/page">React-Editable: 可视化编辑 React 数据</a></p>\n<video src="http://obu9je6ng.bkt.clouddn.com/editable-preview.mp4" controls="controls" width="500" height="300"/>\n<p>可以方便 “编辑” React 组件（包括 Props、State、甚至一些其他自定义数据）\n其中对于 Props 数据的“可编辑”实现，是基于 wrap 方法的，其他数据则都是通过倒转继承的方法实现。\n并且视图进行同步更新</p>\n<h2 id="hoc带来的问题"><a href="#hoc%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98" aria-hidden="true"><span class="icon icon-link"></span></a>HOC带来的问题</h2>\n<ul>\n<li>\n<p>static方法需要手动copy\n该问题2种方法都存在\n<a href="https://github.com/mridgway/hoist-non-react-statics">解决方法: hoist-non-react-statics</a></p>\n</li>\n<li>\n<p>refs不会传递\n该问题只存在于wrap方法</p>\n</li>\n</ul>\n<h2 id="对比两种方法"><a href="#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>对比两种方法</h2>\n<ol>\n<li>wrap 方法可以用于修改 WrappedComponent 的 props</li>\n<li>倒转继承方法可以嵌入自定义方法至WrappedComponent的方法中（包括生命周期）</li>\n<li>因为 refs 的问题存在，倒转继承方法可以更加容易“不被察觉地”工作</li>\n<li>倒转继承方法不能修改 WrappedComponent 的 props，因为 this.props 是 readonly</li>\n</ol>\n',extra:{}}}});