<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> 书写组件 DEMO 的一些方案 - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="1096783369"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">书写组件 DEMO 的一些方案</h1><div class="post-info" data-reactid="12"><time datetime="2018-06-30T15:55:46+00:00" data-reactid="13">Jun 30, 2018 3:55 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p data-reactid="17">目前前端开发都推崇一致组件化的开发思想，即看到业务页面之后，先不着急写页面；而是先观察，把一些具有共性的UI控件包装成组件（如 React/Vue/Web Component）。这样做的好处不言而喻，提供组件复用率，团队开发效率提升明显。</p><p data-reactid="18">既然组件化的思想这么重要，那么对于某个组件单元，它本身是不依赖外部环境（如外部静态资源）的；同时它内部也需要有它自己的单元测试、文档，甚至包含 DEMO 代码。</p><p data-reactid="19">对于单元测试、文档的意义不属于该文讨论范畴，下面展开说说组件 DEMO 的意义</p><h2 id="组件-demo-的意义" data-reactid="20"><a href="#%E7%BB%84%E4%BB%B6-demo-%E7%9A%84%E6%84%8F%E4%B9%89" aria-hidden="true" data-reactid="21"><span class="icon icon-link" data-reactid="22"></span></a><!-- react-text: 23 -->组件 DEMO 的意义<!-- /react-text --></h2><h3 id="沟通、共享" data-reactid="24"><a href="#%E6%B2%9F%E9%80%9A%E3%80%81%E5%85%B1%E4%BA%AB" aria-hidden="true" data-reactid="25"><span class="icon icon-link" data-reactid="26"></span></a><!-- react-text: 27 -->沟通、共享<!-- /react-text --></h3><p data-reactid="28">项目开发人数一般为多人，多人开发的情境下，多了一份沟通的开销。</p><p data-reactid="29">在没有 DEMO 的情景下，项目成员都是交叉沟通的（如该组件具体怎么用），而且这种沟通大都是低效的（无沉淀）； 而 组件 DEMO 的出现将内容聚合起来，项目成员都是面向 DEMO，去除了项目成员冗余沟通，表现方式也更为直观。</p><p data-reactid="30">如果 DEMO 可以可视化集成文档，那么体验则更美妙。</p><h3 id="集成测试" data-reactid="31"><a href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" aria-hidden="true" data-reactid="32"><span class="icon icon-link" data-reactid="33"></span></a><!-- react-text: 34 -->集成测试<!-- /react-text --></h3><p data-reactid="35">组件 DEMO 另一个更为重要的意义则是方便 “集成测试”。拥有 DEMO 之后，我们可以直接使用 DEMO 服务去进行集成测试，而不需要额外搭建环境。</p><h2 id="实现组件-demo" data-reactid="36"><a href="#%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6-demo" aria-hidden="true" data-reactid="37"><span class="icon icon-link" data-reactid="38"></span></a><!-- react-text: 39 -->实现组件 DEMO<!-- /react-text --></h2><p data-reactid="40">不同组件有不同的 DEMO，一个组件还可能拥有多个 DEMO case，所以 DEMO 服务应该是有多路由的，</p><p data-reactid="41">基于添加路由的方式不同，我将实现组件 DEMO 的方式划为两种方式：静态添加路由、动态添加路由。</p><h3 id="静态（不推荐）" data-reactid="42"><a href="#%E9%9D%99%E6%80%81%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89" aria-hidden="true" data-reactid="43"><span class="icon icon-link" data-reactid="44"></span></a><!-- react-text: 45 -->静态（不推荐）<!-- /react-text --></h3><p data-reactid="46">通过模板去自动生成各个组件的 DEMO 路由代码；触发流程应该为：新建 demo 后，执行命令去写入静态路由</p><p data-reactid="47">这种方法相对简单、不优雅，本文不展开说明</p><h3 id="运行时，动态路由匹配" data-reactid="48"><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D" aria-hidden="true" data-reactid="49"><span class="icon icon-link" data-reactid="50"></span></a><!-- react-text: 51 -->运行时，动态路由匹配<!-- /react-text --></h3><p data-reactid="52"><!-- react-text: 53 -->其实市面上已经有一些现场的 DEMO 服务解决方案，如 <!-- /react-text --><a href="https://github.com/storybooks/storybook" data-reactid="54">storybook</a><!-- react-text: 55 --> 和 <!-- /react-text --><a href="https://github.com/styleguidist/react-styleguidist" data-reactid="56">react-styleguidist</a><!-- react-text: 57 --> 它们的共同点是他们都是独立的 webpack 环境，生态都很全面；<!-- /react-text --></p><p data-reactid="58">但是对于有些情况下，我们组件代码和 DEMO 是依赖我们项目环境的（如 webpack 配置，或者其他老项目依赖外部的静态资源），所以以上的方案可能不太适合，这时候就需要我们自己动手写一个 DEMO 架子了。</p><h4 id="demo-架子" data-reactid="59"><a href="#demo-%E6%9E%B6%E5%AD%90" aria-hidden="true" data-reactid="60"><span class="icon icon-link" data-reactid="61"></span></a><!-- react-text: 62 -->DEMO 架子<!-- /react-text --></h4><p data-reactid="63"><!-- react-text: 64 -->其实动态路由添加的实现是基于 Webpack 中的 <!-- /react-text --><code data-reactid="65">require.context</code><!-- react-text: 66 --> 方法的<!-- /react-text --></p><p data-reactid="67"><code data-reactid="68">require.context(path, useSubdirectories, regExp)</code><!-- react-text: 69 --> 方法有三个参数<!-- /react-text --></p><ul data-reactid="70"><li data-reactid="71"><code data-reactid="72">path</code><!-- react-text: 73 -->: 要搜索的文件夹目录<!-- /react-text --></li><li data-reactid="74"><code data-reactid="75">useSubdirectories</code><!-- react-text: 76 -->: 是否还应该搜索它的子目录<!-- /react-text --></li><li data-reactid="77"><code data-reactid="78">regExp</code><!-- react-text: 79 --> 一个匹配文件的正则表达式<!-- /react-text --></li></ul><p data-reactid="80"><code data-reactid="81">require.context</code><!-- react-text: 82 --> 返回一个（require）函数，这个函数可以接收一个参数：<!-- /react-text --><code data-reactid="83">path</code><!-- react-text: 84 --> （这个 path 是基于要搜索的文件夹目录的）<!-- /react-text --></p><p data-reactid="85"><!-- react-text: 86 -->实际上 <!-- /react-text --><code data-reactid="87">require.context</code><!-- react-text: 88 --> 是一个 Webpack 编译阶段用到的语法，而不是前端代码，所以如果执行 <!-- /react-text --><code data-reactid="89">console.log(require.context)</code><!-- react-text: 90 --> 打印的是 <!-- /react-text --><code data-reactid="91">undefined</code></p><p data-reactid="92">如果我们组件的文件结构为:</p><pre data-reactid="93"><code data-query="{}" data-lang="data-lang" data-reactid="94">components/
    Button/
        ...
        demo/  # 对应不同 case 的 demo 代码
            caseA.js
            caseB.js
</code></pre><p data-reactid="95">使用该方法，我们可以使用如下代码来动态选择加载 DEMO 代码</p><pre data-reactid="96"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="97"><span class="hljs-keyword" data-reactid="98">const</span><!-- react-text: 99 --> req = <!-- /react-text --><span class="hljs-built_in" data-reactid="100">require</span><!-- react-text: 101 -->.context(<!-- /react-text --><span class="hljs-string" data-reactid="102">&#x27;components&#x27;</span><!-- react-text: 103 -->, <!-- /react-text --><span class="hljs-literal" data-reactid="104">true</span><!-- react-text: 105 -->, /\/demo\/.+?\.js$/)
<!-- /react-text --><span class="hljs-comment" data-reactid="106">// 加载 DEMO</span><!-- react-text: 107 -->
req.keys().map(<!-- /react-text --><span class="hljs-function" data-reactid="108"><span class="hljs-params" data-reactid="109">filename</span><!-- react-text: 110 --> =&gt;<!-- /react-text --></span><!-- react-text: 111 --> req(filename))<!-- /react-text --></code></pre><p data-reactid="112">基于以上代码，我们可以动态的生成路由，从而渲染组件 DEMO</p><p data-reactid="113"><!-- react-text: 114 -->同时安利一个 React 高阶组件 <!-- /react-text --><a href="https://github.com/m-cuttlefish/react-mhoc" data-reactid="115">react-hoc/editable</a><!-- react-text: 116 -->，使用这个高阶组件可以<!-- /react-text --><strong data-reactid="117">可视化操作更新组件数据</strong><!-- react-text: 118 -->，使我们更方便的修改组件内部的数据，从而更了解组件的使用。<!-- /react-text --></p><p data-reactid="119"><a href="https://m-cuttlefish.github.io/react-mhoc/page/" data-reactid="120">react-hoc/editable DEMO 地址</a></p><p data-reactid="121">你觉得你只有 DEMO 视图还不够，还需要 DEMO 源码展示？</p><h5 id="加上-demo-源码展示" data-reactid="122"><a href="#%E5%8A%A0%E4%B8%8A-demo-%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA" aria-hidden="true" data-reactid="123"><span class="icon icon-link" data-reactid="124"></span></a><!-- react-text: 125 -->加上 DEMO 源码展示<!-- /react-text --></h5><p data-reactid="126"><!-- react-text: 127 -->使用 webpack 的 <!-- /react-text --><code data-reactid="128">raw-loader</code><!-- react-text: 129 -->，即可加载 DEMO 为源码文本<!-- /react-text --></p><pre data-reactid="130"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="131"><span class="hljs-keyword" data-reactid="132">const</span><!-- react-text: 133 --> rawReq = <!-- /react-text --><span class="hljs-built_in" data-reactid="134">require</span><!-- react-text: 135 -->.context(<!-- /react-text --><span class="hljs-string" data-reactid="136">&#x27;!raw-loader!dulife-ui&#x27;</span><!-- react-text: 137 -->, <!-- /react-text --><span class="hljs-literal" data-reactid="138">true</span><!-- react-text: 139 -->, /\/demo\/.+?\.js$/)<!-- /react-text --></code></pre><p data-reactid="140"><!-- react-text: 141 -->最终效果如下： <!-- /react-text --><img src="https://i.loli.net/2018/06/30/5b3741de4ed1e.png" data-reactid="142"/></p><h2 id="结尾" data-reactid="143"><a href="#%E7%BB%93%E5%B0%BE" aria-hidden="true" data-reactid="144"><span class="icon icon-link" data-reactid="145"></span></a><!-- react-text: 146 -->结尾<!-- /react-text --></h2><p data-reactid="147"><!-- react-text: 148 -->本人还是推荐动态添加路由方式中的 <!-- /react-text --><a href="https://github.com/storybooks/storybook" data-reactid="149">storybook</a><!-- react-text: 150 --> 和 <!-- /react-text --><a href="https://github.com/styleguidist/react-styleguidist" data-reactid="151">react-styleguidist</a><!-- react-text: 152 --> 生态！<!-- /react-text --></p></article></div><div class="gitment-container" data-reactid="153"></div><div class="paginator" data-reactid="154"><a title="告别庞大 PSD，轻松测量尺寸" class="prev" href="/make-psd-measurable" data-reactid="155">Prev</a><a title="React在线编辑国际化文本" class="next" href="/在线编辑国际化文本" data-reactid="156">Next</a></div></div></main><footer data-reactid="157"><div class="copyright" data-reactid="158"><p data-reactid="159"><!-- react-text: 160 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="161">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
