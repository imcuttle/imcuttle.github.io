webpackJsonp([26,113],{1239:function(s,a){s.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=定义><a href=#%E5%AE%9A%E4%B9%89 aria-hidden=true><span class="icon icon-link"></span></a>定义</h2><p>高阶组件（Higher Order Components, HOC）: 通过它，将一个组件包装成另一个组件</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-keyword>const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</code></pre><h2 id=两种hoc方式><a href=#%E4%B8%A4%E7%A7%8Dhoc%E6%96%B9%E5%BC%8F aria-hidden=true><span class="icon icon-link"></span></a>两种HOC方式</h2><h3 id=wrap方法><a href=#wrap%E6%96%B9%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>wrap方法</h3><p>如下：将 Pagination 进行一层 wrap，为了与 rd 接口对接上，同时去掉自动计算"多余"的 <code>totalPage</code></p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>myPagination</span>(<span class=hljs-params>Pagination</span>) </span>{\n    <span class=hljs-keyword>return</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>MyPagination</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\n\n        render() {\n            <span class=hljs-keyword>const</span> {pageNum, pageSize, total, children, ...rest} = <span class=hljs-keyword>this</span>.props\n            <span class=hljs-keyword>return</span> (\n                <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>Pagination</span>\n                    <span class=hljs-attr>currentPage</span>=<span class=hljs-string>{parseInt(pageNum,</span> <span class=hljs-attr>10</span>)}\n                    <span class=hljs-attr>currentLine</span>=<span class=hljs-string>{parseInt(pageSize,</span> <span class=hljs-attr>10</span>)}\n                    <span class=hljs-attr>totalNumber</span>=<span class=hljs-string>{parseInt(total,</span> <span class=hljs-attr>10</span>)}\n                    <span class=hljs-attr>totalPage</span>=<span class=hljs-string>{Math.ceil(parseInt(total,</span> <span class=hljs-attr>10</span>) / <span class=hljs-attr>parseInt</span>(<span class=hljs-attr>pageSize</span>, <span class=hljs-attr>10</span>))}\n                    {<span class=hljs-attr>...rest</span>}\n                ></span>\n                    {children}\n                <span class=hljs-tag>&lt;/<span class=hljs-name>Pagination</span>></span></span>\n            )\n        }\n    }\n}</code></pre><h3 id=倒转继承方法><a href=#%E5%80%92%E8%BD%AC%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>倒转继承方法</h3><p>如下，可以用于包装 style/useable 的 api，而且对外无影响（除了静态方法）</p><pre><code class="hljs language-js"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>styleUseable</span>(<span class=hljs-params>WrappedComponent</span>) </span>{\n    <span class=hljs-keyword>return</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Enhancer</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>componentClass</span> </span>{\n        componentWillMount(...args) {\n            styleInstance.use &amp&amp styleInstance.use();\n            <span class=hljs-keyword>if</span> (<span class=hljs-keyword>super</span>.componentWillMount) {\n                <span class=hljs-keyword>super</span>.componentWillMount.apply(<span class=hljs-keyword>this</span>, args)\n            }\n        }\n\n        componentWillUnmount(...args) {\n            styleInstance.unuse &amp&amp styleInstance.unuse();\n            <span class=hljs-keyword>if</span> (<span class=hljs-keyword>super</span>.componentWillUnmount) {\n                <span class=hljs-keyword>super</span>.componentWillUnmount.apply(<span class=hljs-keyword>this</span>, args)\n            }\n        }\n    }\n}</code></pre><h2 id=实践><a href=#%E5%AE%9E%E8%B7%B5 aria-hidden=true><span class="icon icon-link"></span></a>实践</h2><p><a href=https://m-cuttlefish.github.io/react-mhoc/page>React-Editable: 可视化编辑 React 数据</a></p><video src=http://obu9je6ng.bkt.clouddn.com/editable-preview.mp4 controls width=500 height=300><p>可以方便 “编辑” React 组件（包括 Props、State、甚至一些其他自定义数据） 其中对于 Props 数据的“可编辑”实现，是基于 wrap 方法的，其他数据则都是通过倒转继承的方法实现。 并且视图进行同步更新</p><h2 id=hoc带来的问题><a href=#hoc%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98 aria-hidden=true><span class="icon icon-link"></span></a>HOC带来的问题</h2><ul><li><p>static方法需要手动copy 该问题2种方法都存在 <a href=https://github.com/mridgway/hoist-non-react-statics>解决方法: hoist-non-react-statics</a></p></li><li><p>refs不会传递 该问题只存在于wrap方法</p></li></ul><h2 id=对比两种方法><a href=#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>对比两种方法</h2><ol><li>wrap 方法可以用于修改 WrappedComponent 的 props</li><li>倒转继承方法可以嵌入自定义方法至WrappedComponent的方法中（包括生命周期）</li><li>因为 refs 的问题存在，倒转继承方法可以更加容易“不被察觉地”工作</li><li>倒转继承方法不能修改 WrappedComponent 的 props，因为 this.props 是 readonly</li></ol></video>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=talk-about-react-hoc.js.map