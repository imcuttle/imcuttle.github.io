{"version":3,"sources":["webpack:///blog-update.js","webpack:///./source/_articles/blog-update.md"],"names":["webpackJsonp","1160","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,s0LACAC,OACAC,oBACAC","file":"blog-update.js","sourcesContent":["webpackJsonp([103,113],{\n\n/***/ 1160:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>学生时代最后一个学期的前夕（明天就回学校了）。完成了<a href=http://blog.moyuyc.xyz>个人博客</a>的“换血”，页面风格没什么大的改版，<strong>重点是在后端数据接口的开发设计，和前端代码的重构，加上了 react 动态加载多说评论系统（使用 redux 分离数据逻辑处理代码），也加上了服务器渲染，都是为了 SEO 和首屏渲染！</strong></p><p><strong>地址: <a href=http://blog.moyuyc.xyz>http://blog.moyuyc.xyz</a></strong></p><p><strong>仓库地址: <a href=https://github.com/moyuyc/isomorphic-blog>isomorphic-blog</a></strong></p><p>感谢陈老板的服务器！</p><p>总结下开发过程中学习到的东西或者坑！</p><h2 id=学习的总结><a href=#%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%BB%E7%BB%93 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>学习的总结</h2><h3 id=node模块寻找><a href=#node%E6%A8%A1%E5%9D%97%E5%AF%BB%E6%89%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>node模块寻找</h3><p>对于该项目，前后端都需要 node package，所以对于项目包的管理是否重要！</p><p>如下文件结构</p><pre><code data-query={} data-lang>blog/\\n├── backend/\\n│   ├── a.js\\n│   └── node_modules/ # module => express\\n├── frontend/\\n│   ├── b.js\\n│   └── node_modules/ # module => react\\n├── outter.js\\n└── node_modules/  # module => jquery\\n</code></pre><ul><li>outter.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><ul><li>backend/a.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><ul><li>frontend/b.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><p>如上各文件的引入包的情况，可知 node 加载非绝对路径或者相对路径的包，是首先加载该文件同级目录 <code>node_modules/</code> 寻找，然后依次向父级目录延伸，直到 <code>/</code> 根目录。</p><p><em>其他文件 <code>.babelrc/.gitignore/.npmignore</code> 加载方式都是一样的！</em></p><p>所以我们只需要在项目最外层 install package，书写 .babelrc ...</p><p>同时一些 <code>npm script</code> 只需要写在项目最外层即可。 只需要在最外层 <code>npm i cross-env --save</code></p><pre><code data-query={} data-lang>\\\"start\\\": \\\"cross-env NODE_ENV=production node backend/index.js\\\"\\n\\\"dev\\\": \\\"cross-env NODE_ENV=development node backend/index.js\\\"\\n\\\"dev:front\\\": \\\"cross-env NODE_ENV=development node frontend/index.js\\\"\\n</code></pre><h3 id=node模块缓存清除><a href=#node%E6%A8%A1%E5%9D%97%E7%BC%93%E5%AD%98%E6%B8%85%E9%99%A4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>node模块缓存清除</h3><p>由于文章是用 markdown 文件形式存储的，如果每次请求文章内容都需要读取文件的话，简直日狗，电脑硬盘也吃不消。</p><p>所以我在服务器启动之前，就进行 markdown 文件遍历解析，保存至内存中，同时监听 markdown 文件夹变化，发生变化就动态更新内存数据。</p><p><em>插一句！TODO: 感觉可以起个进程单独处理文件遍历解析的工作，用 IPC 进行 JSON 数据（不带 function）传输即可，充分利用多核！</em></p><p>这样每次请求只需要读取内存就 OK，速度也比较快。</p><p>同时还监听了配置文件的变化，变化则需要重新加载，那么就需要清除之前的缓存了。</p><pre><code data-query={} data-lang>const clearCache = (modulepath) => delete require.cache[require.resolve(modulepath)]\\n</code></pre><p>如上代码，<code>require.resolve</code> 和 <code>path.resolve</code> 方法基本一致，都是基于 <code>process.cwd()</code> 当前环境路径，解析 <code>..</code> <code>.</code> 得到绝对路径。</p><p><em>再插一句！<code>require(\\\"../path\\\")</code> 中的路径，不是基于 <code>process.cwd()</code> 的，而是 <code>__dirname</code></em></p><h3 id=配置文件-json--yaml><a href=#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-json--yaml aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>配置文件 json => yaml</h3><p>配置文件升级成 yaml 格式，yaml 真是方便！json 格式太僵硬了！</p><img src=false width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim><h3 id=一些轮子><a href=#%E4%B8%80%E4%BA%9B%E8%BD%AE%E5%AD%90 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>一些轮子</h3><ol><li><p>根据 react-router 自动生成 sitemap ，一切为了 搜！索！ <a href=https://github.com/moyuyc/react-router-sitemap-builder>react-router-sitemap-builder</a></p></li><li><p>更好的阅读体验！解析 markdown &amp HTML 图像文本，读取 URL 图片数据得到大小，替换文本！ <img src=false alt width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim> => => => <img src=false width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim> <a href=https://github.com/moyuyc/node-markdown-image-size>markdown-image-size</a></p></li><li><p>react+多说踩坑！</p></li></ol><img src=false width=842 height=577 data-src=http://obu9je6ng.bkt.clouddn.com/FmY9Gu9I9nPbZE-40BgH8NRMd8tu?imageslim><p>...不知怎么说，总之就是设置各种参数判断是不是脚本加载完成...</p><p>具体看代码吧 <a href=https://github.com/moyuyc/isomorphic-blog/blob/master/frontend/src/components/DuoshuoComment/index.js>react-duoshuo-comment</a></p><p>又水了一篇...</p><h2 id=其他的一些><a href=#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他的一些</h2><ul><li><p>发布流程<br>在本地书写完 markdown 后 => git push 至 github => curl url => 服务器触发 git pull 更新文章 => 文件监听变化 => 更新数据 => 发布成功！</p></li><li><p>SEO<br>谷歌真是技术杠杠的，没几天就可以搜到我的站点了，百度还是没有（都已提交网站和 sitemap.txt/robots.txt） <img src=false width=580 height=628 data-src=http://obu9je6ng.bkt.clouddn.com/FocOlJ-S5EvxL2Qrc00zWNif6kyy?imageslim></p></li></ul>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// blog-update.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>学生时代最后一个学期的前夕（明天就回学校了）。完成了<a href=http://blog.moyuyc.xyz>个人博客</a>的“换血”，页面风格没什么大的改版，<strong>重点是在后端数据接口的开发设计，和前端代码的重构，加上了 react 动态加载多说评论系统（使用 redux 分离数据逻辑处理代码），也加上了服务器渲染，都是为了 SEO 和首屏渲染！</strong></p><p><strong>地址: <a href=http://blog.moyuyc.xyz>http://blog.moyuyc.xyz</a></strong></p><p><strong>仓库地址: <a href=https://github.com/moyuyc/isomorphic-blog>isomorphic-blog</a></strong></p><p>感谢陈老板的服务器！</p><p>总结下开发过程中学习到的东西或者坑！</p><h2 id=学习的总结><a href=#%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%80%BB%E7%BB%93 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>学习的总结</h2><h3 id=node模块寻找><a href=#node%E6%A8%A1%E5%9D%97%E5%AF%BB%E6%89%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>node模块寻找</h3><p>对于该项目，前后端都需要 node package，所以对于项目包的管理是否重要！</p><p>如下文件结构</p><pre><code data-query={} data-lang>blog/\\n├── backend/\\n│   ├── a.js\\n│   └── node_modules/ # module => express\\n├── frontend/\\n│   ├── b.js\\n│   └── node_modules/ # module => react\\n├── outter.js\\n└── node_modules/  # module => jquery\\n</code></pre><ul><li>outter.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><ul><li>backend/a.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><ul><li>frontend/b.js</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>require</span>(<span class=hljs-string>'express'</span>);\\n<span class=hljs-comment>// Error: Cannot find module</span>\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'react'</span>);\\n<span class=hljs-built_in>require</span>(<span class=hljs-string>'jquery'</span>);</code></pre><p>如上各文件的引入包的情况，可知 node 加载非绝对路径或者相对路径的包，是首先加载该文件同级目录 <code>node_modules/</code> 寻找，然后依次向父级目录延伸，直到 <code>/</code> 根目录。</p><p><em>其他文件 <code>.babelrc/.gitignore/.npmignore</code> 加载方式都是一样的！</em></p><p>所以我们只需要在项目最外层 install package，书写 .babelrc ...</p><p>同时一些 <code>npm script</code> 只需要写在项目最外层即可。 只需要在最外层 <code>npm i cross-env --save</code></p><pre><code data-query={} data-lang>\\\"start\\\": \\\"cross-env NODE_ENV=production node backend/index.js\\\"\\n\\\"dev\\\": \\\"cross-env NODE_ENV=development node backend/index.js\\\"\\n\\\"dev:front\\\": \\\"cross-env NODE_ENV=development node frontend/index.js\\\"\\n</code></pre><h3 id=node模块缓存清除><a href=#node%E6%A8%A1%E5%9D%97%E7%BC%93%E5%AD%98%E6%B8%85%E9%99%A4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>node模块缓存清除</h3><p>由于文章是用 markdown 文件形式存储的，如果每次请求文章内容都需要读取文件的话，简直日狗，电脑硬盘也吃不消。</p><p>所以我在服务器启动之前，就进行 markdown 文件遍历解析，保存至内存中，同时监听 markdown 文件夹变化，发生变化就动态更新内存数据。</p><p><em>插一句！TODO: 感觉可以起个进程单独处理文件遍历解析的工作，用 IPC 进行 JSON 数据（不带 function）传输即可，充分利用多核！</em></p><p>这样每次请求只需要读取内存就 OK，速度也比较快。</p><p>同时还监听了配置文件的变化，变化则需要重新加载，那么就需要清除之前的缓存了。</p><pre><code data-query={} data-lang>const clearCache = (modulepath) => delete require.cache[require.resolve(modulepath)]\\n</code></pre><p>如上代码，<code>require.resolve</code> 和 <code>path.resolve</code> 方法基本一致，都是基于 <code>process.cwd()</code> 当前环境路径，解析 <code>..</code> <code>.</code> 得到绝对路径。</p><p><em>再插一句！<code>require(\\\"../path\\\")</code> 中的路径，不是基于 <code>process.cwd()</code> 的，而是 <code>__dirname</code></em></p><h3 id=配置文件-json--yaml><a href=#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-json--yaml aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>配置文件 json => yaml</h3><p>配置文件升级成 yaml 格式，yaml 真是方便！json 格式太僵硬了！</p><img src=false width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim><h3 id=一些轮子><a href=#%E4%B8%80%E4%BA%9B%E8%BD%AE%E5%AD%90 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>一些轮子</h3><ol><li><p>根据 react-router 自动生成 sitemap ，一切为了 搜！索！ <a href=https://github.com/moyuyc/react-router-sitemap-builder>react-router-sitemap-builder</a></p></li><li><p>更好的阅读体验！解析 markdown &amp HTML 图像文本，读取 URL 图片数据得到大小，替换文本！ <img src=false alt width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim> => => => <img src=false width=1003 height=402 data-src=http://obu9je6ng.bkt.clouddn.com/FgyP1Ozhv0F8pA14FosHGobvpP_v?imageslim> <a href=https://github.com/moyuyc/node-markdown-image-size>markdown-image-size</a></p></li><li><p>react+多说踩坑！</p></li></ol><img src=false width=842 height=577 data-src=http://obu9je6ng.bkt.clouddn.com/FmY9Gu9I9nPbZE-40BgH8NRMd8tu?imageslim><p>...不知怎么说，总之就是设置各种参数判断是不是脚本加载完成...</p><p>具体看代码吧 <a href=https://github.com/moyuyc/isomorphic-blog/blob/master/frontend/src/components/DuoshuoComment/index.js>react-duoshuo-comment</a></p><p>又水了一篇...</p><h2 id=其他的一些><a href=#%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他的一些</h2><ul><li><p>发布流程<br>在本地书写完 markdown 后 => git push 至 github => curl url => 服务器触发 git pull 更新文章 => 文件监听变化 => 更新数据 => 发布成功！</p></li><li><p>SEO<br>谷歌真是技术杠杠的，没几天就可以搜到我的站点了，百度还是没有（都已提交网站和 sitemap.txt/robots.txt） <img src=false width=580 height=628 data-src=http://obu9je6ng.bkt.clouddn.com/FocOlJ-S5EvxL2Qrc00zWNif6kyy?imageslim></p></li></ul>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/blog-update.md\n// module id = 1160\n// module chunks = 103"],"sourceRoot":""}