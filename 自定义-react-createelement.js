webpackJsonp([7,113],{1259:function(e,a){e.exports={content:"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id=背景><a href=#%E8%83%8C%E6%99%AF aria-hidden=true><span class=\"icon icon-link\"></span></a>背景</h1><p>在开发 React 应用中，可能会有这么一个需求，对于浏览器默认的 hovering title 行为，如下图： <img src=https://i.loli.net/2020/02/16/zP8EfqWRK6NXvDZ.jpg alt=Jietu20200216-161740.jpg></p><p>有一天，PM 或者 UI MM 突然要求换成自定义的样式，甚至希望显示的时间更可控，如下图 <img src=https://i.loli.net/2020/02/16/69kyKxUWlsPRBoE.png></p><p>对于这个需求，我们一般就需要全局搜索 <code>title</code> 这种关键字，然后进行如下替换</p><pre><code data-query={} data-lang>&lt;p title=\"我是一个无辜的title\">Hi!&lt;/p>\n// =>\n// HoverTitle 为实现了 Hovering title 交互的组件\n&lt;HoverTitle title=\"我是一个无辜的title\">\n    &lt;p>Hi!&lt;/p>\n&lt;/HoverTitle>\n</code></pre><p>这样改动量比较大，也容易有几个漏网之鱼。 有没有什么一劳永逸的方法呢？</p><h1 id=有什么方式><a href=#%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F aria-hidden=true><span class=\"icon icon-link\"></span></a>有什么方式</h1><p>下面有几种方式来实现以上需求： 但实现思路都是覆盖 <code>React.createElement</code>，如下代码：</p><pre><code class=\"hljs language-jsx\"data-query={} data-lang=jsx><span class=hljs-keyword>const</span> rawCreateElement = React.createElement;\n<span class=hljs-keyword>const</span> myCreateElement = <span class=hljs-function>(<span class=hljs-params>name, props, ...children</span>) =></span> {\n    <span class=hljs-keyword>const</span> next = <span class=hljs-function><span class=hljs-params>()</span> =></span> rawCreateElement(name, props, ...children);\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> name === <span class=hljs-string>'string'</span> &amp&amp <span class=hljs-keyword>typeof</span> props.title === <span class=hljs-string>'string'</span> &amp&amp props.title) {\n        <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>HoverTitle</span> <span class=hljs-attr>title</span>=<span class=hljs-string>{props.title}</span>></span>{next()}<span class=hljs-tag>&lt;/<span class=hljs-name>HoverTitle</span>></span></span>\n    }\n    <span class=hljs-keyword>return</span> next()\n}</code></pre><p>那么我们应该如何才能快捷地全局覆盖 <code>React.createElement</code> 呢？ 下面介绍如下几种方法</p><h3 id=语法匹配替换用><a href=#%E8%AF%AD%E6%B3%95%E5%8C%B9%E9%85%8D%E6%9B%BF%E6%8D%A2%E7%94%A8 aria-hidden=true><span class=\"icon icon-link\"></span></a>语法匹配替换用</h3><p>使用 <a href=https://www.npmjs.com/package/babel-plugin-transform-react-jsx><code>babel-plugin-transform-react-jsx</code></a> 来更改 jsx 转化逻辑，将 jsx 用到的 <code>createElement</code> 替换成 <code>myCreateElement</code></p><p>但是这样并不完备，比如直接显示使用 <code>React.createElment</code> 或者 <code>React.createFactory</code> 的地方则不能涵盖到，所以我们还需要额外书写 Babel 插件来替换 <code>React.createElment</code> <code>React.createFactory</code> 关键字</p><h3 id=替换引入路径><a href=#%E6%9B%BF%E6%8D%A2%E5%BC%95%E5%85%A5%E8%B7%AF%E5%BE%84 aria-hidden=true><span class=\"icon icon-link\"></span></a>替换引入路径</h3><p>我们还可以换种思路，将 <code>import React from 'react'</code> 替换成 <code>import React from 'my-custom-react'</code></p><p>在 <code>'my-custom-react'</code> 文件中，覆盖 React</p><pre><code data-query={} data-lang>const React = require('react')\n\nmodule.exports = Object.assign({}, React, {\n    createElement: require('./my-custom-create-element'),\n    createFactory: require('./my-custom-create-factory')\n})\n</code></pre><p>同时我们在 <code>./my-custom-create-element</code> 和 <code>./my-custom-create-factory</code> 文件中用到的 <code>React.createElement</code> 和 <code>React.createFactory</code> 需要是原始的，不然会陷入无穷套娃中。</p><p>下面有两种方式来实现这种方式 1. babel 插件修改规则 2. <a href=https://github.com/webpack/enhanced-resolve>enhanced-resolve</a> 插件修改规则</p><p>enhanced-resolve 是 Webpack 中使用的可拔插的 resolve 路径包，其实现了 Node.js 中的 <code>require.resolve</code> 算法(支持异步)，我们可以利用其暴露的一些勾子来自定义自己的 <code>resovle</code> 逻辑。即我们可以将 <code>resolve('react')</code> 输出为 <code>'my-custom-react'</code></p><p>以上两种方式各有优劣 |方式 | 优点 | 缺点| |---|----|----| |Babel插件|生态好，基本可以方便接入任何构建工具<code>webpack</code>/<code>rollup</code> 等|对于动态引入的模块，匹配麻烦，如 require('rea' + 'ct')| |enhanced-resolve插件|webpack 接入方便，实现方便|在非webpack生态中，可能不好接入|</p><p>除了以上两种思路之外，还有一个不大合适的思路</p><h3 id=自定义-react-renderer><a href=#%E8%87%AA%E5%AE%9A%E4%B9%89-react-renderer aria-hidden=true><span class=\"icon icon-link\"></span></a>自定义 React Renderer</h3><p>在这里不深入展开，主要是自己使用<a href=https://github.com/facebook/react/tree/master/packages/react-reconciler>react-reconciler</a>实现 <code>ReactDOM.render</code>。</p><p>对于该需求，自己实现一个 <code>ReactDOM.render</code> 有些舍近求远，该方式更适合于渲染同一份 React 代码，在不同的运行环境（如浏览器: <code>ReactDOM</code>、服务端 <code>ReactDOMServer</code>、移动端 <code>ReactNative</code>）</p><h1 id=实现><a href=#%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\"icon icon-link\"></span></a>实现</h1><p>在这里，我使用的是 <code>enhanced-resolve</code> 插件实现 <a href=https://github.com/imcuttle/module-mock-plugin>module-mock-plugin</a>，这里有一篇相当详尽的 <a href=https://juejin.im/post/5c6b78cdf265da2da15db125><code>Webpack resolve</code></a> 介绍</p><p>使用该插件，我们可以如下组织我们的项目代码</p><pre><code data-query={} data-lang>src/\n    __mock/\n        react/ # custom react\nnode_modules/\n    react/\n</code></pre><p>在 <code>src/__mock/react/index.js</code> 中可以覆写 React 实现</p>",extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=自定义-react-createelement.js.map