{"version":3,"sources":["webpack:///自研协同文档服务-dozo.js","webpack:///./source/_articles/自研协同文档服务-dozo.md"],"names":["webpackJsonp","1260","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,EAAE,MAEVC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,2pLACAC,OACAC,oBACAC","file":"自研协同文档服务-dozo.js","sourcesContent":["webpackJsonp([6,113],{\n\n/***/ 1260:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>最近一段时间，疫情爆发，对于全球工作人员复工提出了新的挑战！<strong>远程办公，远程授课</strong>成为刚需。 对于远程办公，肯定离不开一个词：<strong>协同</strong>。对于我们日常工作最常见的工作输出载体：文档，也离不开协同</p><p>如下图，为个人实现的协同编辑服务 - Dozo 的示意图： <img src=https://i.loli.net/2020/05/17/ypOQxwzKYXtHloE.gif alt=dozo.gif></p><p>相比于市面上成熟的商用协同产品：如 yuque、feishu、腾讯文档、石墨文档...，只能是小巫见大巫，但是对于个人使用，团队内使用还是值得一试的，后续将会开源，敬请期待。</p><p>下面将对 Dozo 的功能、架构设计和实现展开说明。</p><h2 id=dozo-功能介绍><a href=#dozo-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 功能介绍</h2><h3 id=协同编辑><a href=#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>协同编辑</h3><p>如上图，Dozo 能够协同编辑，会实时同步其他用户的编辑光标</p><h3 id=评论><a href=#%E8%AF%84%E8%AE%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>评论</h3><p>如下图，Dozo 文档支持行评论 <img src=https://i.loli.net/2020/05/20/PeGhkHyu1zWpo8b.png alt=image.png></p><h3 id=分享><a href=#%E5%88%86%E4%BA%AB aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>分享</h3><p>如下图，Dozo 文档支持对外分享，发送分享链接至被分享人 <img src=https://i.loli.net/2020/05/20/jQErMP8evfynwKm.png alt=image.png></p><p>可以设置密码，设置外部访问的权限：可读或可写</p><h3 id=权限控制><a href=#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>权限控制</h3><p>除了分享文档设置读写权限以外，还可以设置文档权限，可以设置为 完全公开、组织内可见、私有，如下 <img src=https://i.loli.net/2020/05/20/1zRK98CYQjxvmHb.png alt=image.png></p><p>同时，组织的拥有者和管理员，能够管理组织成员 <img src=https://i.loli.net/2020/05/20/jgDLZSnzvJ95xYa.png alt=image.png></p><h3 id=内容搜索><a href=#%E5%86%85%E5%AE%B9%E6%90%9C%E7%B4%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>内容搜索</h3><p>Dozo 基于 Elasticsearch 实现了自己权限内的内容搜索 <img src=https://i.loli.net/2020/05/20/FytTm3NIJa5KcZw.png alt=image.png></p><h3 id=文稿模板><a href=#%E6%96%87%E7%A8%BF%E6%A8%A1%E6%9D%BF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>文稿模板</h3><p>可以设置文稿类型为模板，从而可以从新文稿中选择模板 <img src=https://i.loli.net/2020/05/20/LsA56fkSI4ytJgU.png alt=image.png></p><p><img src=https://i.loli.net/2020/05/20/FGkby4IKRwLhaf5.png alt=image.png></p><h3 id=消息通知><a href=#%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>消息通知</h3><p>当有人对你的文稿评论，或者文档中 @ 你，你将会收到邮件通知</p><p><img src=https://i.loli.net/2020/05/20/K7LbPip3ahlv9Vs.png alt=image.png></p><h2 id=dozo-架构设计--实现><a href=#dozo-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 架构设计 &amp 实现</h2><h3 id=dozo-前端><a href=#dozo-%E5%89%8D%E7%AB%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 前端</h3><ul><li>React</li><li>Antd</li><li>Mobx</li><li>Socket.IO Client</li><li>Slate.js</li></ul><h3 id=dozo-后端><a href=#dozo-%E5%90%8E%E7%AB%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 后端</h3><ul><li>Express</li><li>Socket.IO</li><li>Redis</li><li>Elasticsearch</li><li>MySQL</li></ul><h3 id=协同编辑的实现><a href=#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E7%9A%84%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>协同编辑的实现</h3><p>前端使用 <code>slate.js</code> 实现富文本编辑器，其中 <code>slate.js</code> 能够将每一次的操作抽象成自己的数据模型 <code>Operation</code>，于是我们只需要每一次操作，传递该操作的 <code>operation</code> 数据至服务端，通过服务端广播该 <code>operation</code> 至其他客户端即可。这样就能达到不同客户端之间的操作同步，同时我们还需要把文稿进行持久化存储。</p><p>在第一个连接建立后，服务端从数据库中读取文稿数据至内存中，并输出至客户端；当服务端获取来自客户端的 <code>operation</code> 之后，更新于服务端内存中的文稿对象；并且会节流的写入数据库，防止服务崩溃导致数据丢失；同时在某一篇文稿的客户端连接全部断开后，会把服务端文稿写入数据库；这样能有效的减少数据库的写操作。</p><h3 id=分布式--集群><a href=#%E5%88%86%E5%B8%83%E5%BC%8F--%E9%9B%86%E7%BE%A4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>分布式 &amp 集群</h3><p>Dozo 服务的架构如下，由 8 个分布式子服务组成，各个节点又可以构成各自的集群，如下图 <img src=https://i.loli.net/2020/05/20/GVq7U8R1Pb4wHhX.png alt=未命名绘图.png></p><p>其中：</p><ul><li>web: HTTP Web Service，负责主要的业务逻辑</li><li>fileman: 负责文件处理上传、存储</li><li>static: 前端静态服务</li><li>ws: Websocket service，协同实现的服务端关键</li><li>worker: 负责处理其他任务，如发送通知，邮件；推送文档数据至 elasticsearch</li><li>其他 redis / elasticsearch / mysql 服务就不多介绍了，第三方十分主流的服务</li></ul><h4 id=多节点集群的搭建><a href=#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>多节点集群的搭建</h4><p>使用多节点集群和负载均衡，可以大幅度减少单节点的并发数；其中 web / fileman / static 服务多节点集群的搭建比较简单，直接搭配负载均衡，分流到不同节点即可；但是对于 websocket 服务来说，多节点服务并不简单！</p><p>其中有以下问题：</p><ol><li><p>对于 socket.io 来说，建立连接之前，会一段（多个）HTTP请求响应的通信，这时候需要始终保存与固定的 ws 服务通信，所以不能通过简单的轮询来负载均衡，需要通过 ip 网段映射表来分流（会话保持），可就是同一个 ip 始终走同一个 ws 服务；</p></li><li><p>多个不同 ws 服务之间需要共享数据，共享 socket 通道；<br>如，ws1 服务有 a b 客户端连接，ws2 服务有 c d 客户端连接；这时候 ws1 如何才能知道整体 ws 服务当前有多少客户端连接？ ws1 可以通过 redis 发布 getSockets 消息，ws2 在订阅 getSockets 消息后，返回 ws2 所有的 sockets，从而 ws1 通过 ws2.sockets 和 ws1.sockets 合并，即可获取整体 ws 服务的 sockets；<br>又如，ws1 服务需要对整体 ws 客户端广播发送 hello 消息，除了需要对自身 ws1 进程中的 sockets 进行广播；还需要广播消息 <code>{type: 'broadcase', value: 'hello'}</code>, ws2 / ws3 /... 接受消息后，也在当前进程广播消息 <code>hello</code>；</p></li><li><p>在上文提到的协同编辑实现原理的简单介绍中，我们知道 ws 服务进程在内存中是有文稿数据的；这样设计在单节点的时候就没有问题的，但是多节点情境下，该方案是不可行的，随时可能会有数据不同步，数据覆盖的问题出现；<br>鉴于以上问题，所以考虑把文稿数据存入单节点 redis 中，通过对单节点 redis 内存的读写操作，避免数据覆盖问题；</p><p><strong>但是</strong>这样问题就解决了吗？如某时刻有客户端操作发送至 ws1 节点，ws1 服务端正常的流程如下：</p><pre><code data-query={} data-lang>async applyOperation(operation) {\\n   // 从 redis 获取文稿\\n   const doc = await redis.getDocument()  // 1\\n   // 更新 doc\\n   applyOperationToDoc(doc, operation)  // 2\\n   // 写入 doc\\n   await redis.setDocument(doc) // 3\\n}\\n</code></pre><p>当 ws1 节点完成 1 之后，进入 2 之前，这时 ws2 也收到 operation，同时 ws2 也完成 1；这样后续 ws1 / ws2 接着后续流程，可以看到，很可能会丢失掉某批次客户端的操作，至于该问题如何解决，先卖个关子，后续持续完善。</p></li></ol>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 自研协同文档服务-dozo.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>最近一段时间，疫情爆发，对于全球工作人员复工提出了新的挑战！<strong>远程办公，远程授课</strong>成为刚需。 对于远程办公，肯定离不开一个词：<strong>协同</strong>。对于我们日常工作最常见的工作输出载体：文档，也离不开协同</p><p>如下图，为个人实现的协同编辑服务 - Dozo 的示意图： <img src=https://i.loli.net/2020/05/17/ypOQxwzKYXtHloE.gif alt=dozo.gif></p><p>相比于市面上成熟的商用协同产品：如 yuque、feishu、腾讯文档、石墨文档...，只能是小巫见大巫，但是对于个人使用，团队内使用还是值得一试的，后续将会开源，敬请期待。</p><p>下面将对 Dozo 的功能、架构设计和实现展开说明。</p><h2 id=dozo-功能介绍><a href=#dozo-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 功能介绍</h2><h3 id=协同编辑><a href=#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>协同编辑</h3><p>如上图，Dozo 能够协同编辑，会实时同步其他用户的编辑光标</p><h3 id=评论><a href=#%E8%AF%84%E8%AE%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>评论</h3><p>如下图，Dozo 文档支持行评论 <img src=https://i.loli.net/2020/05/20/PeGhkHyu1zWpo8b.png alt=image.png></p><h3 id=分享><a href=#%E5%88%86%E4%BA%AB aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>分享</h3><p>如下图，Dozo 文档支持对外分享，发送分享链接至被分享人 <img src=https://i.loli.net/2020/05/20/jQErMP8evfynwKm.png alt=image.png></p><p>可以设置密码，设置外部访问的权限：可读或可写</p><h3 id=权限控制><a href=#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>权限控制</h3><p>除了分享文档设置读写权限以外，还可以设置文档权限，可以设置为 完全公开、组织内可见、私有，如下 <img src=https://i.loli.net/2020/05/20/1zRK98CYQjxvmHb.png alt=image.png></p><p>同时，组织的拥有者和管理员，能够管理组织成员 <img src=https://i.loli.net/2020/05/20/jgDLZSnzvJ95xYa.png alt=image.png></p><h3 id=内容搜索><a href=#%E5%86%85%E5%AE%B9%E6%90%9C%E7%B4%A2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>内容搜索</h3><p>Dozo 基于 Elasticsearch 实现了自己权限内的内容搜索 <img src=https://i.loli.net/2020/05/20/FytTm3NIJa5KcZw.png alt=image.png></p><h3 id=文稿模板><a href=#%E6%96%87%E7%A8%BF%E6%A8%A1%E6%9D%BF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>文稿模板</h3><p>可以设置文稿类型为模板，从而可以从新文稿中选择模板 <img src=https://i.loli.net/2020/05/20/LsA56fkSI4ytJgU.png alt=image.png></p><p><img src=https://i.loli.net/2020/05/20/FGkby4IKRwLhaf5.png alt=image.png></p><h3 id=消息通知><a href=#%E6%B6%88%E6%81%AF%E9%80%9A%E7%9F%A5 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>消息通知</h3><p>当有人对你的文稿评论，或者文档中 @ 你，你将会收到邮件通知</p><p><img src=https://i.loli.net/2020/05/20/K7LbPip3ahlv9Vs.png alt=image.png></p><h2 id=dozo-架构设计--实现><a href=#dozo-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1--%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 架构设计 &amp 实现</h2><h3 id=dozo-前端><a href=#dozo-%E5%89%8D%E7%AB%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 前端</h3><ul><li>React</li><li>Antd</li><li>Mobx</li><li>Socket.IO Client</li><li>Slate.js</li></ul><h3 id=dozo-后端><a href=#dozo-%E5%90%8E%E7%AB%AF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>Dozo 后端</h3><ul><li>Express</li><li>Socket.IO</li><li>Redis</li><li>Elasticsearch</li><li>MySQL</li></ul><h3 id=协同编辑的实现><a href=#%E5%8D%8F%E5%90%8C%E7%BC%96%E8%BE%91%E7%9A%84%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>协同编辑的实现</h3><p>前端使用 <code>slate.js</code> 实现富文本编辑器，其中 <code>slate.js</code> 能够将每一次的操作抽象成自己的数据模型 <code>Operation</code>，于是我们只需要每一次操作，传递该操作的 <code>operation</code> 数据至服务端，通过服务端广播该 <code>operation</code> 至其他客户端即可。这样就能达到不同客户端之间的操作同步，同时我们还需要把文稿进行持久化存储。</p><p>在第一个连接建立后，服务端从数据库中读取文稿数据至内存中，并输出至客户端；当服务端获取来自客户端的 <code>operation</code> 之后，更新于服务端内存中的文稿对象；并且会节流的写入数据库，防止服务崩溃导致数据丢失；同时在某一篇文稿的客户端连接全部断开后，会把服务端文稿写入数据库；这样能有效的减少数据库的写操作。</p><h3 id=分布式--集群><a href=#%E5%88%86%E5%B8%83%E5%BC%8F--%E9%9B%86%E7%BE%A4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>分布式 &amp 集群</h3><p>Dozo 服务的架构如下，由 8 个分布式子服务组成，各个节点又可以构成各自的集群，如下图 <img src=https://i.loli.net/2020/05/20/GVq7U8R1Pb4wHhX.png alt=未命名绘图.png></p><p>其中：</p><ul><li>web: HTTP Web Service，负责主要的业务逻辑</li><li>fileman: 负责文件处理上传、存储</li><li>static: 前端静态服务</li><li>ws: Websocket service，协同实现的服务端关键</li><li>worker: 负责处理其他任务，如发送通知，邮件；推送文档数据至 elasticsearch</li><li>其他 redis / elasticsearch / mysql 服务就不多介绍了，第三方十分主流的服务</li></ul><h4 id=多节点集群的搭建><a href=#%E5%A4%9A%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>多节点集群的搭建</h4><p>使用多节点集群和负载均衡，可以大幅度减少单节点的并发数；其中 web / fileman / static 服务多节点集群的搭建比较简单，直接搭配负载均衡，分流到不同节点即可；但是对于 websocket 服务来说，多节点服务并不简单！</p><p>其中有以下问题：</p><ol><li><p>对于 socket.io 来说，建立连接之前，会一段（多个）HTTP请求响应的通信，这时候需要始终保存与固定的 ws 服务通信，所以不能通过简单的轮询来负载均衡，需要通过 ip 网段映射表来分流（会话保持），可就是同一个 ip 始终走同一个 ws 服务；</p></li><li><p>多个不同 ws 服务之间需要共享数据，共享 socket 通道；<br>如，ws1 服务有 a b 客户端连接，ws2 服务有 c d 客户端连接；这时候 ws1 如何才能知道整体 ws 服务当前有多少客户端连接？ ws1 可以通过 redis 发布 getSockets 消息，ws2 在订阅 getSockets 消息后，返回 ws2 所有的 sockets，从而 ws1 通过 ws2.sockets 和 ws1.sockets 合并，即可获取整体 ws 服务的 sockets；<br>又如，ws1 服务需要对整体 ws 客户端广播发送 hello 消息，除了需要对自身 ws1 进程中的 sockets 进行广播；还需要广播消息 <code>{type: 'broadcase', value: 'hello'}</code>, ws2 / ws3 /... 接受消息后，也在当前进程广播消息 <code>hello</code>；</p></li><li><p>在上文提到的协同编辑实现原理的简单介绍中，我们知道 ws 服务进程在内存中是有文稿数据的；这样设计在单节点的时候就没有问题的，但是多节点情境下，该方案是不可行的，随时可能会有数据不同步，数据覆盖的问题出现；<br>鉴于以上问题，所以考虑把文稿数据存入单节点 redis 中，通过对单节点 redis 内存的读写操作，避免数据覆盖问题；</p><p><strong>但是</strong>这样问题就解决了吗？如某时刻有客户端操作发送至 ws1 节点，ws1 服务端正常的流程如下：</p><pre><code data-query={} data-lang>async applyOperation(operation) {\\n   // 从 redis 获取文稿\\n   const doc = await redis.getDocument()  // 1\\n   // 更新 doc\\n   applyOperationToDoc(doc, operation)  // 2\\n   // 写入 doc\\n   await redis.setDocument(doc) // 3\\n}\\n</code></pre><p>当 ws1 节点完成 1 之后，进入 2 之前，这时 ws2 也收到 operation，同时 ws2 也完成 1；这样后续 ws1 / ws2 接着后续流程，可以看到，很可能会丢失掉某批次客户端的操作，至于该问题如何解决，先卖个关子，后续持续完善。</p></li></ol>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/自研协同文档服务-dozo.md\n// module id = 1260\n// module chunks = 6"],"sourceRoot":""}