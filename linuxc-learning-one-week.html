<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> linux C一周学习 - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="555156439"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">linux C一周学习</h1><div class="post-info" data-reactid="12"><time datetime="2016-10-12T12:57:36+00:00" data-reactid="13">Oct 12, 2016 12:57 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p data-reactid="17"><!-- react-text: 18 -->还记得大一懵懂的时候，第一门专业课便是C语言了，当时都没接触过编程，而且用的是win32，老师也讲的就是一些<!-- /react-text --><code data-reactid="19">if while</code><!-- react-text: 20 -->语法知识，指针数组等等。<!-- /react-text --></p><p data-reactid="21">没有涉及到linux系统调用函数，不过也理所当然，因为当时根本对操作系统，汇编，计算机系统等一概不懂，讲了也只是换来更多的懵逼脸。</p><p data-reactid="22">那三年后的我，为什么又重新学习C呢？</p><p data-reactid="23"><!-- react-text: 24 -->因为大四还有一门tcp/ip网络编程，老师和书本是基于<!-- /react-text --><code data-reactid="25">unix socket</code><!-- react-text: 26 -->和<!-- /react-text --><code data-reactid="27">winsocket</code><!-- react-text: 28 -->的。其实在大三网络课里面，老师就有要求完成一个tcp和udp的聊天程序，当时用的是<!-- /react-text --><code data-reactid="29">nodejs</code><!-- react-text: 30 -->的<!-- /react-text --><code data-reactid="31">net package</code><!-- react-text: 32 -->. 使用node完成的可就简单了，net包为你实现了请求的队列和一套异步编程api。<!-- /react-text --></p><p data-reactid="33"><strong data-reactid="34">但在c中，socket只是一个位于tcp/udp之上的一层，多请求的处理，你可以采用多进程/多线程，也可以采用单进程轮询处理（往往搭配非阻塞IO）；IO操作你也可以使用阻塞和非阻塞，随你喜欢。</strong></p><p data-reactid="35">但这些名词，只有在你理解了计算机系统后才能运用自如。</p><p data-reactid="36"><!-- react-text: 37 -->而且C也可以与node结合起来，参看<!-- /react-text --><a href="https://github.com/nodejs/node-addon-examples/" data-reactid="38">node addon</a><!-- react-text: 39 -->，所以之后遇到计算量大和趋向底层的活，完全可以交给c实现。<!-- /react-text --></p><p data-reactid="40">于是乎，我便开始了学习linux c之旅。</p><h2 id="疑难总结" data-reactid="41"><a href="#%E7%96%91%E9%9A%BE%E6%80%BB%E7%BB%93" aria-hidden="true" data-reactid="42"><span class="icon icon-link" data-reactid="43"></span></a><!-- react-text: 44 -->疑难总结<!-- /react-text --></h2><ol data-reactid="45"><li data-reactid="46"><code data-reactid="47">char* a = &quot;123&quot;;</code><!-- react-text: 48 -->与 <!-- /react-text --><code data-reactid="49">char b[] = &quot;123&quot;;</code><br data-reactid="50"/><!-- react-text: 51 -->在执行<!-- /react-text --><code data-reactid="52">char* a = &quot;123&quot;;</code><!-- react-text: 53 -->时，编译器会把<!-- /react-text --><code data-reactid="54">&quot;123&quot;</code><!-- react-text: 55 -->当成字符串常量，而a指向的正式<!-- /react-text --><code data-reactid="56">&#x27;a&#x27;</code><!-- react-text: 57 -->的地址，而字符串的结束标志为<!-- /react-text --><code data-reactid="58">&#x27;\0&#x27;</code><!-- react-text: 59 -->. 这就是为什么不能<!-- /react-text --><code data-reactid="60">strcat(a, b)</code><!-- react-text: 61 -->, 因为a指向的是常量字符串。<!-- /react-text --><br data-reactid="62"/><!-- react-text: 63 -->那么下面这段程序执行时什么结果呢？<!-- /react-text --></li></ol><pre data-reactid="64"><code class="hljs language-c" data-query="{}" data-lang="c" data-reactid="65"><span class="hljs-keyword" data-reactid="66">char</span><!-- react-text: 67 -->* x = <!-- /react-text --><span class="hljs-string" data-reactid="68">&quot;123&quot;</span><!-- react-text: 69 -->;
<!-- /react-text --><span class="hljs-keyword" data-reactid="70">char</span><!-- react-text: 71 --> y[] = <!-- /react-text --><span class="hljs-string" data-reactid="72">&quot;123&quot;</span><!-- react-text: 73 -->;
<!-- /react-text --><span class="hljs-built_in" data-reactid="74">printf</span><!-- react-text: 75 -->(<!-- /react-text --><span class="hljs-string" data-reactid="76">&quot;%s %s %d %d %d\n&quot;</span><!-- react-text: 77 -->, <!-- /react-text --><span class="hljs-built_in" data-reactid="78">strcat</span><!-- react-text: 79 -->(y, x), y, <!-- /react-text --><span class="hljs-keyword" data-reactid="80">sizeof</span><!-- react-text: 81 -->(y), <!-- /react-text --><span class="hljs-built_in" data-reactid="82">strlen</span><!-- react-text: 83 -->(y), <!-- /react-text --><span class="hljs-keyword" data-reactid="84">sizeof</span><!-- react-text: 85 -->(x));
<!-- /react-text --><span class="hljs-comment" data-reactid="86">// 123123 123123 4 6 8</span></code></pre><ol start="2" data-reactid="87"><li data-reactid="88"><code data-reactid="89">char** s;</code><!-- react-text: 90 --> 二级指针<!-- /react-text --></li></ol><pre data-reactid="91"><code class="hljs language-c" data-query="{}" data-lang="c" data-reactid="92"><span class="hljs-keyword" data-reactid="93">char</span><!-- react-text: 94 -->  **s;  
*s = <!-- /react-text --><span class="hljs-string" data-reactid="95">&quot;hello world&quot;</span><!-- react-text: 96 -->; <!-- /react-text --></code></pre><p data-reactid="97"><!-- react-text: 98 -->上面这段程序是有错的，因为没有给s分配空间,也就是s指向（值）为空（不可读写）， <!-- /react-text --><code data-reactid="99">malloc</code><!-- react-text: 100 -->之后，s指向一个可以读写的内存块。<!-- /react-text --></p><p data-reactid="101"><!-- react-text: 102 -->更多参看 <!-- /react-text --><a href="http://blog.csdn.net/daiyutage/article/details/8604720" data-reactid="103">http://blog.csdn.net/daiyutage/article/details/8604720</a></p><h2 id="知识总结" data-reactid="104"><a href="#%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93" aria-hidden="true" data-reactid="105"><span class="icon icon-link" data-reactid="106"></span></a><!-- react-text: 107 -->知识总结<!-- /react-text --></h2><ol data-reactid="108"><li data-reactid="109"><p data-reactid="110">网络编程</p><ol data-reactid="111"><li data-reactid="112">如何知道服务器或者客户端断开了连接？（read() == 0）</li><li data-reactid="113">处理多请求的俩种服务器实现（fork/select）</li><li data-reactid="114"><p data-reactid="115">一些&quot;奇怪&quot;现象的解释</p><ol data-reactid="116"><li data-reactid="117">主动关闭连接的一方要处于TIME_WAIT状态，等待两个MSL（maximum segment lifetime）的时间后才能回到CLOSED状态</li><li data-reactid="118">网络服务器通常用fork来同时服务多个客户端，父进程专门负责监听端口，每次accept一个新的客户端连接就fork出一个子进程专门服务这个客户端。但是子进程退出时会产生僵尸进程，父进程要注意处理SIGCHLD信号和调用wait清理僵尸进程。</li><li data-reactid="119">server对每个请求只处理一次，应答后就关闭连接，client不能继续使用这个连接发送数据。但是client下次循环时又调用write发数据给server，write调用只负责把数据交给TCP发送缓冲区就可以成功返回了，所以不会出错，而server收到数据后应答一个RST段，client收到RST段后无法立刻通知应用层，只把这个状态保存在TCP协议层。client下次循环又调用write发数据给server，由于TCP协议层已经处于RST状态了，因此不会将数据发出，而是发一个SIGPIPE信号给应用层，SIGPIPE信号的缺省处理动作是终止程序</li></ol></li></ol></li><li data-reactid="120"><p data-reactid="121">进程</p><ol data-reactid="122"><li data-reactid="123">shell的工作方式，fork -&gt; exec</li><li data-reactid="124">fork与exec</li><li data-reactid="125">shell的实现，改变current work path, 实现pipe与输入输出重定向</li><li data-reactid="126">...</li></ol></li><li data-reactid="127"><p data-reactid="128">文件系统</p><ol data-reactid="129"><li data-reactid="130">erverything is file</li><li data-reactid="131">dup与dup2运用, 重定向</li><li data-reactid="132">link/ln stat/lstat</li><li data-reactid="133">...</li></ol></li><li data-reactid="134">库函数与系统函数</li></ol><h2 id="编码实践" data-reactid="135"><a href="#%E7%BC%96%E7%A0%81%E5%AE%9E%E8%B7%B5" aria-hidden="true" data-reactid="136"><span class="icon icon-link" data-reactid="137"></span></a><!-- react-text: 138 -->编码实践<!-- /react-text --></h2><p data-reactid="139"><!-- react-text: 140 -->学的虽然挺多的，但是需要做的东西出来才能掌握。 1. c实现shell (掌握linux内核函数，进程管道通信，文件描述符等概念)<!-- /react-text --><br data-reactid="141"/><a href="https://github.com/moyuyc/c_cpp-node_c_cpp_addon/blob/master/cpp_src/shell.h" data-reactid="142">source file</a></p><ol start="2" data-reactid="143"><li data-reactid="144"><p data-reactid="145"><!-- react-text: 146 -->tcp双向通信 (select()/fork()两种方式)<!-- /react-text --><br data-reactid="147"/><a href="https://github.com/moyuyc/c_cpp-node_c_cpp_addon/blob/master/cpp_src/server.h" data-reactid="148">source file Server</a><br data-reactid="149"/><a href="https://github.com/moyuyc/c_cpp-node_c_cpp_addon/blob/master/cpp_src/client.h" data-reactid="150">source file Client</a></p></li><li data-reactid="151"><p data-reactid="152"><!-- react-text: 153 -->node addon(node调用c/c++)<!-- /react-text --><br data-reactid="154"/><a href="https://github.com/moyuyc/c_cpp-node_c_cpp_addon/tree/master/node_src" data-reactid="155">source file</a></p></li></ol><h2 id="闲话" data-reactid="156"><a href="#%E9%97%B2%E8%AF%9D" aria-hidden="true" data-reactid="157"><span class="icon icon-link" data-reactid="158"></span></a><!-- react-text: 159 -->闲话<!-- /react-text --></h2><p data-reactid="160">上面简单总结了一下知识和成果，我觉得学习linux c是十分必要的，可以将整个计算机系统理论串联起来，而且后续有必要的话，完全可以重零开始，自己造轮子。</p><p data-reactid="161"><!-- react-text: 162 -->然后推荐两个项目，都是用linux c写的 1. <!-- /react-text --><a href="https://github.com/EZLippi/Tinyhttpd" data-reactid="163">TinyHttpd</a><br data-reactid="164"/><!-- react-text: 165 -->500+行代码实现一个小型web服务器，助于理解web 服务器本质，而不再是只会使用现成的web服务器。代码不多，便于学习。<!-- /react-text --></p><ol start="2" data-reactid="166"><li data-reactid="167"><a href="https://github.com/posva/catimg" data-reactid="168">catimg</a><br data-reactid="169"/><!-- react-text: 170 -->将图片print在shell中，便于学习unix字符转义，shell窗口控制，图像处理<!-- /react-text --></li></ol><p data-reactid="171"><!-- react-text: 172 -->最后力荐一本电子书<!-- /react-text --><a href="http://akaedu.github.io/book/" data-reactid="173">【Linux C编程一站式学习】</a><!-- react-text: 174 -->，学习linux C就靠它！<!-- /react-text --></p></article></div><div class="gitment-container" data-reactid="175"></div><div class="paginator" data-reactid="176"><a title="npm命令行小结" class="prev" href="/npm-cached-option" data-reactid="177">Prev</a><a title="分片上传与断点续传解决方案" class="next" href="/slice-and-breakpoint-up-down" data-reactid="178">Next</a></div></div></main><footer data-reactid="179"><div class="copyright" data-reactid="180"><p data-reactid="181"><!-- react-text: 182 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="183">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
