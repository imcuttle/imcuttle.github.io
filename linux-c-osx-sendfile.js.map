{"version":3,"sources":["webpack:///linux-c-osx-sendfile.js","webpack:///./source/_articles/linux-c-osx-sendfile.md"],"names":["webpackJsonp","1192","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,g6VACAC,OACAC,oBACAC","file":"linux-c-osx-sendfile.js","sourcesContent":["webpackJsonp([72,113],{\n\n/***/ 1192:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>今天，来小结一下纠结我几个小时的linux C。需求是这样的，<em>用c实现tcp的文件上传与下载</em></p><p>一开始，很容易想到的上传思路是，直接在内存中开一块<code>buffer</code>，得到一个<code>file description</code>后，进行一读一发。</p><!--more--><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>char</span> buffer[<span class=hljs-number>1024</span>];\\n<span class=hljs-keyword>int</span> fd = open(path, O_RDONLY);\\n<span class=hljs-keyword>int</span> n = read(fd, buffer, <span class=hljs-number>1024</span>);\\n<span class=hljs-keyword>if</span>(n&lt;<span class=hljs-number>0</span>) {\\n    perror(<span class=hljs-string>\\\"read\\\"</span>);\\n}\\nbuffer[n] = <span class=hljs-number>0</span>;\\n\\nwrite(socket, buffer, n);\\n\\n<span class=hljs-comment>//...</span></code></pre><p><strong>然而，其实在linux内核中已经实现了一种更为高效的方法，<code>sendfile</code></strong><br>不需要频繁的调用<code>read/write</code>,也不需要开辟buffer，减少了内核函数的调用，提高性能。</p><h2 id=函数说明><a href=#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>函数说明</h2><ul><li><p>定义</p><pre><code data-query={} data-lang>  int sendfile(int fd, int s, off_t offset, off_t *len, struct sf_hdtr *hdtr, int flags);\\n</code></pre></li><li><p>解释</p></li></ul><table><thead><tr><th>argument name</th><th>explantion</th></tr></thead><tbody><tr><td>fd</td><td>需要发送的文件的fd(file description)</td></tr><tr><td>s</td><td>socket的fd</td></tr><tr><td>offset</td><td>文件从那开始发,NULL表示为0</td></tr><tr><td>len</td><td>输出参数，输出一共发送了多少byte,包括后面的hdtr</td></tr><tr><td>hdtr</td><td>额外发送的头和尾</td></tr><tr><td>flags</td><td>设置为0即可</td></tr></tbody></table><p>关于flags, man page原文如下:</p><blockquote><p>The flags parameter is reserved for future expansion and must be set to 0. Any other value will cause sendfile() to return EINVAL.</p></blockquote><p>意思是，flags是为了后面备用的，现在还没实现，现在传入0即可。</p><p>下面着重解释<code>len</code>与<code>hdtr</code>参数 结构体<code>sf_hdtr</code>, 成员如下</p><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>sf_hdtr</span> {</span>\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> *<span class=hljs-title>headers</span>;</span>  <span class=hljs-comment>/* pointer to header iovecs */</span>\\n    <span class=hljs-keyword>int</span> hdr_cnt;            <span class=hljs-comment>/* number of header iovecs */</span>\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> *<span class=hljs-title>trailers</span>;</span> <span class=hljs-comment>/* pointer to trailer iovecs */</span>\\n    <span class=hljs-keyword>int</span> trl_cnt;            <span class=hljs-comment>/* number of trailer iovecs */</span>\\n};</code></pre><p>而，结构体<code>iovec</code></p><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> {</span>\\n\\t<span class=hljs-keyword>void</span> *   iov_base;\\t<span class=hljs-comment>/* [XSI] Base address of I/O memory region */</span>\\n\\t<span class=hljs-keyword>size_t</span>\\t iov_len;\\t<span class=hljs-comment>/* [XSI] Size of region iov_base points to */</span>\\n};</code></pre><p>可以看到，iovec数据就是表示一段<code>iov_len</code>长度的数据区，而sf_hdtr则是2个<code>iov_len</code>数组(指针)。</p><p><code>headers</code>就是发送文件数据前发送的数据段，<code>trailers</code>则是跟在文件数据EOF之后的。</p><p>解释完该方法后，其实上传文件，只需要调用该方法即可，而<code>headers</code>和<code>trailers</code>可以用来界定文件数据，ngnix osx版本中，便有使用该方法。</p><p>为了简化文件数据划分的逻辑，我未采用，http协议中类似<code>Content-Length</code>字段来表示文件的大小，从而拼接出完整的文件内容，而是简单的在文件数据头尾加上了自定义的字符串。</p><h2 id=代码><a href=#%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码</h2><p><a href=https://github.com/moyuyc/c_cpp-node_c_cpp_addon/tree/master/cpp_src>cpp_src</a></p><ul><li>发送文件</li></ul><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>bool</span> _sendFile(<span class=hljs-keyword>int</span> out_fd, <span class=hljs-keyword>const</span> <span class=hljs-keyword>char</span>* file) {\\n    <span class=hljs-keyword>int</span> fd = open(file, O_RDONLY);\\n    <span class=hljs-keyword>char</span>* tmp = <span class=hljs-built_in>strrchr</span>(file, <span class=hljs-string>'/'</span>);\\n    <span class=hljs-keyword>const</span> <span class=hljs-keyword>char</span>* filename = tmp!=<span class=hljs-literal>NULL</span>? tmp+<span class=hljs-number>1</span>: file;\\n    <span class=hljs-keyword>if</span>(fd==<span class=hljs-number>-1</span>) {\\n        <span class=hljs-keyword>char</span> b[<span class=hljs-number>1024</span>];\\n        <span class=hljs-built_in>sprintf</span>(b, <span class=hljs-string>\\\"open failed %s\\\"</span>, file);\\n        perror(b);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n    }\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>stat</span> <span class=hljs-title>state</span>;</span>\\n    fstat(fd, &ampstate);\\n\\n    <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"sending File %s ...\\\\n\\\"</span>, file);\\n    <span class=hljs-keyword>off_t</span> offset = <span class=hljs-number>0</span>;\\n    <span class=hljs-keyword>off_t</span> len = <span class=hljs-number>0</span>; <span class=hljs-comment>// 必须初始化0, 不然下次重入时，会被旧值覆盖</span>\\n\\n    <span class=hljs-keyword>char</span> head[<span class=hljs-number>1024</span>], sizehd[<span class=hljs-number>1024</span>];\\n    <span class=hljs-built_in>sprintf</span>(head, <span class=hljs-string>\\\"---file: %s\\\\r\\\\n\\\"</span>, filename); <span class=hljs-comment>// 拼装头部字符串</span>\\n<span class=hljs-comment>//    sprintf(sizehd, \\\"---size: %lld\\\\r\\\\n\\\\r\\\\n\\\", state.st_size);</span>\\n\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>sf_hdtr</span> <span class=hljs-title>hdtr</span> = <span class=hljs-title>NULL</span>;</span>\\n    iovec headers = <span class=hljs-literal>NULL</span>, trailers = <span class=hljs-literal>NULL</span>;\\n    headers.iov_base = head;\\n    headers.iov_len = <span class=hljs-built_in>strlen</span>(head);\\n<span class=hljs-comment>//    trailers.iov_base = (void *)\\\"file---\\\\r\\\\n\\\"; //todo: don't recv sometimes ??</span>\\n<span class=hljs-comment>//    trailers.iov_len = 9;</span>\\n    hdtr.headers = &ampheaders;\\n    hdtr.hdr_cnt = <span class=hljs-number>1</span>;\\n    hdtr.trailers = <span class=hljs-literal>NULL</span>;\\n    hdtr.trl_cnt = <span class=hljs-number>0</span>;\\n\\n    <span class=hljs-keyword>if</span>(<span class=hljs-number>0</span> == sendfile(fd, out_fd, offset, &amplen, &amphdtr, <span class=hljs-number>0</span>)) {\\n        close(fd);\\n        write(out_fd, <span class=hljs-string>\\\"file---\\\\r\\\\n\\\"</span>, <span class=hljs-number>9</span>); <span class=hljs-comment>// 未使用trailers，因为有时候上传大文件，trailers会丢失。</span>\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"sendFile %s success, return len: %lld.\\\\n\\\"</span>, file, len);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;\\n    } <span class=hljs-keyword>else</span> {\\n        close(fd);\\n        write(out_fd, <span class=hljs-string>\\\"file---\\\\r\\\\n\\\"</span>, <span class=hljs-number>9</span>);\\n        perror(<span class=hljs-string>\\\"sendfile\\\"</span>);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n    }\\n}</code></pre><ul><li>接收文件</li></ul><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>bool</span> _receFile(FILE* &amppfsile, <span class=hljs-keyword>char</span>* buffer, <span class=hljs-keyword>ssize_t</span> n, <span class=hljs-keyword>bool</span>&amp receiveing, <span class=hljs-keyword>char</span>* rfilename, <span class=hljs-keyword>int</span> size) {\\n    <span class=hljs-keyword>bool</span> run = <span class=hljs-literal>false</span>;\\n    <span class=hljs-keyword>char</span>* last = <span class=hljs-literal>NULL</span>;\\n    <span class=hljs-keyword>if</span>(!receiveing &amp&amp isfileHead(buffer)) {\\n        <span class=hljs-built_in>memset</span>(rfilename, <span class=hljs-number>0</span>, <span class=hljs-number>50</span>);\\n        <span class=hljs-built_in>strcpy</span>(rfilename, <span class=hljs-string>\\\"data/\\\"</span>);\\n        <span class=hljs-keyword>if</span> (stat(rfilename, <span class=hljs-literal>NULL</span>) == <span class=hljs-number>-1</span>) {\\n            mkdir(rfilename, <span class=hljs-number>0700</span>);\\n        }\\n\\n        <span class=hljs-keyword>char</span> name[<span class=hljs-number>40</span>];\\n        <span class=hljs-built_in>sscanf</span>(buffer, <span class=hljs-string>\\\"---file: %s\\\\r\\\\n\\\"</span>, name);\\n        <span class=hljs-keyword>int</span> othlen = <span class=hljs-number>11</span>+<span class=hljs-built_in>strlen</span>(name);\\n        <span class=hljs-keyword>int</span> addonlen = n-othlen;\\n\\n        <span class=hljs-built_in>strcat</span>(rfilename, name);\\n        pfile = fopen(rfilename, <span class=hljs-string>\\\"wb+\\\"</span>); <span class=hljs-comment>//!! 以二进制打开文件</span>\\n\\n        receiveing = <span class=hljs-literal>true</span>;\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"Downloading %s ...\\\\nhead addon: %s\\\\n\\\\n\\\"</span>,\\n               rfilename, buffer+othlen);\\n        <span class=hljs-keyword>if</span>(addonlen > <span class=hljs-number>0</span>) {\\n            fwrite(buffer+othlen, addonlen, <span class=hljs-number>1</span>, pfile);\\n        }\\n        run= <span class=hljs-literal>true</span>;\\n    }\\n    <span class=hljs-keyword>if</span>(receiveing &amp&amp (last = fileTail(buffer, n))!=<span class=hljs-literal>NULL</span>) {\\n        receiveing = <span class=hljs-literal>false</span>;\\n        fwrite(buffer, last-buffer, <span class=hljs-number>1</span>, pfile);\\n        fclose(pfile);\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"Downloaded %s. and saved\\\\n\\\"</span>, rfilename);\\n        run= <span class=hljs-literal>true</span>;\\n    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span>(receiveing &amp&amp !run) {\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"download chunk, size: %ld\\\\n\\\"</span>, n);\\n        <span class=hljs-keyword>if</span>(n&lt;size) {\\n            receiveing = <span class=hljs-literal>false</span>;\\n            fclose(pfile);\\n        }\\n        fwrite(buffer, n, <span class=hljs-number>1</span>, pfile);\\n        run= <span class=hljs-literal>true</span>;\\n    }\\n    <span class=hljs-keyword>return</span> run;\\n}</code></pre><h2 id=最后><a href=#%E6%9C%80%E5%90%8E aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>最后</h2><p>其实还是会有bug的，比如<code>---file: a.png\\\\r\\\\n ... ---file\\\\r\\\\n</code>的数据，接收方buffer设置较小，不能容纳完整的<code>---file</code>标志，可能就不会被认为是file；或者结尾截断了。而对于上诉情况，应用层只能通过更复杂的代码逻辑来控制了。</p>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// linux-c-osx-sendfile.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>今天，来小结一下纠结我几个小时的linux C。需求是这样的，<em>用c实现tcp的文件上传与下载</em></p><p>一开始，很容易想到的上传思路是，直接在内存中开一块<code>buffer</code>，得到一个<code>file description</code>后，进行一读一发。</p><!--more--><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>char</span> buffer[<span class=hljs-number>1024</span>];\\n<span class=hljs-keyword>int</span> fd = open(path, O_RDONLY);\\n<span class=hljs-keyword>int</span> n = read(fd, buffer, <span class=hljs-number>1024</span>);\\n<span class=hljs-keyword>if</span>(n&lt;<span class=hljs-number>0</span>) {\\n    perror(<span class=hljs-string>\\\"read\\\"</span>);\\n}\\nbuffer[n] = <span class=hljs-number>0</span>;\\n\\nwrite(socket, buffer, n);\\n\\n<span class=hljs-comment>//...</span></code></pre><p><strong>然而，其实在linux内核中已经实现了一种更为高效的方法，<code>sendfile</code></strong><br>不需要频繁的调用<code>read/write</code>,也不需要开辟buffer，减少了内核函数的调用，提高性能。</p><h2 id=函数说明><a href=#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>函数说明</h2><ul><li><p>定义</p><pre><code data-query={} data-lang>  int sendfile(int fd, int s, off_t offset, off_t *len, struct sf_hdtr *hdtr, int flags);\\n</code></pre></li><li><p>解释</p></li></ul><table><thead><tr><th>argument name</th><th>explantion</th></tr></thead><tbody><tr><td>fd</td><td>需要发送的文件的fd(file description)</td></tr><tr><td>s</td><td>socket的fd</td></tr><tr><td>offset</td><td>文件从那开始发,NULL表示为0</td></tr><tr><td>len</td><td>输出参数，输出一共发送了多少byte,包括后面的hdtr</td></tr><tr><td>hdtr</td><td>额外发送的头和尾</td></tr><tr><td>flags</td><td>设置为0即可</td></tr></tbody></table><p>关于flags, man page原文如下:</p><blockquote><p>The flags parameter is reserved for future expansion and must be set to 0. Any other value will cause sendfile() to return EINVAL.</p></blockquote><p>意思是，flags是为了后面备用的，现在还没实现，现在传入0即可。</p><p>下面着重解释<code>len</code>与<code>hdtr</code>参数 结构体<code>sf_hdtr</code>, 成员如下</p><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>sf_hdtr</span> {</span>\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> *<span class=hljs-title>headers</span>;</span>  <span class=hljs-comment>/* pointer to header iovecs */</span>\\n    <span class=hljs-keyword>int</span> hdr_cnt;            <span class=hljs-comment>/* number of header iovecs */</span>\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> *<span class=hljs-title>trailers</span>;</span> <span class=hljs-comment>/* pointer to trailer iovecs */</span>\\n    <span class=hljs-keyword>int</span> trl_cnt;            <span class=hljs-comment>/* number of trailer iovecs */</span>\\n};</code></pre><p>而，结构体<code>iovec</code></p><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>iovec</span> {</span>\\n\\t<span class=hljs-keyword>void</span> *   iov_base;\\t<span class=hljs-comment>/* [XSI] Base address of I/O memory region */</span>\\n\\t<span class=hljs-keyword>size_t</span>\\t iov_len;\\t<span class=hljs-comment>/* [XSI] Size of region iov_base points to */</span>\\n};</code></pre><p>可以看到，iovec数据就是表示一段<code>iov_len</code>长度的数据区，而sf_hdtr则是2个<code>iov_len</code>数组(指针)。</p><p><code>headers</code>就是发送文件数据前发送的数据段，<code>trailers</code>则是跟在文件数据EOF之后的。</p><p>解释完该方法后，其实上传文件，只需要调用该方法即可，而<code>headers</code>和<code>trailers</code>可以用来界定文件数据，ngnix osx版本中，便有使用该方法。</p><p>为了简化文件数据划分的逻辑，我未采用，http协议中类似<code>Content-Length</code>字段来表示文件的大小，从而拼接出完整的文件内容，而是简单的在文件数据头尾加上了自定义的字符串。</p><h2 id=代码><a href=#%E4%BB%A3%E7%A0%81 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码</h2><p><a href=https://github.com/moyuyc/c_cpp-node_c_cpp_addon/tree/master/cpp_src>cpp_src</a></p><ul><li>发送文件</li></ul><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>bool</span> _sendFile(<span class=hljs-keyword>int</span> out_fd, <span class=hljs-keyword>const</span> <span class=hljs-keyword>char</span>* file) {\\n    <span class=hljs-keyword>int</span> fd = open(file, O_RDONLY);\\n    <span class=hljs-keyword>char</span>* tmp = <span class=hljs-built_in>strrchr</span>(file, <span class=hljs-string>'/'</span>);\\n    <span class=hljs-keyword>const</span> <span class=hljs-keyword>char</span>* filename = tmp!=<span class=hljs-literal>NULL</span>? tmp+<span class=hljs-number>1</span>: file;\\n    <span class=hljs-keyword>if</span>(fd==<span class=hljs-number>-1</span>) {\\n        <span class=hljs-keyword>char</span> b[<span class=hljs-number>1024</span>];\\n        <span class=hljs-built_in>sprintf</span>(b, <span class=hljs-string>\\\"open failed %s\\\"</span>, file);\\n        perror(b);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n    }\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>stat</span> <span class=hljs-title>state</span>;</span>\\n    fstat(fd, &ampstate);\\n\\n    <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"sending File %s ...\\\\n\\\"</span>, file);\\n    <span class=hljs-keyword>off_t</span> offset = <span class=hljs-number>0</span>;\\n    <span class=hljs-keyword>off_t</span> len = <span class=hljs-number>0</span>; <span class=hljs-comment>// 必须初始化0, 不然下次重入时，会被旧值覆盖</span>\\n\\n    <span class=hljs-keyword>char</span> head[<span class=hljs-number>1024</span>], sizehd[<span class=hljs-number>1024</span>];\\n    <span class=hljs-built_in>sprintf</span>(head, <span class=hljs-string>\\\"---file: %s\\\\r\\\\n\\\"</span>, filename); <span class=hljs-comment>// 拼装头部字符串</span>\\n<span class=hljs-comment>//    sprintf(sizehd, \\\"---size: %lld\\\\r\\\\n\\\\r\\\\n\\\", state.st_size);</span>\\n\\n    <span class=hljs-class><span class=hljs-keyword>struct</span> <span class=hljs-title>sf_hdtr</span> <span class=hljs-title>hdtr</span> = <span class=hljs-title>NULL</span>;</span>\\n    iovec headers = <span class=hljs-literal>NULL</span>, trailers = <span class=hljs-literal>NULL</span>;\\n    headers.iov_base = head;\\n    headers.iov_len = <span class=hljs-built_in>strlen</span>(head);\\n<span class=hljs-comment>//    trailers.iov_base = (void *)\\\"file---\\\\r\\\\n\\\"; //todo: don't recv sometimes ??</span>\\n<span class=hljs-comment>//    trailers.iov_len = 9;</span>\\n    hdtr.headers = &ampheaders;\\n    hdtr.hdr_cnt = <span class=hljs-number>1</span>;\\n    hdtr.trailers = <span class=hljs-literal>NULL</span>;\\n    hdtr.trl_cnt = <span class=hljs-number>0</span>;\\n\\n    <span class=hljs-keyword>if</span>(<span class=hljs-number>0</span> == sendfile(fd, out_fd, offset, &amplen, &amphdtr, <span class=hljs-number>0</span>)) {\\n        close(fd);\\n        write(out_fd, <span class=hljs-string>\\\"file---\\\\r\\\\n\\\"</span>, <span class=hljs-number>9</span>); <span class=hljs-comment>// 未使用trailers，因为有时候上传大文件，trailers会丢失。</span>\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"sendFile %s success, return len: %lld.\\\\n\\\"</span>, file, len);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;\\n    } <span class=hljs-keyword>else</span> {\\n        close(fd);\\n        write(out_fd, <span class=hljs-string>\\\"file---\\\\r\\\\n\\\"</span>, <span class=hljs-number>9</span>);\\n        perror(<span class=hljs-string>\\\"sendfile\\\"</span>);\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n    }\\n}</code></pre><ul><li>接收文件</li></ul><pre><code class=\\\"hljs language-c\\\"data-query={} data-lang=c><span class=hljs-keyword>bool</span> _receFile(FILE* &amppfsile, <span class=hljs-keyword>char</span>* buffer, <span class=hljs-keyword>ssize_t</span> n, <span class=hljs-keyword>bool</span>&amp receiveing, <span class=hljs-keyword>char</span>* rfilename, <span class=hljs-keyword>int</span> size) {\\n    <span class=hljs-keyword>bool</span> run = <span class=hljs-literal>false</span>;\\n    <span class=hljs-keyword>char</span>* last = <span class=hljs-literal>NULL</span>;\\n    <span class=hljs-keyword>if</span>(!receiveing &amp&amp isfileHead(buffer)) {\\n        <span class=hljs-built_in>memset</span>(rfilename, <span class=hljs-number>0</span>, <span class=hljs-number>50</span>);\\n        <span class=hljs-built_in>strcpy</span>(rfilename, <span class=hljs-string>\\\"data/\\\"</span>);\\n        <span class=hljs-keyword>if</span> (stat(rfilename, <span class=hljs-literal>NULL</span>) == <span class=hljs-number>-1</span>) {\\n            mkdir(rfilename, <span class=hljs-number>0700</span>);\\n        }\\n\\n        <span class=hljs-keyword>char</span> name[<span class=hljs-number>40</span>];\\n        <span class=hljs-built_in>sscanf</span>(buffer, <span class=hljs-string>\\\"---file: %s\\\\r\\\\n\\\"</span>, name);\\n        <span class=hljs-keyword>int</span> othlen = <span class=hljs-number>11</span>+<span class=hljs-built_in>strlen</span>(name);\\n        <span class=hljs-keyword>int</span> addonlen = n-othlen;\\n\\n        <span class=hljs-built_in>strcat</span>(rfilename, name);\\n        pfile = fopen(rfilename, <span class=hljs-string>\\\"wb+\\\"</span>); <span class=hljs-comment>//!! 以二进制打开文件</span>\\n\\n        receiveing = <span class=hljs-literal>true</span>;\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"Downloading %s ...\\\\nhead addon: %s\\\\n\\\\n\\\"</span>,\\n               rfilename, buffer+othlen);\\n        <span class=hljs-keyword>if</span>(addonlen > <span class=hljs-number>0</span>) {\\n            fwrite(buffer+othlen, addonlen, <span class=hljs-number>1</span>, pfile);\\n        }\\n        run= <span class=hljs-literal>true</span>;\\n    }\\n    <span class=hljs-keyword>if</span>(receiveing &amp&amp (last = fileTail(buffer, n))!=<span class=hljs-literal>NULL</span>) {\\n        receiveing = <span class=hljs-literal>false</span>;\\n        fwrite(buffer, last-buffer, <span class=hljs-number>1</span>, pfile);\\n        fclose(pfile);\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"Downloaded %s. and saved\\\\n\\\"</span>, rfilename);\\n        run= <span class=hljs-literal>true</span>;\\n    } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span>(receiveing &amp&amp !run) {\\n        <span class=hljs-built_in>printf</span>(<span class=hljs-string>\\\"download chunk, size: %ld\\\\n\\\"</span>, n);\\n        <span class=hljs-keyword>if</span>(n&lt;size) {\\n            receiveing = <span class=hljs-literal>false</span>;\\n            fclose(pfile);\\n        }\\n        fwrite(buffer, n, <span class=hljs-number>1</span>, pfile);\\n        run= <span class=hljs-literal>true</span>;\\n    }\\n    <span class=hljs-keyword>return</span> run;\\n}</code></pre><h2 id=最后><a href=#%E6%9C%80%E5%90%8E aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>最后</h2><p>其实还是会有bug的，比如<code>---file: a.png\\\\r\\\\n ... ---file\\\\r\\\\n</code>的数据，接收方buffer设置较小，不能容纳完整的<code>---file</code>标志，可能就不会被认为是file；或者结尾截断了。而对于上诉情况，应用层只能通过更复杂的代码逻辑来控制了。</p>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/linux-c-osx-sendfile.md\n// module id = 1192\n// module chunks = 72"],"sourceRoot":""}