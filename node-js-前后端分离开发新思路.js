webpackJsonp([55,113],{1209:function(e,s){e.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>从事 Web 开发的程序员，对于前后端分离模式多半不陌生，这也是目前主流的 Web 开发模式，具体关于前后端分离的模式可以参看文章<a href=https://juejin.im/post/5b71302351882560ea4afbb8>《你不得不了解的前后端分离原理! 》</a>，在这里写者不进行说明。</p><p>好了，让我们进入主题 —— Node.js 前后端分离开发新思路\\ 在进入新思路之前，我们现需要了解“老思路”是什么？（注意：后面的案例都是以全栈工程师为例，即前后端代码在一起）</p><h2 id=前后端分离开发常规思路><a href=#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>前后端分离开发常规思路</h2><p>以一种具体情景为例：小牛是一名全栈工程师，喜欢前端后端全干，前端使用目前主流的 Webpack + React 全家桶（或 Vue 全家桶），后端使用 express（或 Koa），小牛在同时开发前后端过程中，开启两个进程（前后端各一个），同时使用 <a href=https://www.npmjs.com/package/nodemon>nodemon</a> 热重启后台服务，使用 Webpack Proxy 转发实现跨域请求，然后哼哧哼哧开发。 如例子：<a href=https://juejin.im/entry/58aa5ccf2f301e006c32a3be>一个前后端分离的简单案例</a></p><pre><code class="hljs language-text"data-query={} data-lang=text> Process 1                Process 2\n ___________          ____________________\n|<span class=hljs-string>           </span>|<span class=hljs-string> Proxy  </span>|<span class=hljs-string>          </span>|<span class=hljs-string>         </span>|\n|<span class=hljs-string> FrontEnd  </span>|<span class=hljs-string> &lt;----> </span>|<span class=hljs-string> Nodemon  </span>|<span class=hljs-string> BackEnd </span>|\n|<span class=hljs-string>           </span>|<span class=hljs-string>        </span>|<span class=hljs-string>          </span>|<span class=hljs-string> (cp 1)  </span>|\n-------------        ----------------------</code></pre><p>如上示意，该模式启动需要启动两个进程（前端 和 Nodemon），其中 BackEnd 程序作为子进程挂载在 Nodemon 进程，而且前端和 Nodemon 进程通过 Proxy 转发实现通信。</p><p>乍看一下这样挺美好的，但是这种模式的缺陷也很容易暴露出来</p><h3 id=传统思路的缺陷><a href=#%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF%E7%9A%84%E7%BC%BA%E9%99%B7 aria-hidden=true><span class="icon icon-link"></span></a>传统思路的缺陷</h3><ol><li>BackEnd 程序复杂度提升后，启动时间也变得不可控，每次热启动后台服务时间过长；</li><li>需要同时开启两个进程，一定程度提高了开发成本</li></ol><p>那么对于上述的问题，需要介绍一下我们今天的主角！</p><h2 id=前后端分离开发新思路><a href=#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%96%B0%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>前后端分离开发新思路</h2><p>依旧是小牛的例子，大牛同样使用小牛相同的前后端技术栈，但不同的是，大牛不使用 Nodemon 实现后端程序的热重启，而是使用类似 <a href=https://webpack.docschina.org/guides/hot-module-replacement/>Webpack HMR（Hot Module Replacement）</a> 的思路，热更新 Node.js 中的 module，具体实现使用 <a href=https://github.com/imcuttle/hot-module-require>hot-module-require</a>。</p><p>原理图如下，前后端在一个进程（同一个端口）中，通过 Fs Watcher 热替换更新的 Module，而不是全量重启。</p><pre><code class="hljs language-text"data-query={} data-lang=text><span class=hljs-code>          Process</span>\n<span class=hljs-code> _________________________</span>\n|          | File Watcher |\n| Frontend |       +      |\n<span class=hljs-section>|          |    Backend   |\n---------------------------</span></code></pre><p>其中核心的 Node.js 端 HMR 实现思路如下</p><h3 id=nodejs-端-hmr-实现思路><a href=#nodejs-%E7%AB%AF-hmr-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>Node.js 端 HMR 实现思路</h3><p>首先我们来看看一个程序的依赖图关系 <img src=https://i.loli.net/2019/06/25/5d1186625830173192.png></p><ol><li>得到程序依赖图<br><code>index.js</code> 为程序入口，可以通过静态代码分析，得到 <code>index.js</code> 的直接依赖 <code>express/index.js</code> 和 <code>lib/middleware.js</code>，然后递归地进行，依次得到一个完整的依赖图，算法具体实现参看 <a href=https://github.com/imcuttle/detect-dep>detect-dep</a>。</li><li>监听依赖图中涉及到的文件<br>需要热更新，那就离不开文件改动的监听，所以进行依赖图中文件的监听（实际上只需要监听本地的文件，排除 node builtin modules 和第三方模块）</li><li><p>某个时候，<code>lib/to-array.js</code> 文件发生改动！</p><ol start=0><li>删除更新模块 A 缓存 (<code>delete require.caches[modulePath]</code>)</li><li>以 A 为入口，更新依赖图</li><li>发出 A 更新的信号</li><li>根据依赖图，得到依赖 A 的模块集合 B</li><li>向上回溯 B，再次从 0. 开始执行<br>其中这一步需要注意环状依赖的处理，需要保证一条依赖路径，不进行重复的依赖更新。 如 <code>lib/to-array.js</code>，存在两条路径：<code>lib/to-array.js -> lib/middleware.js -> index/js</code> 和 <code>lib/to-array.js -> lib/express-utils.js -> lib/middleware.js -> index/js</code></li></ol></li></ol><p>以上算法的具体实现参看 <a href=https://github.com/imcuttle/hot-module-require>hot-module-require</a>， 具体的应用代码可以参看<a href=https://github.com/imcuttle/live-markd/blob/master/client>这里</a></p><p>相比与传统模式，新思路的优点十分突出。</p><h3 id=优势><a href=#%E4%BC%98%E5%8A%BF aria-hidden=true><span class="icon icon-link"></span></a>优势</h3><ol><li>细化 Module 更新的颗粒度，避免不必要的更新开销，大大缩减服务更新时间</li><li>只有一个进程，一定程度上缩减了进程调度，进程切换的开销</li></ol><p>用一个具体的场景对比举例，如后端使用内存存储用户 session 数据。如使用传统方式开发，则每一次更新后台代码，都会丢失内存中的用户数据，所以每次都需要重新进行登录；但是在新方式，只需要不修改用户登录模块代码，则不会重置用户 session 数据，即不需重新登录。</p><pre><code data-query={} data-lang>      Backend 入口\n  /                \\\n -                   -\n登录 --> Common &lt;-- 某业务逻辑\n</code></pre><p>如上简易模块依赖图，A -> B 表示 A 依赖 B，所以上图中，Backend 入口直接依赖 “登录”和“某业务逻辑”，间接依赖“Common”；这时候我们只有在修改了“登录”或“Common”的代码，才会触发登录模块的热更新。</p><p>但是新方法也不是无缺陷</p><h3 id=缺陷><a href=#%E7%BC%BA%E9%99%B7 aria-hidden=true><span class="icon icon-link"></span></a>缺陷</h3><ol><li>如代码模块中包含全局副作用代码，可能会有各种奇怪问题出现</li></ol><h2 id=扩展><a href=#%E6%89%A9%E5%B1%95 aria-hidden=true><span class="icon icon-link"></span></a>扩展</h2><p>使用 Node.js HMR 可以实现各种各样的热更新体验，如热更新 proxy，热更新 mock 数据，热更新配置文件...，非常 Cool！</p><h2 id=相关材料><a href=#%E7%9B%B8%E5%85%B3%E6%9D%90%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>相关材料</h2><ul><li><a href=https://github.com/imcuttle/detect-dep>静态依赖分析</a></li><li><a href=https://github.com/imcuttle/hot-module-require>Node.js HMR 实现</a></li><li><a href=https://github.com/imcuttle/live-markd/blob/master/client>Node.js HMR 在开发环境中的使用</a></li><li><a href=https://nodejs.org/api/modules.html#modules_cycles>Node.js 环状依赖</a></li></ul>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=node-js-前后端分离开发新思路.js.map