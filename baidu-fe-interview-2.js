webpackJsonp([105,113],{1158:function(s,a){s.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id=前言><a href=#%E5%89%8D%E8%A8%80 aria-hidden=true><span class="icon icon-link"></span></a>前言</h1><p>昨天，进行了百度第二次前端面试，结果今天中午就通知我过了，准备本周五进行三面，百度的办事效率还挺高的哈。 写这篇文章为了记录和总结一下，已经回顾自己的不足，以及展望下后面的计划。</p><!--more--><h1 id=开始前夕><a href=#%E5%BC%80%E5%A7%8B%E5%89%8D%E5%A4%95 aria-hidden=true><span class="icon icon-link"></span></a>开始前夕</h1><p>我听取了一面面试官的建议，花了一周时间捣鼓了一个静态博客，所以我就在简历上加上了我的博客地址，然后发了一份新的简历给二面面试官。 二面面试官比一面面试官「活跃」些，互动也多了些。</p><h1 id=视频开始><a href=#%E8%A7%86%E9%A2%91%E5%BC%80%E5%A7%8B aria-hidden=true><span class="icon icon-link"></span></a>视频开始</h1><p>中午二点，正式开始视频面试，出乎我意料之外的是，面试官居然也露出了庐山真面目。 一开始面试官就吐英语了！听得我一愣一愣的（可能在文字聊天的时候我一直有发okok，让面试官误以为我英语不错），还好没听明白的地方，面试官会翻译。 简单做了一下自我介绍后，面试官便进入了自己的节奏，说明这次面试主要是测试我的编码能力，需要共享我的电脑桌面，看我敲代码。 当时内心还是有点慌的，「怎么跟网上的二面面经不太一样啊！」，于是便开始了出题编码环节。</p><h1 id=第一题><a href=#%E7%AC%AC%E4%B8%80%E9%A2%98 aria-hidden=true><span class="icon icon-link"></span></a>第一题</h1><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-comment>/*\n 用 javascript 语言,手工实现 repeat 函数.两个参数:\n 1.要重复的原始字符串\n 2.需要重复的次数\n\n 例如:\n repeat (\'a\', 3) => \'aaa\'\n\n */</span>\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>repeat</span> (<span class=hljs-params>str, count</span>) </span>{\n    <span class=hljs-comment>// your code here</span>\n}</code></pre><p>恩恩，第一题不难，头脑中首先冒出两种方法</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>repeat</span> (<span class=hljs-params>str, count</span>) </span>{\n    <span class=hljs-keyword>if</span>(str != <span class=hljs-literal>undefined</span> &amp&amp count!= <span class=hljs-literal>undefined</span> &amp&amp count><span class=hljs-number>0</span> &amp&amp !<span class=hljs-built_in>isNaN</span>(count)) {\n        <span class=hljs-comment>// 1</span>\n        <span class=hljs-keyword>var</span> s =<span class=hljs-string>\'\'</span>;\n        <span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i=<span class=hljs-number>0</span>;i&lt;count;i++){\n            s+=str;\n        }\n        <span class=hljs-keyword>return</span> s;\n\n        <span class=hljs-comment>//2</span>\n        <span class=hljs-keyword>var</span> arr = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Array</span>(count + <span class=hljs-number>1</span>);\n        <span class=hljs-keyword>return</span> arr.join(str);\n    }\n}</code></pre><p>但是，面试官肯定要深问啊，要求我用递归来实现。 当时比较紧张...,思路不是很清晰...,有点乱。 开始是用下面的递归方法：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>repeat</span>(<span class=hljs-params>str ,count</span>) </span>{\n    <span class=hljs-keyword>var</span> s = <span class=hljs-string>\'\'</span>;\n    rep(str,count);\n    <span class=hljs-keyword>return</span> s;\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>rep</span>(<span class=hljs-params>str,count</span>) </span>{\n        <span class=hljs-keyword>if</span>(count&lt;=<span class=hljs-number>0</span>) <span class=hljs-keyword>return</span>;\n        s+=str;\n        <span class=hljs-built_in>arguments</span>.callee(str,--count);\n    }\n}</code></pre><p>面试官还是不满意！让我改进，不用"全局变量" <code>s</code>，于是修改代码为下：</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>repeat</span>(<span class=hljs-params>str ,count</span>) </span>{\n    <span class=hljs-keyword>return</span> rep(<span class=hljs-string>\'\'</span>,str,count);\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>rep</span>(<span class=hljs-params>s,str,count</span>) </span>{\n        <span class=hljs-keyword>if</span>(count&lt;=<span class=hljs-number>0</span>) <span class=hljs-keyword>return</span> str;\n        s+=str;\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>arguments</span>.callee(s,str,--count);\n    }\n}</code></pre><h1 id=第二题><a href=#%E7%AC%AC%E4%BA%8C%E9%A2%98 aria-hidden=true><span class="icon icon-link"></span></a>第二题</h1><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-comment>/*\n 使用 原生javacript 实现事件代理\n\n 例子:\n\n delegate (  containerElement, \'click\', \'remove-item\', onClick )\n 会绑定一个事件代理到 containerElement 这个元素, 即是说, 所有在 containerElement 这个容器下的所有 .remove-item 在click事件出现时都会触发 onClick 这个回调\n\n */</span>\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>delegate</span>(<span class=hljs-params>parentElem, eventType, className, callback</span>) </span>{\n\n}</code></pre><p>第二题也是比较常规的事件委托题目，想了一会儿，还好是想出来了。</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>delegate</span>(<span class=hljs-params>parentElem, eventType, className, callback</span>) </span>{\n    <span class=hljs-keyword>if</span>(parentElem.attachEvent)\n        parentElem.attachEvent(<span class=hljs-string>\'on\'</span>+eventType,<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\n            <span class=hljs-keyword>if</span>(e.srcElement.classList.contains(className)){\n                callback(e);\n            }\n        });\n    <span class=hljs-keyword>else</span>{\n        parentElem.addEventListener(eventType,<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\n            <span class=hljs-keyword>if</span>(e.target.classList.contains(className)){\n                callback(e);\n            }\n        });\n    }\n}</code></pre><p>写完后，面试官继续问：有没有方法可以让事件响应更快速点。 额，想了一分钟吧，面试官看我没声音，就直接到第三题了。`</p><pre><code data-query={} data-lang>其实，后面仔细想了下，觉得可以将`addEventListener`方法中的第三个参数设置为`true`，也就是按照事件捕获方式响应，\nDOM事件流首先要捕获事件（由父结点到子节点），然后是事件冒泡（由子节点到父结点）。\n`addEventListener`方法第三个参数默认为`false`，表示事件冒泡处理事件，所以我觉得设置为`true`，应该能够更快的响应事件。\n</code></pre><h1 id=第三题><a href=#%E7%AC%AC%E4%B8%89%E9%A2%98 aria-hidden=true><span class="icon icon-link"></span></a>第三题</h1><p>开放题，考察我学习新知识的能力和方法，让我做出一个跟React中第三个Demo一样的效果（使用React）。 <a href=http://facebook.github.io/react/>http://facebook.github.io/react/</a> ...当时我已经是比较懵逼了，就查看源码呗，看下官网上实现这个Demo的源码在哪，然后导入库文件，复制代码试试看咯。 但是当时突然就网络不好了，github上不去了，结果面试官还主动帮我下库文件，600多KB，结果发给我的数据居然是1KB/s，所以最后这道题不了了之。 时间差不多了，就结束了。</p><h1 id=总结><a href=#%E6%80%BB%E7%BB%93 aria-hidden=true><span class="icon icon-link"></span></a>总结</h1><p>最后我才知道一共有四道题目（恩，第四题也不知道是个什么东西）。 从腾讯一面被刷到百度的二面通过，等待三面，真是验证了一句话「机会是留给有准备的人的。」 还有，<strong>紧张只会给自己添乱子！</strong> 最后我希望三面也能顺风顺水吧。 如果拿到实习offer后，希望在实习的时候也能拿出以往的「折腾、捣鼓」精神，能够顺利转正。</p>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=baidu-fe-interview-2.js.map