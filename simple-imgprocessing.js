webpackJsonp([20,90],{1043:function(n,a){n.exports={content:'<h1 id="引言"><a href="#%E5%BC%95%E8%A8%80" aria-hidden="true"><span class="icon icon-link"></span></a>引言</h1>\n<p> 这个学期，我学习了图像处理的相关课程，对图像有了初步的认识，并且利用web知识，做了相关实践。<br>\n在线地址：<a href="http://moyuyc.github.io/htm/painter/">moyuyc.github.io/htm/painter/</a><br>\n<strong>姓名：余聪</strong><br><strong>学号：19130126</strong></p>\n<!--more-->\n<h1 id="实现技术说明"><a href="#%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E" aria-hidden="true"><span class="icon icon-link"></span></a>实现技术说明</h1>\n<p> 使用了前端HTML5 canvas API 以及后端Java Web搭建的后台服务。<br>\n也就是说，<strong>图像处理功能既有使用JavaScript语言实现的，也有利用Java语言实现的，但是都将以网页形式展现</strong><br>\n具体技术说明如下图所示。\n<img src="http://obu9je6ng.bkt.clouddn.com/FtExOgf-UTKT19vx6mmqWfBdqn_h?imageslim" alt="ClipboardImage" width="1102" height="422" /></p>\n<h1 id="使用说明"><a href="#%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" aria-hidden="true"><span class="icon icon-link"></span></a>使用说明</h1>\n<ol>\n<li>Image Choose\n<img src="http://obu9je6ng.bkt.clouddn.com/FtJDetUzRzzIBewtLi0y718y0_oH?imageslim" alt="ClipboardImage" width="1185" height="824" /></li>\n<li>点击白色面板，选择图像起点\n<img src="http://obu9je6ng.bkt.clouddn.com/FiHHgSEUm-t3GsBzEz7i5wIaTLwu?imageslim" alt="ClipboardImage" width="1626" height="879" />\n右侧Message出现该图片灰度分布情况</li>\n<li>操作面板解释\n<img src="http://obu9je6ng.bkt.clouddn.com/Fgmb7FlStUCyQzc6RoYRWPYaO8gn?imageslim" alt="ClipboardImage" width="1162" height="236" /></li>\n<li>注意\n<strong>对于Server操作，由于需要将图像传输给服务器，所以对于图像大小有要求，请使用下面的图片(较小)进行测试</strong>\n<img src="http://obu9je6ng.bkt.clouddn.com/FuZpYAjB3V5XaFc-tKjpG0T2vzZR?imageslim" alt="ClipboardImage" width="256" height="256" /></li>\n</ol>\n<h1 id="功能介绍"><a href="#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span class="icon icon-link"></span></a>功能介绍</h1>\n<h2 id="设置图像透明度直接像素点操作"><a href="#%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%83%8F%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9B%B4%E6%8E%A5%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="icon icon-link"></span></a>设置图像透明度(直接像素点操作)</h2>\n<ul>\n<li>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FiXgk80RJjYyPQe7ANO4uhAA-mTL?imageslim" alt="ClipboardImage" width="533" height="263" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">alphaHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    setImageAlpha = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index,alph</span>)</span>{\n        <span class="hljs-keyword">if</span>(paint.images &#x26;&#x26; paint.images.length>index ) {\n            <span class="hljs-keyword">var</span> image = paint.images[index],\n                img = paint.getImageData(image.x,image.y,image.width,image.height);\n            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&#x3C;img.data.length;i+=<span class="hljs-number">4</span>){\n                <span class="hljs-comment">// 设置alph</span>\n                img.data[i+<span class="hljs-number">3</span>] = alph;\n            }\n            paint.save();\n            paint.putImageData(img,image.x,image.y);\n            paint.restore();\n        }\n    };\n    <span class="hljs-keyword">var</span> alph;\n    <span class="hljs-keyword">while</span>((alph=<span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">\'please set images alpha. (0~255)\'</span>,<span class="hljs-number">120</span>)))><span class="hljs-number">255</span> || alph&#x3C;<span class="hljs-number">0</span>);\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&#x3C;paint.images.length;i++)\n        setImageAlpha(i,alph);\n};</code></pre>\n</li>\n</ul>\n<h2 id="图像灰化直接像素点操作"><a href="#%E5%9B%BE%E5%83%8F%E7%81%B0%E5%8C%96%E7%9B%B4%E6%8E%A5%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="icon icon-link"></span></a>图像灰化(直接像素点操作)</h2>\n<ul>\n<li>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FvwSNwQGsLpUjptBT1NKs6IMq1Cc?imageslim" alt="ClipboardImage" width="540" height="265" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">imgGrayHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    paint.images.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ele</span>) </span>{\n        <span class="hljs-keyword">var</span> imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&#x3C;imgData.data.length;i+=<span class="hljs-number">4</span>) {\n            <span class="hljs-keyword">var</span> r = imgData.data[i],g=imgData.data[i+<span class="hljs-number">1</span>],b = imgData.data[i+<span class="hljs-number">2</span>];\n            <span class="hljs-keyword">var</span> value = (r+g+b)/<span class="hljs-number">3</span>; <span class="hljs-comment">//rgb平均值->灰度</span>\n            imgData.data[i]=imgData.data[i+<span class="hljs-number">1</span>]=imgData.data[i+<span class="hljs-number">2</span>]=value;\n        }\n        paint.putImageData(imgData,ele.x,ele.y);\n    })\n};</code></pre>\n</li>\n</ul>\n<h2 id="高对比度直接像素点操作"><a href="#%E9%AB%98%E5%AF%B9%E6%AF%94%E5%BA%A6%E7%9B%B4%E6%8E%A5%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="icon icon-link"></span></a>高对比度(直接像素点操作)</h2>\n<ul>\n<li>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/Fq4fUyU60zSFY3EIEnx_WtlDD2EY?imageslim" alt="ClipboardImage" width="558" height="258" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">hgHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    paint.images.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ele</span>) </span>{\n        <span class="hljs-keyword">var</span> imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&#x3C;imgData.data.length;i+=<span class="hljs-number">4</span>) {\n            <span class="hljs-comment">// 取背景色的反作为前景色</span>\n            imgData.data[i] = <span class="hljs-number">255</span>-imgData.data[i];\n            imgData.data[i+<span class="hljs-number">1</span>] = <span class="hljs-number">255</span>-imgData.data[i+<span class="hljs-number">1</span>];\n            imgData.data[i+<span class="hljs-number">2</span>] = <span class="hljs-number">255</span>-imgData.data[i+<span class="hljs-number">2</span>];\n        }\n        paint.putImageData(imgData,ele.x,ele.y);\n    })\n};</code></pre>\n</li>\n</ul>\n<h2 id="浮雕效果锐化滤波器"><a href="#%E6%B5%AE%E9%9B%95%E6%95%88%E6%9E%9C%E9%94%90%E5%8C%96%E6%BB%A4%E6%B3%A2%E5%99%A8" aria-hidden="true"><span class="icon icon-link"></span></a>浮雕效果(锐化滤波器)</h2>\n<ul>\n<li>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FkmvcJ6520vsm6HomvGwCWQbUsZf?imageslim" alt="ClipboardImage" width="539" height="261" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ConvolutionMatrix</span>(<span class="hljs-params">input, matrix, divisor, offset</span>) </span>{\n    <span class="hljs-comment">// 创建一个输出的 imageData 对象</span>\n    <span class="hljs-keyword">var</span> output = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"canvas"</span>)\n        .getContext(<span class="hljs-string">\'2d\'</span>).createImageData(input);\n    <span class="hljs-keyword">var</span> w = input.width, h = input.height;\n    <span class="hljs-keyword">var</span> iD = input.data, oD = output.data;\n    <span class="hljs-keyword">var</span> m = matrix;\n    <span class="hljs-comment">// 对除了边缘的点之外的内部点的 RGB 进行操作，透明度在最后都设为 255</span>\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> y = <span class="hljs-number">1</span>; y &#x3C; h - <span class="hljs-number">1</span>; y += <span class="hljs-number">1</span>) {\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; x &#x3C; w - <span class="hljs-number">1</span>; x += <span class="hljs-number">1</span>) {\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>; c &#x3C; <span class="hljs-number">3</span>; c += <span class="hljs-number">1</span>) {\n                <span class="hljs-keyword">var</span> i = (y * w + x) * <span class="hljs-number">4</span> + c;\n                oD[i] = offset\n                    + (m[<span class="hljs-number">0</span>] * iD[i - w * <span class="hljs-number">4</span> - <span class="hljs-number">4</span>] + m[<span class="hljs-number">1</span>] * iD[i - w * <span class="hljs-number">4</span>] + m[<span class="hljs-number">2</span>] * iD[i - w * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>]\n                    + m[<span class="hljs-number">3</span>] * iD[i - <span class="hljs-number">4</span>] + m[<span class="hljs-number">4</span>] * iD[i] + m[<span class="hljs-number">5</span>] * iD[i + <span class="hljs-number">4</span>]\n                    + m[<span class="hljs-number">6</span>] * iD[i + w * <span class="hljs-number">4</span> - <span class="hljs-number">4</span>] + m[<span class="hljs-number">7</span>] * iD[i + w * <span class="hljs-number">4</span>] + m[<span class="hljs-number">8</span>] * iD[i + w * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>])\n                    / divisor;\n                oD[(y * w + x) * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>; <span class="hljs-comment">// 设置透明度</span>\n            }\n        }\n    }\n    <span class="hljs-keyword">return</span> output;\n};</code></pre>\n</li>\n</ul>\n<h2 id="图像黑化直接像素点操作"><a href="#%E5%9B%BE%E5%83%8F%E9%BB%91%E5%8C%96%E7%9B%B4%E6%8E%A5%E5%83%8F%E7%B4%A0%E7%82%B9%E6%93%8D%E4%BD%9C" aria-hidden="true"><span class="icon icon-link"></span></a>图像黑化(直接像素点操作)</h2>\n<ul>\n<li>如图\n<img src="/images/imgpro5.png" alt="imgpro5.png" width="546" height="266" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">blackHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{\n    paint.images.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ele</span>) </span>{\n        <span class="hljs-keyword">var</span> imgData = paint.getImageData(ele.x,ele.y,ele.width,ele.height);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&#x3C;imgData.data.length;i+=<span class="hljs-number">4</span>) {\n            <span class="hljs-keyword">var</span> r = imgData.data[i],g=imgData.data[i+<span class="hljs-number">1</span>],b = imgData.data[i+<span class="hljs-number">2</span>];\n            <span class="hljs-keyword">var</span> grey = r*<span class="hljs-number">0.3</span>+g*<span class="hljs-number">0.59</span>+b*<span class="hljs-number">0.11</span>;\n            <span class="hljs-comment">// 取0或者255,非黑即白</span>\n            imgData.data[i] = imgData.data[i+<span class="hljs-number">1</span>] = imgData.data[i+<span class="hljs-number">2</span>] = grey><span class="hljs-number">125</span> ? <span class="hljs-number">255</span> : <span class="hljs-number">0</span>;\n        }\n        paint.putImageData(imgData,ele.x,ele.y);\n    })\n}</code></pre>\n</li>\n</ul>\n<h2 id="模糊效果线性平滑滤波器"><a href="#%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%E7%BA%BF%E6%80%A7%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2%E5%99%A8" aria-hidden="true"><span class="icon icon-link"></span></a>模糊效果(线性平滑滤波器)</h2>\n<ul>\n<li>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/Fo05MIaOVxYft3uLkjZw7rgIgaVp?imageslim" alt="ClipboardImage" width="542" height="252" /><img src="http://obu9je6ng.bkt.clouddn.com/FuhpGHFjE7Pzd5qZdrQZyI8YY9NL?imageslim" alt="ClipboardImage" width="546" height="266" /></li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">blurHandle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{\n    paint.images.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ele</span>) </span>{\n        <span class="hljs-keyword">var</span> imgData = paint.getImageData(ele.x, ele.y, ele.width, ele.height);\n        <span class="hljs-keyword">var</span> blurR = <span class="hljs-number">3</span>, totalnum = (<span class="hljs-number">2</span> * blurR + <span class="hljs-number">1</span>) * (<span class="hljs-number">2</span> * blurR + <span class="hljs-number">1</span>);\n        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = blurR; i &#x3C; ele.height - blurR; i++)\n            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = blurR; j &#x3C; ele.width - blurR; j++) {\n                <span class="hljs-keyword">var</span> totalr = <span class="hljs-number">0</span>, totalg = <span class="hljs-number">0</span>, totalb = <span class="hljs-number">0</span>;\n                <span class="hljs-comment">//2*blurR 模糊的正方形长宽，total 范围内RGB的总和</span>\n                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> dx = -blurR; dx &#x3C;= blurR; dx++)\n                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> dy = -blurR; dy &#x3C;= blurR; dy++) {\n                        <span class="hljs-keyword">var</span> x = i + dx\n                        <span class="hljs-keyword">var</span> y = j + dy\n                        <span class="hljs-keyword">var</span> p = (x * ele.width + y)*<span class="hljs-number">4</span>;\n                        totalr += imgData.data[p + <span class="hljs-number">0</span>]\n                        totalg += imgData.data[p + <span class="hljs-number">1</span>]\n                        totalb += imgData.data[p + <span class="hljs-number">2</span>]\n                    }\n                <span class="hljs-keyword">var</span> p = (i*ele.width + j)*<span class="hljs-number">4</span>;\n                imgData.data[p+<span class="hljs-number">0</span>] = totalr / totalnum;\n                imgData.data[p+<span class="hljs-number">1</span>] = totalg / totalnum;\n                imgData.data[p+<span class="hljs-number">2</span>] = totalb / totalnum;\n            }\n        paint.putImageData(imgData,ele.x,ele.y);\n    });\n};</code></pre>\n</li>\n</ul>\n<h2 id="马赛克效果平滑滤波器"><a href="#%E9%A9%AC%E8%B5%9B%E5%85%8B%E6%95%88%E6%9E%9C%E5%B9%B3%E6%BB%91%E6%BB%A4%E6%B3%A2%E5%99%A8" aria-hidden="true"><span class="icon icon-link"></span></a>马赛克效果(平滑滤波器)</h2>\n<ul>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FmhxBd8me8P8_Czqeh3BaPxnudM5?imageslim" alt="ClipboardImage" width="541" height="260" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code data-query="{}" data-lang="">```javascript\nmosaicHandle = function (){\n    paint.images.forEach(function (ele) {\n        var imgData = paint.getImageData(ele.x, ele.y, ele.width, ele.height);\n        var size = 16\n        var totalnum = size*size;\n        for( var i = 0 ; i &#x3C; ele.height ; i += size )\n            for( var j = 0 ; j &#x3C; ele.width ; j += size ){\n                var totalr = 0 , totalg = 0 , totalb = 0\n                //以size为大小作为一个像素方格\n                for( var dx = 0 ; dx &#x3C; size ; dx ++ )\n                    for( var dy = 0 ; dy &#x3C; size ; dy ++ ){\n                        var x = i + dx;\n                        var y = j + dy;\n                        var p = x*ele.width + y\n                        totalr += imgData.data[p*4+0]\n                        totalg += imgData.data[p*4+1]\n                        totalb += imgData.data[p*4+2]\n                    }\n                var p = i*ele.width+j\n                var resr = totalr / totalnum\n                var resg = totalg / totalnum\n                var resb = totalb / totalnum;\n                //将size大小内的像素点全部设为平均rgb\n                for( var dx = 0 ; dx &#x3C; size ; dx ++ )\n                    for( var dy = 0 ; dy &#x3C; size ; dy ++ ){\n                        var x = i + dx\n                        var y = j + dy\n                        var p = x*ele.width + y\n                        imgData.data[p*4+0] = resr\n                        imgData.data[p*4+1] = resg\n                        imgData.data[p*4+2] = resb\n                    }\n            }\n        paint.putImageData(imgData,ele.x,ele.y);\n    })\n}\n```\n</code></pre>\n<h2 id="kmenus算法矢量量化"><a href="#kmenus%E7%AE%97%E6%B3%95%E7%9F%A2%E9%87%8F%E9%87%8F%E5%8C%96" aria-hidden="true"><span class="icon icon-link"></span></a>KMenus算法(矢量量化)</h2>\n</li>\n<li>\n<p>说明：KMenus算法是一个聚类算法，我们可以用该算法思想，找出图像中主要的rgb颜色。（可以将rgb想象为三维空间xyz，找出图像中rgb聚集的地方）然后把属于该聚类中的所有像素点全部赋值为聚类像素值，查看效果</p>\n</li>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FlxYpIXzpNyQE68RFGZuyxwWYfTM?imageslim" alt="ClipboardImage" width="547" height="324" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code data-query="{}" data-lang="">```javascript\nkMeans : function(imgData){\n        var data = imgData.data, w = imgData.width, h = imgData.height;\n        var clusters = (function getRandomClusters(k){\n            var rlt = [];\n            while(k-->0)\n                rlt.push([randomInt(256),randomInt(256),randomInt(256)]);\n            return rlt;\n        })(3);\n        function getRGBDistance(clu,rgb){\n            return parseInt(Math.sqrt(Math.pow(rgb[0]-clu[0],2)+Math.pow(rgb[1]-clu[1],2),Math.pow(rgb[2]-clu[2],2)).toFixed(0));\n        }\n        function getCenterCluster(rgbs){\n            var sumr= 0,sumg= 0,sumb=0;\n            for(var i in rgbs){\n                sumr+=rgbs[i][0];sumg+=rgbs[i][1];sumb+=rgbs[i][2];\n            }\n            return [parseInt((sumr/rgbs.length).toFixed(0)),\n                parseInt((sumg/rgbs.length).toFixed(0)),\n                parseInt((sumb/rgbs.length).toFixed(0))]\n        }\n        var forNewClus = new Array(clusters.length),forNewData = new Array(clusters.length);\n        while(true) {\n            for(var i=0;i&#x3C;forNewClus.length;i++) {\n                forNewClus[i] = [];\n                forNewData[i] = [];\n            }\n            for (var i = 0; i &#x3C; data.length; i += 4) {\n                var myCluIndex, minDist = Number.MAX_VALUE, rgb = [data[i], data[i + 1], data[i + 2]];\n                for (var j = 0; j &#x3C; clusters.length; j++) {\n                    var dist = getRGBDistance(clusters[j], rgb);\n                    if (dist &#x3C; minDist) {\n                        myCluIndex = j;\n                        minDist = dist;\n                    }\n                }\n                forNewData[myCluIndex].push(i);\n                forNewClus[myCluIndex].push(rgb);\n            }\n            var isUpdate=false;\n            for(var i=0;i&#x3C;forNewClus.length;i++) {\n                if(forNewClus[i].length==0)\n                    continue;\n                var c = getCenterCluster(forNewClus[i]);\n                if(c[0]!=clusters[i][0]||c[1]!=clusters[i][1]||c[2]!=clusters[i][2]) {\n                    clusters[i] = c;\n                    isUpdate = true;\n                }\n            }\n            if(!isUpdate)\n                break;\n        }\n        for(var i=0;i&#x3C;forNewData.length;i++) {\n            for(var j=0;j&#x3C;forNewClus[i].length;j++){\n                var val = forNewData[i][j];\n                data[val] = clusters[i][0];\n                data[val+1] = clusters[i][1];\n                data[val+2] = clusters[i][1];\n            }\n        }\n        console.log(forNewClus,clusters);\n        return {c:clusters,md:imgData};\n    }\n```\n</code></pre>\n<h2 id="直方图均衡化空域点处理"><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E7%A9%BA%E5%9F%9F%E7%82%B9%E5%A4%84%E7%90%86" aria-hidden="true"><span class="icon icon-link"></span></a>直方图均衡化(空域点处理)</h2>\n</li>\n<li>\n<p>说明：直方图均衡化：我们把一张图片对应的rgb像素点分成3个(对应rgb)256(0-255)等级，并且将等级绘制为直方图，我们把直方图变得分布均匀，这就是直方图均衡化。这样的图片往往具有高对比度。</p>\n</li>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FmwuGT6aQQupiOOGufUTs2qO4dsH?imageslim" alt="ClipboardImage" width="537" height="261" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code data-query="{}" data-lang="">```javascript\n//http://blog.csdn.net/jia20003/article/details/8119563\n//http://hello-wangfeng.iteye.com/blog/1717150\naverage: function (imgData) {\n    var data = imgData.data, w = imgData.width, h = imgData.height;\n    var histogramR = [],\n        histogramG = [],\n        histogramB = [];\n    for(var i=0; i&#x3C;data.length; i+=4){\n        histogramR[data[i]] = histogramR[data[i]]+1 || 1;\n        histogramG[data[i+1]] = histogramG[data[i+1]]+1 || 1;\n        histogramB[data[i+2]] = histogramB[data[i+2]]+1 || 1;\n    }\n    //直方图均衡化\n    function getRate(grayHis,total,index) {\n        var s = 0;\n        for(var i=0;i&#x3C;index;i++){\n            var v = grayHis[i]||0;\n            s+=(v/total);\n        }\n        return Math.floor(s*255);\n    }\n    var total = w*h,\n        newHisR = [],\n        newHisG = [],\n        newHisB = [];\n    for(i=0; i&#x3C;256; i++){\n        newHisR[i] = getRate(histogramR,total,i);\n        newHisG[i] = getRate(histogramG,total,i);\n        newHisB[i] = getRate(histogramB,total,i);\n    }\n    console.log([histogramR,histogramG,histogramB],[newHisR,newHisG,newHisB]);\n    for(i=0; i&#x3C;h; i++){\n        for(var j=0; j&#x3C;w; j++){\n            var v = (i*w+j)&#x3C;&#x3C;2;\n            data[v] = newHisR[data[v]];\n            data[v+1]=newHisG[data[v+1]];\n            data[v+1]=newHisB[data[v+2]];\n        }\n    }\n    return imgData;\n}\n```\n</code></pre>\n<h2 id="图像复原"><a href="#%E5%9B%BE%E5%83%8F%E5%A4%8D%E5%8E%9F" aria-hidden="true"><span class="icon icon-link"></span></a>图像复原</h2>\n</li>\n<li>\n<p>说明：图像在形成、记录、处理和传输过程中，由于成像系统、记录设备、传输介质和处理方法的问题，导致图像质量下降，这种现象叫图像退化。而图像复原就是对退化的图像进行处理，尽可能的复原图像的本来面目。</p>\n</li>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FkLD1OdGi0WKdv26sK4ubCj3ov6B?imageslim" alt="ClipboardImage" width="530" height="330" />\n<img src="http://obu9je6ng.bkt.clouddn.com/FqQpRZv_Tzx54uHAREg7O9UPY8r3?imageslim" alt="ClipboardImage" width="530" height="330" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code data-query="{}" data-lang="">```java\n//图像恢复\npublic int[] imRestore(int[] pixels, int iw, int ih)\n{\n    double[] newPixels = new double [iw*ih];\n    double[] newKernel = new double [iw*ih];\n\n    //初始化\n    for(int j = 0; j &#x3C; ih; j++)\n    {\n        for(int i = 0; i &#x3C; iw; i++)\n        {\n            newPixels[i+j*iw] = pixels[i+j*iw]&#x26;0xff;\n            if((i&#x3C;5) &#x26;&#x26; (j&#x3C;5))\n                newKernel[i+j*iw] = 1.0/25;\n            else\n                newKernel[i+j*iw] = 0;\n        }\n    }\n\n    //初始化\n    Complex[] complex   = new Complex[iw*ih];\n    Complex[] comKernel = new Complex[iw*ih];\n    for(int i = 0;i &#x3C; iw*ih; i++)\n    {\n        complex[i]   = new Complex(0,0);\n        comKernel[i] = new Complex(0,0);\n    }\n\n    //对原图像进行FFT (快速傅氏变换)\n    fft2 = new FFT2();\n    fft2.setData2(iw, ih, newPixels);\n    complex = fft2.getFFT2();\n\n    //对卷积核进行FFT\n    fft2 = new FFT2();\n    fft2.setData2(iw, ih, newKernel);\n    comKernel = fft2.getFFT2();\n\n    //逆滤波复原\n    for(int j = 0;j &#x3C; ih; j++)\n    {\n        for(int i = 0; i &#x3C; iw; i++)\n        {\n            double re = complex[i+j*iw].re;\n            double im = complex[i+j*iw].im;\n            double reKernel = comKernel[i+j*iw].re;\n            double imKernel = comKernel[i+j*iw].im;\n            double x = reKernel*reKernel+imKernel*imKernel;\n\n            if(x > 1e-3)\n            {\n                double r = (re*reKernel+im*imKernel)/x;\n                double m = (im*reKernel-re*imKernel)/x;\n                complex[i+j*iw].re = r;\n                complex[i+j*iw].im = m;\n            }\n        }\n    }\n\n    //进行FFT反变换\n    fft2 = new FFT2();\n    fft2.setData2i(iw, ih, complex);\n    pixels = fft2.getPixels2i();\n    return pixels;\n}\n```\n</code></pre>\n<h2 id="边界检测自定义方法"><a href="#%E8%BE%B9%E7%95%8C%E6%A3%80%E6%B5%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a>边界检测(自定义方法)</h2>\n</li>\n<li>\n<p>说明：人们看一个物体是，首先感受的就是它的边缘，灰度或结构等信息的突变处称为边缘。边缘是一个区域的结束，也是另一个区域的开始，利用这种特征可以分割图像。\n物体边缘上的这种变化可以用微分算子检测出来，通常用一阶或二阶导数来检测边缘。</p>\n</li>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/FtX_UjvlyHv3o98RvaXwh7gsihqP?imageslim" alt="ClipboardImage" width="545" height="261" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code data-query="{}" data-lang="">```java\n//边界提取\npublic byte[] Bound(byte bw[], int iw, int ih)\n{\n    int p, r;\n    byte[] tem = new byte[iw*ih];\n    for(int j = 0;j &#x3C; ih; j++)\n        for(int i = 0; i &#x3C; iw; i++)\n            tem[i+j*iw] = bw[i+j*iw];\n    for(int j = 1; j &#x3C; ih - 1; j++)\n    {\n        for (int i = 1; i &#x3C; iw - 1; i++)\n        {\n            p = bw[i+j*iw];\n            if(p == 0)//如果当前象素是白色, 进入下一个循环\n                continue;\n            else\n            {\n                // 检查周边的8-连通域\n                r = 1;\n                LB:\n                for(int k =-1;k&#x3C;2;k++)\n                {\n                    for(int l=-1;l&#x3C;2;l++)\n                    {\n                        if(bw[i+k+(j+l)*iw] == 0)\n                        {\n                            r = 0;\n                            break LB;//跳出2重循环\n                        }\n                    }\n                }\n                //如果都是黑点,判定为内部点,改变颜色\n                if(r == 1)\n                    tem[i+j*iw] = 0;\n            }\n        }\n    }\n    return tem;\n}\n```\n</code></pre>\n<h2 id="素描效果roberts边界检测"><a href="#%E7%B4%A0%E6%8F%8F%E6%95%88%E6%9E%9Croberts%E8%BE%B9%E7%95%8C%E6%A3%80%E6%B5%8B" aria-hidden="true"><span class="icon icon-link"></span></a>素描效果(roberts边界检测)</h2>\n</li>\n<li>\n<p>说明：上面说到边缘可以用微分算子检测，roberts算子就是基于一阶导数的边缘检测算子的一种。</p>\n</li>\n<li>\n<p>如图\n<img src="http://obu9je6ng.bkt.clouddn.com/Fk7ZRWXH81MM58St-T3chZiCay6-?imageslim" alt="ClipboardImage" width="542" height="261" /></p>\n</li>\n<li>\n<p>代码</p>\n<pre><code class="hljs language-java" data-query="{}" data-lang="java"><span class="hljs-comment">//Roberts算法</span>\n<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] robert(<span class="hljs-keyword">int</span>[] px, <span class="hljs-keyword">int</span> iw, <span class="hljs-keyword">int</span> ih, <span class="hljs-keyword">int</span> thresh, <span class="hljs-keyword">boolean</span> flag)\n{\n    ColorModel cm = ColorModel.getRGBdefault();\n    <span class="hljs-keyword">int</span> r, r0, r1, r2, r3, g, g0, g1, g2, g3, b, b0, b1, b2, b3;\n    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &#x3C; ih-<span class="hljs-number">1</span>; j++)\n    {\n        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &#x3C; iw-<span class="hljs-number">1</span>; i++)\n        {\n            r0 = cm.getRed(px[i+j*iw]);\n            r1 = cm.getRed(px[i+(j+<span class="hljs-number">1</span>)*iw]);\n            r2 = cm.getRed(px[i+<span class="hljs-number">1</span>+j*iw]);\n            r3 = cm.getRed(px[i+<span class="hljs-number">1</span>+(j+<span class="hljs-number">1</span>)*iw]);\n            <span class="hljs-comment">/*--------------------------------------------*\n             * -------------------------\n             * |r0:(i,j)  |r1:(i, j+1) |\n             * |-----------------------| 交叉\n             * |r2:(i+1,j)|r3:(i+1,j+1)|\n             * -------------------------\n             *--------------------------------------------*/</span>\n            r = (<span class="hljs-keyword">int</span>)Math.sqrt((r0-r3)*(r0-r3)+(r1-r2)*(r1-r2));\n\n            g0 = cm.getGreen(px[i+j*iw]);\n            g1 = cm.getGreen(px[i+(j+<span class="hljs-number">1</span>)*iw]);\n            g2 = cm.getGreen(px[i+<span class="hljs-number">1</span>+j*iw]);\n            g3 = cm.getGreen(px[i+<span class="hljs-number">1</span>+(j+<span class="hljs-number">1</span>)*iw]);\n            g = (<span class="hljs-keyword">int</span>)Math.sqrt((g0-g3)*(g0-g3)+(g1-g2)*(g1-g2));\n\n            b0 = cm.getBlue(px[i+j*iw]);\n            b1 = cm.getBlue(px[i+(j+<span class="hljs-number">1</span>)*iw]);\n            b2 = cm.getBlue(px[i+<span class="hljs-number">1</span>+j*iw]);\n            b3 = cm.getBlue(px[i+<span class="hljs-number">1</span>+(j+<span class="hljs-number">1</span>)*iw]);\n            b = (<span class="hljs-keyword">int</span>)Math.sqrt((b0-b3)*(b0-b3)+(b1-b2)*(b1-b2));\n            <span class="hljs-keyword">if</span>(flag)\n            {\n                <span class="hljs-keyword">if</span>(r > thresh) r = <span class="hljs-number">0</span>;<span class="hljs-comment">//黑色，边缘点</span>\n                <span class="hljs-keyword">else</span> r = <span class="hljs-number">255</span>;\n                px[i+j*iw] = (<span class="hljs-number">255</span>&#x3C;&#x3C;<span class="hljs-number">24</span>)|(r&#x3C;&#x3C;<span class="hljs-number">16</span>)|(r&#x3C;&#x3C;<span class="hljs-number">8</span>)|r;\n            }\n            <span class="hljs-keyword">else</span>\n                px[i+j*iw] = (<span class="hljs-number">255</span>&#x3C;&#x3C;<span class="hljs-number">24</span>)|(r&#x3C;&#x3C;<span class="hljs-number">16</span>)|(g&#x3C;&#x3C;<span class="hljs-number">8</span>)|b;\n        }\n    }\n    <span class="hljs-keyword">return</span> px;\n}</code></pre>\n</li>\n</ul>\n<h2 id="其他"><a href="#%E5%85%B6%E4%BB%96" aria-hidden="true"><span class="icon icon-link"></span></a>其他</h2>\n<ol>\n<li>\n<p>清空画板</p>\n</li>\n<li>\n<p>选择图片下载</p>\n</li>\n<li>\n<p>画板图片下载</p>\n</li>\n<li>\n<p>添加文字</p>\n</li>\n<li>\n<p>图形绘制，图形拖拽，图形填充</p>\n</li>\n</ol>\n<h1 id="参考资料"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true"><span class="icon icon-link"></span></a>参考资料</h1>\n<ul>\n<li>数字图像处理——Java编程与实验 （孙燮华著）</li>\n</ul>\n',extra:{}}}});