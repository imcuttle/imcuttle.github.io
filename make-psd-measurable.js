webpackJsonp([69,113],{1195:function(s,a){s.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=起因><a href=#%E8%B5%B7%E5%9B%A0 aria-hidden=true><span class="icon icon-link"></span></a>起因</h2><p>作为前端工程师，日常开发离不开 psd 文件。</p><p>但是日常开发的一个小弹窗页面，它的 psd 居然需要 <strong>30+Mb</strong>，所以经常得定期清理 psd...</p><p>对于我一个 PS 小菜鸡来说，用 PSD 无非只是需要用来度量元素大小（元素间距），查看属性等简单的功能。</p><h2 id=思考，对比><a href=#%E6%80%9D%E8%80%83%EF%BC%8C%E5%AF%B9%E6%AF%94 aria-hidden=true><span class="icon icon-link"></span></a>思考，对比</h2><p>相对比于 sketch，sketch 具有 <a href=https://github.com/utom/sketch-measure>sketch-measure</a>，设计师导出成静态资源给前端即可。</p><p><img src=https://i.loli.net/2018/09/18/5ba0be21d368f.png></p><p>对于 PSD 来说，市面上已经有如 pxcook / lanhuapp，体验也很不错，但是需要下载 U 同学提供的 (庞大的) psd 才能进行标注体验。</p><p>而且有时候还是需要 U 同学给(庞大的) PSD 文件，我们才能在 pxcook / lanhuapp 中自动标注。</p><p>于是鉴于以上，考虑做一个开源项目，类似于 sketch-measure， 定位为 psd-measure。</p><h2 id=效果展示><a href=#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA aria-hidden=true><span class="icon icon-link"></span></a>效果展示</h2><p><a href=https://imcuttle.github.io/measure/>DEMO</a></p><p><img src=http://obu9je6ng.bkt.clouddn.com//1537411054.png?imageMogr2/thumbnail/!100p></p><p><a href=https://github.com/imcuttle/measure>源码</a></p><h3 id=命令行><a href=#%E5%91%BD%E4%BB%A4%E8%A1%8C aria-hidden=true><span class="icon icon-link"></span></a>命令行</h3><p>我们也可以使用命令行来导出页面标注</p><p>bash</p><pre><code data-query={} data-lang>npm i measure-export-cli -g\n# 开启服务，在线预览 `path/to/psdDir` 下的 psd\nmeasure-export start path/to/psdDir\n# 构建 `path/to/psdDir` 下的 psd 至 `dist` 文件目录\nmeasure-export build path/to/psdDir\n</code></pre><h3 id=chrome-插件><a href=#chrome-%E6%8F%92%E4%BB%B6 aria-hidden=true><span class="icon icon-link"></span></a>Chrome 插件</h3><p>提供 Chrome 插件，当我们点击 psd 链接时候跳出 Measure UI，而不是下载 PSD，当然我们也可以点击右上方的下载进行下载。</p><p><img src=https://i.loli.net/2018/09/24/5ba8bd6ba8f09.png></p><h4 id=安装><a href=#%E5%AE%89%E8%A3%85 aria-hidden=true><span class="icon icon-link"></span></a>安装</h4><ol><li>下载扩展，<a href=https://github.com/imcuttle/measure/raw/master/packages/chrome-extension-measure-viewer/measure-viewer.zip>点击下载</a></li><li>打开 Chrome 扩展页面： chrome://extensions/</li><li>拖拽下载的包至页面中进行安装 <img src=https://i.loli.net/2018/09/24/5ba8bdd4c9096.png></li><li>出现该图标表示安装完成 <img src=https://i.loli.net/2018/09/24/5ba8be05d9f9a.png></li></ol><h2 id=设计与实现><a href=#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class="icon icon-link"></span></a>设计与实现</h2><p>流程如下：</p><p><img src=http://obu9je6ng.bkt.clouddn.com/psd-measure.svg></p><h3 id=psd-文件格式介绍><a href=#psd-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D aria-hidden=true><span class="icon icon-link"></span></a>PSD 文件格式介绍</h3><p><img src=https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/images/PhotoshopFileFormatsStructure.gif></p><ul><li>File Header（定长） 主要包括这个 psd 文件整体的数据，如版本，尺寸大小，图片通道数，使用的颜色类别（rgb、cmyk...）</li><li>Color Mode Data Section（变长） 主要是部分颜色类型图片需要用到</li><li>Image Resources（变长） 放置一些外部的图片资源</li><li>Layer and Mask（变长） 放置图层和蒙层的各种信息，大小位置，字体，描边等等</li><li>Image Data（变长） 放置图像像素数据</li></ul><h3 id=psdjs><a href=#psdjs aria-hidden=true><span class="icon icon-link"></span></a>PSD.js</h3><p>使用 psd.js 便是解析上述文件结构，得到可读的数据结构。 其中 psd.js 使用 getter 得到懒解析数据，即如下代码：</p><pre><code class="hljs language-javascipt"data-query={} data-lang=javascipt><span class=hljs-keyword>const</span> obj = <span class=hljs-built_in>Object</span>.defineProperty({}, <span class=hljs-string>\'someParsedVal\'</span>, {\n  <span class=hljs-attr>get</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\n    <span class=hljs-keyword>if</span> (!<span class=hljs-keyword>this</span>._someParsedVal) {\n      <span class=hljs-keyword>const</span> afterMs = <span class=hljs-built_in>Date</span>.now() + <span class=hljs-number>3000</span>\n      <span class=hljs-keyword>while</span> (<span class=hljs-literal>true</span>) {\n        <span class=hljs-keyword>if</span> (<span class=hljs-built_in>Date</span>.now() >= afterMs) {\n          <span class=hljs-keyword>this</span>._someParsedVal = <span class=hljs-string>\'ok\'</span>\n          <span class=hljs-keyword>break</span>\n        }\n      }\n    }\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>._someParsedVal\n  }\n})\n\nobj.someParsedVal <span class=hljs-comment>// 3s 后出来</span>\nobj.someParsedVal <span class=hljs-comment>// 很快</span></code></pre><p>在 mobx3 中也有类似的设计（LazyInitializer）</p><h3 id=psd-html><a href=#psd-html aria-hidden=true><span class="icon icon-link"></span></a>psd-html</h3><p>将 PSD 解析为 <a href=https://github.com/syntax-tree/hast>HAST</a>，进而转换为 HTML</p><h4 id=hast-html-抽象语法树><a href=#hast-html-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91 aria-hidden=true><span class="icon icon-link"></span></a>HAST (HTML 抽象语法树)</h4><p>如下 html：</p><pre><code class="hljs language-html"data-query={} data-lang=html><span class=hljs-tag>&lt;<span class=hljs-name>a</span> <span class=hljs-attr>href</span>=<span class=hljs-string>"http://alpha.com"</span> <span class=hljs-attr>class</span>=<span class=hljs-string>"bravo"</span> <span class=hljs-attr>download</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>a</span>></span></code></pre><p>对应 HAST 为</p><pre><code class="hljs language-json"data-query={} data-lang=json>{\n  <span class=hljs-attr>"type"</span>: <span class=hljs-string>"element"</span>,\n  <span class=hljs-attr>"tagName"</span>: <span class=hljs-string>"a"</span>,\n  <span class=hljs-attr>"properties"</span>: {\n    <span class=hljs-attr>"href"</span>: <span class=hljs-string>"http://alpha.com"</span>,\n    <span class=hljs-attr>"id"</span>: <span class=hljs-string>"bravo"</span>,\n    <span class=hljs-attr>"className"</span>: [<span class=hljs-string>"bravo"</span>],\n    <span class=hljs-attr>"download"</span>: <span class=hljs-literal>true</span>\n  },\n  <span class=hljs-attr>"children"</span>: []\n}</code></pre><h4 id=前后端同构><a href=#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%8C%E6%9E%84 aria-hidden=true><span class="icon icon-link"></span></a>前后端同构</h4><p>前后端同构的意思：同时运行在客户端和服务端，具体便是同时执行在浏览器环境和 nodejs 环境</p><p>实现前后端同构的一些常用方式，借助构建工具 browserify / rollup / webpack 来分别打包不同环境的 js</p><h5 id=模拟环境><a href=#%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83 aria-hidden=true><span class="icon icon-link"></span></a>模拟环境</h5><ul><li>在 nodejs 环境，对于 <a href=https://www.w3schools.com/nodejs/ref_modules.asp>nodejs built-in modules</a> 不进行打包</li><li>在 browser 环境，则将预设的 built-in modules 打包进去，以及一些 global 变量（如 <code>process.env / __dirname</code>）也会进行 mock</li></ul><h5 id=利用-变量替换--treeshake-区分不同环境的代码><a href=#%E5%88%A9%E7%94%A8-%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2--treeshake-%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BB%A3%E7%A0%81 aria-hidden=true><span class="icon icon-link"></span></a>利用 变量替换 + treeshake 区分不同环境的代码</h5><ul><li><p>如 webpack 配置 <code>DefinePlugin</code></p><pre><code data-query={} data-lang>{\n  plugins: [\n    new webpack.DefinePlugin({\n      \'process.env.RUN_ENV\': JSON.stringify(\'browser\')\n    })\n  ]\n}\n</code></pre></li><li><p>在代码中对不同环境打包进行区分</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-built_in>module</span>.exports =\n  process.env.RUN_ENV === <span class=hljs-string>\'browser\'</span>\n    ? {\n        psdToHtml,\n        psdToHtmlFromBuffer,\n        psdToHtmlFromURL,\n        psdToHAST,\n        psdToHASTFromBuffer\n      }\n    : {\n        psdToHtml,\n        psdToHtmlFromPath,\n        psdToHtmlFromBuffer,\n        psdToHAST,\n        psdToHASTFromBuffer,\n        psdToHASTFromPath\n      }</code></pre></li><li><p>最终打包出来的 js 则会剔除掉 <code>psdToHASTFromPath</code> 相关代码</p></li></ul><h5 id=packagejson-配置><a href=#packagejson-%E9%85%8D%E7%BD%AE aria-hidden=true><span class="icon icon-link"></span></a><code>package.json</code> 配置</h5><p>如下：</p><pre><code class="hljs language-json"data-query={} data-lang=json>{\n  <span class=hljs-attr>"main"</span>: <span class=hljs-string>"dist/psd-html.cjs.js"</span>,\n  <span class=hljs-attr>"browser"</span>: <span class=hljs-string>"dist/psd-html.browser.cjs.js"</span>,\n  <span class=hljs-attr>"cdn"</span>: <span class=hljs-string>"dist/psd-html.browser.umd.min.js"</span>,\n  <span class=hljs-attr>"unpkg"</span>: <span class=hljs-string>"dist/psd-html.browser.umd.min.js"</span>\n}</code></pre><ul><li><code>main</code>: nodejs 环境加载的 js</li><li><code>browser</code>: browser 环境加载的 js</li><li><code>cdn</code>: 部分 cdn 服务加载的 js</li><li><code>unpkg</code>: unpkg cdn 服务加载的 js （主要使用 UMD 规范打包）</li></ul><p>直接访问 <a href=https://unpkg.com/@moyuyc/psd-html>https://unpkg.com/@moyuyc/psd-html</a> 则会重定向至 <a href=https://unpkg.com/@moyuyc/psd-html@%7Blatest-version%7D/dist/psd-html.browser.umd.min.js>https://unpkg.com/@moyuyc/psd-html@{latest-version}/dist/psd-html.browser.umd.min.js</a></p><h3 id=html-measure-交互><a href=#html-measure-%E4%BA%A4%E4%BA%92 aria-hidden=true><span class="icon icon-link"></span></a>html-measure 交互</h3><h4 id=布局定位><a href=#%E5%B8%83%E5%B1%80%E5%AE%9A%E4%BD%8D aria-hidden=true><span class="icon icon-link"></span></a>布局定位</h4><p><img src=https://i.loli.net/2018/09/18/5ba0c06942981.png></p><p>将 psd 导出成整个图片，利用每一个图层的定位和大小来自动标注。</p><h4 id=其他><a href=#%E5%85%B6%E4%BB%96 aria-hidden=true><span class="icon icon-link"></span></a>其他</h4><p>2 个 div，相对与同一个父级的绝对定位，如何判断他们是否相交？</p><p>. . . . . . . . . .</p><p>正面直接判断是很费力的，要考虑各种情况，这时候需要逆向思维，考虑不相交的情况。 这时候就简单了</p><p>不相交只要满足下面四种情况之一就可以</p><p><img src=https://i.loli.net/2018/09/20/5ba2fd9e30a0b.png></p><p><img src=https://i.loli.net/2018/09/20/5ba2fe0ac7cd4.png></p><pre><code data-query={} data-lang>function isIntersect(node1, node2) {\n  const rect1 = node1.getBoundingClientRect()\n  const rect2 = node2.getBoundingClientRect()\n  return !(\n    rect1.right &lt; rect2.left ||\n    rect1.left > rect2.right ||\n    rect1.bottom &lt; rect2.top ||\n    rect1.top > rect2.bottom\n  )\n}\n</code></pre><h3 id=measure-export-cli><a href=#measure-export-cli aria-hidden=true><span class="icon icon-link"></span></a>measure-export(-cli)</h3><p>输入 psd / html 导出 <code>meas-ui</code> 静态资源，流程如图（区分 prod 和 dev 环境）</p><p><img src=http://obu9je6ng.bkt.clouddn.com//measure-export(-cli).svg></p><h2 id=todo><a href=#todo aria-hidden=true><span class="icon icon-link"></span></a>Todo</h2><ul><li class=task-list-item><input type=checkbox disabled> 提供 chrome 插件：当浏览器打开 psd 时候，渲染测量尺寸 UI</li></ul><h2 id=相关项目><a href=#%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE aria-hidden=true><span class="icon icon-link"></span></a>相关项目</h2><ul><li><a href=https://github.com/imcuttle/psd.js>@moyuyc/psd.js</a> - 解析 psd 文件，格式化 (Forked from <a href=https://github.com/meltingice/psd.js>psd.js</a>)</li><li><a href=https://github.com/imcuttle/measure/tree/master/packages/psd-html>@moyuyc/psd-html</a> - psd -> hast -> html</li><li><a href=https://github.com/imcuttle/measure/tree/master/packages/html-measure>html-measure</a> - 标注交互</li><li><a href=https://github.com/imcuttle/measure/tree/master/packages/meas-ui>meas-ui</a> - 前端 UI 展示，包含标注交互</li><li><a href=https://github.com/imcuttle/measure/tree/master/packages/measure-export-cli>measure-export(-cli)</a> - 输入 psd / html 导出 <code>meas-ui</code> 静态资源</li></ul><h2 id=参考资料><a href=#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 aria-hidden=true><span class="icon icon-link"></span></a>参考资料</h2><ul><li><a href=https://www.adobe.com/devnet-apps/photoshop/fileformatashtml>Adobe Photoshop File Formats Specification</a> PS 文件格式官方标准</li><li><a href=https://www.tonton-pixel.com/Photoshop%20Additional%20File%20Formats/styles-file-format.html#toc-parsing-styles-files>Photoshop Styles File Format</a></li><li><a href=https://zhuanlan.zhihu.com/p/29704064>JS. 如何判断两个矩形是否相交</a></li><li><a href=https://github.com/syntax-tree/hast>HAST</a></li></ul>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=make-psd-measurable.js.map