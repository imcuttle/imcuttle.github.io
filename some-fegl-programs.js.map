{"version":3,"sources":["webpack:///some-fegl-programs.js","webpack:///./source/_articles/some-fegl-programs.md"],"names":["webpackJsonp","1233","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA;AACAC,OACAC,oBACAC","file":"some-fegl-programs.js","sourcesContent":["webpackJsonp([32,113],{\n\n/***/ 1233:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id=前言><a href=#%E5%89%8D%E8%A8%80 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>前言</h1><p>这是一篇不太正规的「计算机图形学论文」，其实论文谈不上，因为根本上不到研究的层次，就是自己瞎捣鼓。 主要介绍了几个与图形学相关的程序，皆采用前端技术实现，点击即可查看。</p><ul><li><a href=http://moyuyc.github.io/htm/painter/>简单的绘图程序</a></li><li><a href=http://moyuyc.github.io/2016/04/26/canvas%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%B1%E7%93%A3/>三次贝赛尔曲线应用-绘制平面动态花瓣</a></li><li><a href=/htm/bezier.html>动态绘制三次贝赛尔曲线</a></li><li><a href=http://moyuyc.xyz/play_3d/play_3d_demo1.html>三维几何体的基本变换与组合变换应用</a></li></ul><!--more--><h1 id=主要内容><a href=#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>主要内容</h1><h2 id=简单的绘图程序><a href=#%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>简单的绘图程序</h2><h3 id=介绍><a href=#%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>主要运用HTML5 canvas API与相关图形学知识实现的绘图程序（还包括部分图像处理功能，不介绍）。 能够选择图形类型（Pen/Line/Circle）,画笔颜色（随机生成）,画笔宽度, 图形对象拖拽移动，图形种子填充算法。</p><h3 id=演示图片><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif1.gif alt=img width=1142 height=747><h3 id=代码解释><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p><code>Shape.js ： 主要包含一些图形类</code></p><p>点类代码</p><pre><code data-query={} data-lang>Point: function (x, y) {\\n    this.x = x;\\n    this.y = y;\\n    this.distance = function (p) {\\n        p = p?p:new Shape.Point(0,0);\\n        return Math.sqrt(Math.pow(p.x-this.x,2)+Math.pow(p.y-this.y,2));\\n    };\\n    this.move = function(offsetX,offsetY){\\n        this.x+=offsetX;this.y+=offsetY;\\n    };\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        paint.strokeStyle = this.color ? this.color : 'black';\\n        paint.lineWidth = this.linewidth!=null ? this.linewidth : 1;\\n        paint.beginPath();\\n        paint.moveTo(this.x, this.y);\\n        paint.lineTo(this.x + 1, this.y + 1);\\n        paint.stroke();\\n        paint.save();\\n        return this;\\n    }\\n}\\n</code></pre><p>线段类代码</p><pre><code data-query={} data-lang>Line: function (p1, p2) {\\n    this.sp = p1;\\n    this.ep = p2;\\n    //this.color;this.linewidth;\\n    this.move = function(offsetX,offsetY){\\n        this.sp.x+=offsetX;this.sp.y+=offsetY;\\n        this.ep.x+=offsetX;this.ep.y+=offsetY;\\n    };\\n    // 不足：未考虑线宽，用户较难选中\\n    this.isIn = function (point) {\\n        var x = point.x, y = point.y;\\n        if((y-this.sp.y)*(x-this.ep.x)==(y-this.ep.y)*(x-this.sp.x))\\n            return true;\\n        return false;\\n    };\\n    // 中点划线法\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth!=null?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        var ep = this.ep, sp = this.sp,\\n            dX = ep.x - sp.x,\\n            dY = ep.y - sp.y,\\n            a = sp.y - ep.y,\\n            b = ep.x - sp.x;\\n        if (Math.abs(dX) >= Math.abs(dY)) {\\n            if (dX >= 0 &amp&amp dY >= 0) {\\n                var d = b + 2 * a, d1 = 2 * a, d2 = 2 * (a + b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x + 1, y = sp.y; x &lt; ep.x; x++) {\\n                    if (d >= 0) d = d + d1;\\n                    else {\\n                        y++;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX >= 0 &amp&amp dY &lt;= 0) {\\n                var d = -b + a &lt;&lt; 1, d1 = (a - b) &lt;&lt; 1, d2 = a &lt;&lt; 1;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x + 1, y = sp.y; x &lt; ep.x; x++) {\\n                    if (d >= 0) {\\n                        y--;\\n                        d = d + d1;\\n                    }\\n                    else d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX &lt;= 0 &amp&amp dY &lt;= 0) {\\n                var d = -b - 2 * a, d1 = -2 * a, d2 = -2 * (a + b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\\n                    if (d >= 0) d = d + d1;\\n                    else {\\n                        y--;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else {\\n                var d = b - 2 * a, d1 = 2 * (b - a), d2 = -2 * a;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\\n                    if (d >= 0) {\\n                        y++;\\n                        d = d + d1;\\n                    }\\n                    else d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n        }\\n        else {\\n            if (dX >= 0 &amp&amp dY >= 0) {\\n                var d = a + 2 * b, d1 = 2 * (a + b), d2 = 2 * b;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y + 1; y &lt; ep.y; y++) {\\n                    if (d >= 0) {\\n                        x++;\\n                        d = d + d1;\\n                    }\\n                    else {\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX >= 0 &amp&amp dY &lt;= 0) {\\n                var d = a - 2 * b, d1 = -2 * b, d2 = 2 * (a - b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\\n                    if (d >= 0)      d = d + d1;\\n                    else {\\n                        x++;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n\\n            }\\n            else if (dX &lt;= 0 &amp&amp dY &lt;= 0) {\\n                var d = -a - 2 * b, d1 = -2 * (a + b), d2 = -2 * b;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\\n                    if (d >= 0) {\\n                        x--;\\n                        d = d + d1;\\n                    }\\n                    else               d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n\\n            }\\n            else {\\n                var d = -a + 2 * b, d1 = 2 * b, d2 = 2 * (b - a);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y + 1; y &lt; ep.y; y++) {\\n                    if (d >= 0)           d = d + d1;\\n                    else {\\n                        x--;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n        }\\n        return this;\\n    }\\n}\\n</code></pre><p>圆类代码</p><pre><code data-query={} data-lang>Circle: function (cp, r) {\\n    this.cp = cp;\\n    this.r = r;\\n    this.move = function(offsetX,offsetY){\\n        this.cp.x+=offsetX;this.cp.y+=offsetY;\\n    };\\n    //this.color;this.linewidth;\\n    this.isIn = function (point) {\\n        var x = point.x, y = point.y;\\n        return (x-this.cp.x)*(x-this.cp.x)+(y-this.cp.y)*(y-this.cp.y)&lt;=this.r*this.r;\\n    };\\n    // 八分法画圆\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        //console.log(color);\\n        var r = this.r, cp = this.cp,\\n            d = 1 - r, p = new Shape.Point(0, r);\\n        while (p.x &lt;= p.y) {\\n            new Shape.Point(cp.x + p.x, cp.y + p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.x, cp.y - p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.x, cp.y + p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.x, cp.y - p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.y, cp.y + p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.y, cp.y - p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.y, cp.y + p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.y, cp.y - p.x).draw(paint, color, linewidth);\\n            p.x++;\\n            if (d &lt; 0) d = d + 2 * p.x + 1;\\n            else {\\n                p.y--;\\n                d = d + 2 * p.x - 2 * p.y + 1;\\n            }\\n        }\\n        return this;\\n    };\\n    //种子填充算法 深度优先搜索，基于栈，isam表示是否含动画填充效果\\n    this.dfsFill = function (paint,p,color,isam) {\\n        isam = isam || false;\\n        var stack = [p],hashmap = {},container=[];\\n        while (stack.length !== 0){\\n            p = stack.pop();\\n            if(isam)\\n                container.push(p);\\n            else\\n                p.draw(paint,color);\\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\\n                .forEach(ele=>{\\n                    if(this.isIn(ele) &amp&amp !hashmap[ele]) {\\n                        stack.push(ele);\\n                        hashmap[ele] = hashmap[ele]+1 || 0;\\n                    }\\n                });\\n        }\\n        console.log(hashmap);\\n        if(isam) {\\n            var animate = requestAnimationFrame;\\n            animate(function () {\\n                if (!container.length) return;\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                animate(arguments.callee);\\n            })\\n        }\\n    };\\n    //种子填充算法 广度优先搜索，基于队列。\\n    this.bfsFill = function (paint,p,color,isam) {\\n        isam = isam || false;\\n        var queue = [p],hashmap = {},container=[];\\n        while (queue.length !== 0){\\n            p = queue.shift();\\n            if(isam)\\n                container.push(p);\\n            else\\n                p.draw(paint,color);\\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\\n                .forEach(ele=>{\\n                    if(this.isIn(ele) &amp&amp !hashmap[ele]) {\\n                        queue.push(ele);\\n                        hashmap[ele] = hashmap[ele]+1 || 0;\\n                    }\\n                });\\n        }\\n        console.log(hashmap);\\n        if(isam) {\\n            var animate = requestAnimationFrame;\\n            animate(function () {\\n                if (!container.length) return;\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                animate(arguments.callee);\\n            })\\n        }\\n    }\\n}\\n</code></pre><p>路径类代码</p><pre><code data-query={} data-lang>Path: function (points) {\\n    this.ps = points;\\n    this.move = function(offsetX,offsetY){\\n        for(var i = 0;i&lt;this.ps.length;i++){\\n            this.ps[i].x+=offsetX;\\n            this.ps[i].y+=offsetY;\\n        }\\n    };\\n    this.isIn = function (point) {\\n        var p = this.ps[0];\\n        for(var i=1;i&lt;this.ps.length;i++){\\n            if(new Shape.Line(p,this.ps[i]).isIn(point))\\n                return true;\\n            p = this.ps[i];\\n        }\\n        return false;\\n    };\\n    // 调用canvas提供的api\\n    this.draw = function (paint,color,linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        //console.log(color);\\n        var arr = this.ps;\\n        if(arr.length==0)  return;\\n        paint.beginPath();\\n        paint.strokeStyle = color ? color : 'black';\\n        paint.lineWidth = linewidth ? linewidth : 1;\\n        paint.moveTo(arr[0].x,arr[0].y);\\n        for(var i =1;i&lt;arr.length;i++){\\n            paint.lineTo(arr[i].x,arr[i].y);\\n        }\\n        paint.stroke();\\n        return this;\\n    }\\n}\\n</code></pre><p><code>canvas.js: 包含其他一些对事件的绑定或者对控件的控制等代码</code></p><p>选中图形进行拖动函数</p><pre><code data-query={} data-lang>dragMoveHandle = function () {\\n    var f1 = function(e){\\n    var x = e.offsetX, y = e.offsetY;\\n    var v = Tool.getInFirstShape(new Shape.Point(x,y));\\n    if(v){\\n    var f2 = function (e2) {\\n        if(e2.buttons==1){\\n        var offsetx = e2.offsetX-x, offsety = e2.offsetY-y;\\n        x=e2.offsetX; y = e2.offsetY;\\n        v.move(offsetx,offsety);\\n        Tool.refresh();\\n        }\\n    },f3 = function (e3) {\\n        var offsetx = e3.offsetX-x, offsety = e3.offsetY-y;\\n        v.move(offsetx,offsety);\\n        Tool.refresh();\\n        // e3.stopPropagation();\\n        $(this).off('mousemove',f2).off('mouseup',f3);\\n    };\\n    $(paint.canvas).on('mousemove',f2).on('mouseup',f3).off('mousedown',f1);\\n    }else\\n    $('[role=opType-item]').removeClass('active');\\n}\\n$(paint.canvas).on('mousedown',f1)\\n}\\n</code></pre><p>关于Tool对象</p><pre><code data-query={} data-lang>Tool = {\\n    getInFirstShape : function(p){\\n        var f = function(d){\\n            for(var i =0;i&lt; d.length;i++){\\n                if(d[i].isIn(p))//点p是否在d[i]图形对象中？\\n                    return d[i];\\n            }\\n            return false;\\n        };\\n        var r;\\n        for(var d in paint.data)\\n            //paint.data 表示存在于画布中的所有图形对象\\n            if((r=f(paint.data[d]))!=false)\\n                return r;\\n    },\\n    // 重新绘制\\n    refresh : function () {\\n        paint.clearRect(0,0,paint.canvas.width,paint.canvas.height);\\n        for(var i =0;i&lt;paint.data.Paths.length;i++)\\n            paint.data.Paths[i].draw(paint);\\n        for(var i =0;i&lt;paint.data.Lines.length;i++)\\n            paint.data.Lines[i].draw(paint);\\n        for(var i =0;i&lt;paint.data.Circles.length;i++)\\n            paint.data.Circles[i].draw(paint);\\n    }\\n}\\n</code></pre><h3 id=不足之处><a href=#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>不足之处</h3><ol><li>对于<code>Line</code>的<code>isIn</code>方法，未考虑到线宽的因素，用户很难准确选中线段</li><li>对于拖动图形的事件处理逻辑较复杂。</li><li>对于图形类中未使用到<code>js</code>中的原型与原型继承，降低了代码复用度。</li></ol><h2 id=三次贝赛尔曲线应用-绘制平面动态花瓣><a href=#%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%BA%94%E7%94%A8-%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E5%8A%A8%E6%80%81%E8%8A%B1%E7%93%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>三次贝赛尔曲线应用-绘制平面动态花瓣</h2><h3 id=介绍-1><a href=#%E4%BB%8B%E7%BB%8D-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>主要运用HTML5 canvas API与相关图形学知识实现的平面动态花瓣绘制。</p><h3 id=演示图片-1><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif2.gif alt=img width=992 height=604><h3 id=代码解释-1><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><ul><li>核心代码</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Flower</span>(<span class=hljs-params>c,petals,size,x,y,rotate</span>)</span>{\\n\\t<span class=hljs-keyword>this</span>.c = c || [<span class=hljs-number>255</span>,<span class=hljs-number>255</span>,<span class=hljs-number>255</span>];\\n\\t<span class=hljs-keyword>this</span>.petals = petals || <span class=hljs-number>4</span>;\\n\\t<span class=hljs-keyword>this</span>.size = size || <span class=hljs-number>5</span>;\\n\\t<span class=hljs-keyword>this</span>.x = x || <span class=hljs-number>0</span>;\\n\\t<span class=hljs-keyword>this</span>.y = y || <span class=hljs-number>0</span>;\\n\\t<span class=hljs-keyword>this</span>.rotate = rotate || <span class=hljs-number>0</span>;\\n}\\nFlower.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n\\t<span class=hljs-keyword>var</span> _rad = <span class=hljs-keyword>this</span>.size,_num_pts=<span class=hljs-keyword>this</span>.petals,_x=<span class=hljs-keyword>this</span>.x,_y=<span class=hljs-keyword>this</span>.y,c=<span class=hljs-keyword>this</span>.c;\\n\\tctx.save();\\n\\tctx.shadowBlur = <span class=hljs-number>30</span>; <span class=hljs-comment>//阴影程度</span>\\n\\tctx.lineWidth = <span class=hljs-number>1</span>;\\n\\tctx.shadowColor = utils.rgba(c[<span class=hljs-number>0</span>],c[<span class=hljs-number>1</span>],c[<span class=hljs-number>2</span>],<span class=hljs-number>1</span>); <span class=hljs-comment>//阴影颜色</span>\\n\\tctx.fillStyle = utils.rgba(c[<span class=hljs-number>0</span>],c[<span class=hljs-number>1</span>],c[<span class=hljs-number>2</span>],<span class=hljs-number>.6</span>); <span class=hljs-comment>//填充颜色</span>\\n\\tc2 = c.map(<span class=hljs-function>(<span class=hljs-params>x</span>)=></span><span class=hljs-built_in>Math</span>.floor(x/<span class=hljs-number>1.6</span>));           <span class=hljs-comment>//lambda表达式写法</span>\\n\\tctx.strokeStyle = utils.rgba(c2[<span class=hljs-number>0</span>],c2[<span class=hljs-number>1</span>],c2[<span class=hljs-number>2</span>],<span class=hljs-number>1</span>);  <span class=hljs-comment>//边框颜色</span>\\n\\t<span class=hljs-keyword>var</span> pts = [];\\n\\t<span class=hljs-keyword>var</span> _a = <span class=hljs-keyword>this</span>.rotate+(tick*<span class=hljs-number>1</span>);\\n\\t<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span> ; i &lt;= _num_pts ; i++){<span class=hljs-comment>//增量法提高效率</span>\\n\\t\\tpts.push({<span class=hljs-attr>x</span>:utils.P2L(_rad, _a).x,<span class=hljs-attr>y</span>:utils.P2L(_rad, _a).y}); <span class=hljs-comment>//P2L将极坐标转换为平面坐标</span>\\n\\t\\t_a += (<span class=hljs-number>360</span>/_num_pts);\\n\\t}\\n\\t<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>1</span> ; i&lt;= _num_pts; i+=<span class=hljs-number>2</span>){\\n\\t\\tidx= i%_num_pts;\\n\\t\\tctx.beginPath();<span class=hljs-comment>//开始绘制</span>\\n\\t\\tctx.moveTo(_x,_y);<span class=hljs-comment>//起点为(_x,_y)</span>\\n\\t\\tctx.bezierCurveTo(_x+pts[i<span class=hljs-number>-1</span>].x,_y+pts[i<span class=hljs-number>-1</span>].y,_x+pts[idx+<span class=hljs-number>1</span>].x,_y+pts[idx+<span class=hljs-number>1</span>].y,_x,_y);<span class=hljs-comment>//绘制贝塞尔曲线</span>\\n\\t\\tctx.stroke();<span class=hljs-comment>//闭合图形边框</span>\\n\\t\\tctx.fill();<span class=hljs-comment>//填充图形</span>\\n\\t}\\n\\tctx.restore();\\n}\\nHTMLCanvasElement.prototype.magicBg = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n\\t<span class=hljs-keyword>var</span> ctx = <span class=hljs-keyword>this</span>.getContext(<span class=hljs-string>'2d'</span>);\\n\\t<span class=hljs-keyword>if</span>(!<span class=hljs-keyword>this</span>.grd){\\n\\t\\t<span class=hljs-comment>//实现从画布中心往外呈圆形扩散，渐变。</span>\\n\\t\\t<span class=hljs-keyword>this</span>.grd=ctx.createRadialGradient(<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>,<span class=hljs-built_in>Math</span>.min(<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height)/<span class=hljs-number>1.2</span>);\\n\\t\\t<span class=hljs-keyword>this</span>.grd.addColorStop(<span class=hljs-number>0</span>,<span class=hljs-string>\\\"rgba(255,255,255,.25)\\\"</span>);\\n\\t\\t<span class=hljs-keyword>this</span>.grd.addColorStop(<span class=hljs-number>1</span>,<span class=hljs-keyword>this</span>.utils.rgba(<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>.65</span>));\\n\\t}\\n\\tctx.save();\\n\\tctx.clearRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height);\\n\\tctx.fillStyle = <span class=hljs-keyword>this</span>.grd;\\n\\tctx.fillRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height);\\n\\tctx.restore();\\n}</code></pre><ul><li>Flower对象解释</li></ul><table><thead><tr><th>参数</th><th>说明</th><th>默认</th><th>类型</th></tr></thead><tbody><tr><td><code>c</code></td><td>花瓣的颜色</td><td>[255,255,255]</td><td>Array</td></tr><tr><td><code>petals</code></td><td>花瓣个数</td><td>4</td><td>Number</td></tr><tr><td><code>size</code></td><td>半径大小</td><td>5</td><td>Number</td></tr><tr><td><code>x</code></td><td>中心 x 坐标</td><td>0</td><td>Number</td></tr><tr><td><code>y</code></td><td>中心 y 坐标</td><td>0</td><td>Number</td></tr><tr><td><code>rotate</code></td><td>绕中心旋转角度</td><td>0</td><td>Number(单位：度)</td></tr></tbody></table><ul><li><code>Flower.draw</code> 方法解释</li></ul><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>_rad</code></td><td>radix，对应<code>size</code></td></tr><tr><td><code>_num_pts</code></td><td>对应<code>petals</code></td></tr><tr><td><code>_x</code></td><td>对应<code>x</code></td></tr><tr><td><code>_y</code></td><td>对应<code>y</code></td></tr><tr><td><code>c</code></td><td>对应<code>c</code></td></tr></tbody></table><ul><li>关于贝塞尔曲线，<a href=http://bbs.csdn.net/topics/390358020>参考资料</a></li></ul><img src=/images/bezier3.gif alt=IMG width=240 height=100><center>图：三次贝塞尔曲线动态绘制效果</center><img src=false alt=ClipboardImage width=746 height=725 data-src=http://obu9je6ng.bkt.clouddn.com/FqrMRZZXMInLzy27Mc6CCWwHrC_v?imageslim><center>图：花瓣与其贝塞尔曲线控制点</center>- 怎么使用？ 1. `<script src=drawflower.js></script>` 2. `canvas.drawFlower(option);`<pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>//default option</span>\\n{\\n\\t<span class=hljs-attr>animate</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>rotate</span>:<span class=hljs-number>90</span>,\\n\\t<span class=hljs-attr>randomSize</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>randomColor</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>randomPetals</span>: <span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>pos</span>:{\\n\\t\\t<span class=hljs-attr>x</span>:<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,\\n\\t\\t<span class=hljs-attr>y</span>:<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>\\n\\t}\\n}</code></pre><p>or</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>{\\n\\t<span class=hljs-attr>animate</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>rotate</span>:<span class=hljs-number>-20</span>,\\n\\t<span class=hljs-attr>randomSize</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>size</span>:<span class=hljs-number>10</span>,\\n\\t<span class=hljs-attr>randomColor</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>color</span>:[<span class=hljs-number>100</span>,<span class=hljs-number>100</span>,<span class=hljs-number>100</span>],\\n\\t<span class=hljs-attr>randomPetals</span>: <span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>petals</span>:<span class=hljs-number>6</span>,\\n\\t<span class=hljs-attr>pos</span>:{\\n\\t\\t<span class=hljs-attr>x</span>:<span class=hljs-number>0</span>,\\n\\t\\t<span class=hljs-attr>y</span>:<span class=hljs-number>0</span>\\n\\t}\\n}</code></pre><h2 id=动态绘制三次贝赛尔曲线><a href=#%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>动态绘制三次贝赛尔曲线</h2><h3 id=介绍-2><a href=#%E4%BB%8B%E7%BB%8D-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>应用canvas API, 事件绑定, 达到动态绘制三次贝赛尔曲线效果。</p><h3 id=演示图片-2><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif3.gif alt=img width=792 height=649><h3 id=代码解释-2><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p>自己定义的<code>Pos</code> <code>Rect</code> <code>Circle</code> 类</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Pos</span>(<span class=hljs-params>x,y</span>)</span>{<span class=hljs-keyword>this</span>.x=x;<span class=hljs-keyword>this</span>.y=y;}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Circle</span>(<span class=hljs-params>p,r</span>)</span>{<span class=hljs-keyword>this</span>.p=p;<span class=hljs-keyword>this</span>.r=r;}\\nCircle.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>sty</span>)</span>{\\n    ctx.save();\\n    ctx.strokeStyle=sty||<span class=hljs-string>'blue'</span>;\\n    ctx.beginPath();\\n    ctx.arc(<span class=hljs-keyword>this</span>.p.x, <span class=hljs-keyword>this</span>.p.y, <span class=hljs-keyword>this</span>.r, <span class=hljs-number>0</span>, <span class=hljs-built_in>Math</span>.PI * <span class=hljs-number>2</span>, <span class=hljs-literal>true</span>);\\n    ctx.stroke();\\n    ctx.restore();\\n}\\n<span class=hljs-comment>// p is in Circle?</span>\\nCircle.prototype.around=<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>p</span>)</span>{\\n    <span class=hljs-keyword>return</span> (p.x-<span class=hljs-keyword>this</span>.p.x)*(p.x-<span class=hljs-keyword>this</span>.p.x)+ (p.y-<span class=hljs-keyword>this</span>.p.y)*(p.y-<span class=hljs-keyword>this</span>.p.y)&lt;=<span class=hljs-keyword>this</span>.r*<span class=hljs-keyword>this</span>.r;\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Rect</span>(<span class=hljs-params>p,w,h</span>)</span>{<span class=hljs-keyword>this</span>.p=p;<span class=hljs-keyword>this</span>.w=w;<span class=hljs-keyword>this</span>.h=h;};\\nRect.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>style</span>) </span>{\\n    ctx.save();\\n    ctx.strokeStyle=style||<span class=hljs-string>'blue'</span>;\\n    <span class=hljs-keyword>var</span> v = <span class=hljs-keyword>this</span>.w>>> <span class=hljs-number>1</span>,t = <span class=hljs-keyword>this</span>.h>>><span class=hljs-number>1</span>;\\n    ctx.strokeRect(<span class=hljs-keyword>this</span>.p.x-v, <span class=hljs-keyword>this</span>.p.y-t,<span class=hljs-keyword>this</span>.w,<span class=hljs-keyword>this</span>.h);\\n    ctx.restore();\\n}\\n<span class=hljs-comment>// p is in Rect?</span>\\nRect.prototype.around = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>p</span>) </span>{\\n    <span class=hljs-keyword>var</span> v = <span class=hljs-keyword>this</span>.w>>> <span class=hljs-number>1</span>,t = <span class=hljs-keyword>this</span>.h>>><span class=hljs-number>1</span>;\\n    <span class=hljs-keyword>return</span> p.x>=<span class=hljs-keyword>this</span>.p.x-v &amp&amp p.x&lt;=<span class=hljs-keyword>this</span>.p.x+v &amp&amp p.y>=<span class=hljs-keyword>this</span>.p.y-t &amp&amp p.y&lt;=<span class=hljs-keyword>this</span>.p.y+t;\\n}</code></pre><p>初始化</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> midP = <span class=hljs-keyword>new</span> Pos(<span class=hljs-built_in>window</span>.innerWidth>>><span class=hljs-number>1</span>,<span class=hljs-built_in>window</span>.innerHeight>>><span class=hljs-number>1</span>),\\n    sP = <span class=hljs-keyword>new</span> Circle(<span class=hljs-keyword>new</span> Pos(midP.x<span class=hljs-number>-100</span>,midP.y<span class=hljs-number>-100</span>),<span class=hljs-number>4</span>),\\n    cP1= <span class=hljs-keyword>new</span> Rect(<span class=hljs-keyword>new</span> Pos(midP.x<span class=hljs-number>-80</span>,midP.y+<span class=hljs-number>10</span>),<span class=hljs-number>8</span>,<span class=hljs-number>8</span>),\\n    cP2= <span class=hljs-keyword>new</span> Rect(<span class=hljs-keyword>new</span> Pos(midP.x+<span class=hljs-number>80</span>,midP.y+<span class=hljs-number>20</span>),<span class=hljs-number>8</span>,<span class=hljs-number>8</span>),\\n    eP = <span class=hljs-keyword>new</span> Circle(<span class=hljs-keyword>new</span> Pos(midP.x+<span class=hljs-number>100</span>,midP.y+<span class=hljs-number>100</span>),<span class=hljs-number>4</span>);</code></pre><p>绘制三次贝塞尔曲线</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>drawBezier</span>(<span class=hljs-params>ps</span>)</span>{\\n    ctx.save();\\n    ctx.beginPath();\\n    ctx.moveTo(ps[<span class=hljs-number>0</span>].x,ps[<span class=hljs-number>0</span>].y);\\n    ctx.bezierCurveTo(ps[<span class=hljs-number>1</span>].x,ps[<span class=hljs-number>1</span>].y,ps[<span class=hljs-number>2</span>].x,ps[<span class=hljs-number>2</span>].y,ps[<span class=hljs-number>3</span>].x,ps[<span class=hljs-number>3</span>].y);\\n    ctx.stroke();\\n    <span class=hljs-comment>// 自己实现的绘制虚线方法</span>\\n    ctx.dashedLineTo(ps[<span class=hljs-number>0</span>].x,ps[<span class=hljs-number>0</span>].y,ps[<span class=hljs-number>1</span>].x,ps[<span class=hljs-number>1</span>].y);\\n    ctx.dashedLineTo(ps[<span class=hljs-number>3</span>].x,ps[<span class=hljs-number>3</span>].y,ps[<span class=hljs-number>2</span>].x,ps[<span class=hljs-number>2</span>].y);\\n    ctx.restore();\\n}</code></pre><p><code>ctx.dashedLineTo</code>方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>CanvasRenderingContext2D.prototype.dashedLineTo = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>fromX, fromY, toX, toY, pattern</span>) </span>{\\n    <span class=hljs-comment>// default interval distance -> 5px</span>\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> pattern === <span class=hljs-string>\\\"undefined\\\"</span>) {\\n        pattern = <span class=hljs-number>5</span>;\\n    }\\n    <span class=hljs-comment>// calculate the delta x and delta y</span>\\n    <span class=hljs-keyword>var</span> dx = (toX - fromX);\\n    <span class=hljs-keyword>var</span> dy = (toY - fromY);\\n    <span class=hljs-keyword>var</span> distance = <span class=hljs-built_in>Math</span>.floor(<span class=hljs-built_in>Math</span>.sqrt(dx*dx + dy*dy));\\n    <span class=hljs-keyword>var</span> dashlineInteveral = (pattern &lt;= <span class=hljs-number>0</span>) ? distance : (distance/pattern);\\n    <span class=hljs-keyword>var</span> deltay = (dy/distance) * pattern;\\n    <span class=hljs-keyword>var</span> deltax = (dx/distance) * pattern;\\n\\n    <span class=hljs-comment>// draw dash line</span>\\n    <span class=hljs-keyword>this</span>.beginPath();\\n    <span class=hljs-keyword>var</span> f = <span class=hljs-number>1</span>;\\n    <span class=hljs-keyword>while</span> (dashlineInteveral--><span class=hljs-number>0</span>){\\n        <span class=hljs-keyword>if</span>(f) {\\n            <span class=hljs-keyword>this</span>.lineTo(fromX, fromY);\\n        } <span class=hljs-keyword>else</span> {\\n            <span class=hljs-keyword>this</span>.moveTo(fromX, fromY);\\n        }\\n        fromX += deltax; fromY += deltay; <span class=hljs-comment>// 增量法</span>\\n        f = <span class=hljs-number>1</span>-f;\\n    }\\n    <span class=hljs-keyword>this</span>.stroke();\\n};</code></pre><p>鼠标事件绑定处理</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>canvas.addEventListener(<span class=hljs-string>'mousedown'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e1</span>) </span>{\\n    <span class=hljs-keyword>var</span> p1 = <span class=hljs-keyword>new</span> Pos(e1.offsetX,e1.offsetY),c;\\n    [sP,cP1,cP2,eP].every(<span class=hljs-function><span class=hljs-params>ele</span>=></span>{\\n        <span class=hljs-keyword>if</span>(ele.around(p1)){\\n            c = ele;\\n            <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n        }\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;\\n    });\\n    <span class=hljs-keyword>if</span>(c){\\n        c.draw(<span class=hljs-string>'red'</span>);\\n        canvas.addEventListener(<span class=hljs-string>'mousemove'</span>,<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\\n            <span class=hljs-keyword>this</span>.mousemove = <span class=hljs-built_in>arguments</span>.callee;\\n            <span class=hljs-keyword>if</span>(e.buttons===<span class=hljs-number>1</span>){<span class=hljs-comment>// left mouse pressed down</span>\\n                <span class=hljs-keyword>var</span> pos = <span class=hljs-keyword>new</span> Pos(e.offsetX,e.offsetY);\\n                c.p = pos;\\n                rePaint([c]);\\n                c.draw(<span class=hljs-string>'red'</span>);\\n            }\\n        });\\n    }\\n})\\ncanvas.addEventListener(<span class=hljs-string>'mouseup'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\\n    <span class=hljs-keyword>this</span>.removeEventListener(<span class=hljs-string>'mousemove'</span>,<span class=hljs-keyword>this</span>.mousemove);\\n    rePaint();\\n});</code></pre><p><code>rePaint(ignores)</code> 重新绘制函数</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// ignores 为跳过不重绘的点(Circle/Rect)</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>rePaint</span>(<span class=hljs-params>ignores</span>)</span>{\\n    ctx.save();\\n    ctx.clearRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,canvas.width,canvas.height);\\n    <span class=hljs-keyword>if</span>(ignores==<span class=hljs-literal>null</span>){\\n        cP1.draw();\\n        cP2.draw();\\n        sP.draw();\\n        eP.draw();\\n    }\\n    <span class=hljs-keyword>else</span> {\\n        [sP,cP1,cP2,eP].forEach(<span class=hljs-function><span class=hljs-params>el</span>=></span>{\\n            <span class=hljs-keyword>if</span>(ignores.indexOf(el)==<span class=hljs-number>-1</span>)\\n                el.draw();\\n        });\\n    }\\n    drawBezier([sP.p,cP1.p,cP2.p,eP.p]);\\n    ctx.restore();\\n}</code></pre><h2 id=三维几何体的基本变换与组合变换应用><a href=#%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2%E5%BA%94%E7%94%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>三维几何体的基本变换与组合变换应用</h2><h3 id=介绍-3><a href=#%E4%BB%8B%E7%BB%8D-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>运用前端WebGL框架<a href=http://three.org>threejs</a>，结合相关矩阵变换知识完成。</p><h3 id=演示图片-3><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif4.gif alt=img width=1920 height=995><h3 id=代码解释-3><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p><a href=/htm/4%E4%B8%89%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A25%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2.doc>三维基本变换组合变换文档参考下载</a></p><ol><li><p>基本变换之平移变换 <img src=false alt=ClipboardImage width=586 height=156 data-src=http://obu9je6ng.bkt.clouddn.com/FlInRAsxX_jMvJHaZQvaKK0vF2O8?imageslim></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> matD = <span class=hljs-keyword>new</span> THREE.Matrix4();\\n<span class=hljs-comment>//thressjs 封装的API，产生平移变换矩阵</span>\\nmatD.makeTranslation(myctls[<span class=hljs-number>0</span>].x,myctls[<span class=hljs-number>0</span>].y,myctls[<span class=hljs-number>0</span>].z);\\n<span class=hljs-comment>// mesh为几何体，将其矩阵与平移变换矩阵相乘</span>\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>基本变换之比例变换 <img src=false alt=ClipboardImage width=531 height=141 data-src=http://obu9je6ng.bkt.clouddn.com/FpnmgsA3Km1IRwmog3nOD45TsJRb?imageslim></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>matD.makeScale(myctls[<span class=hljs-number>1</span>].x,myctls[<span class=hljs-number>1</span>].y,myctls[<span class=hljs-number>1</span>].z);\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>组合变换之关于任意向量旋转</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> v3 = myctls[<span class=hljs-number>2</span>].vector.toVector3();\\nmatD.makeRotationAxis(v3.normalize(),myctls[<span class=hljs-number>2</span>].degree/<span class=hljs-number>360</span>*<span class=hljs-built_in>Math</span>.PI)\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>...</p></li></ol><h1 id=总结><a href=#%E6%80%BB%E7%BB%93 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>总结</h1><ol><li>学习巩固了相关图形学的知识。</li><li>学习了相关前端技术对图形的处理方法。</li><li>对于WebGL简单入门了，以后可以往更酷炫的3D效果靠近。</li></ol>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// some-fegl-programs.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id=前言><a href=#%E5%89%8D%E8%A8%80 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>前言</h1><p>这是一篇不太正规的「计算机图形学论文」，其实论文谈不上，因为根本上不到研究的层次，就是自己瞎捣鼓。 主要介绍了几个与图形学相关的程序，皆采用前端技术实现，点击即可查看。</p><ul><li><a href=http://moyuyc.github.io/htm/painter/>简单的绘图程序</a></li><li><a href=http://moyuyc.github.io/2016/04/26/canvas%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E8%8A%B1%E7%93%A3/>三次贝赛尔曲线应用-绘制平面动态花瓣</a></li><li><a href=/htm/bezier.html>动态绘制三次贝赛尔曲线</a></li><li><a href=http://moyuyc.xyz/play_3d/play_3d_demo1.html>三维几何体的基本变换与组合变换应用</a></li></ul><!--more--><h1 id=主要内容><a href=#%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>主要内容</h1><h2 id=简单的绘图程序><a href=#%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%98%E5%9B%BE%E7%A8%8B%E5%BA%8F aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>简单的绘图程序</h2><h3 id=介绍><a href=#%E4%BB%8B%E7%BB%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>主要运用HTML5 canvas API与相关图形学知识实现的绘图程序（还包括部分图像处理功能，不介绍）。 能够选择图形类型（Pen/Line/Circle）,画笔颜色（随机生成）,画笔宽度, 图形对象拖拽移动，图形种子填充算法。</p><h3 id=演示图片><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif1.gif alt=img width=1142 height=747><h3 id=代码解释><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p><code>Shape.js ： 主要包含一些图形类</code></p><p>点类代码</p><pre><code data-query={} data-lang>Point: function (x, y) {\\n    this.x = x;\\n    this.y = y;\\n    this.distance = function (p) {\\n        p = p?p:new Shape.Point(0,0);\\n        return Math.sqrt(Math.pow(p.x-this.x,2)+Math.pow(p.y-this.y,2));\\n    };\\n    this.move = function(offsetX,offsetY){\\n        this.x+=offsetX;this.y+=offsetY;\\n    };\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        paint.strokeStyle = this.color ? this.color : 'black';\\n        paint.lineWidth = this.linewidth!=null ? this.linewidth : 1;\\n        paint.beginPath();\\n        paint.moveTo(this.x, this.y);\\n        paint.lineTo(this.x + 1, this.y + 1);\\n        paint.stroke();\\n        paint.save();\\n        return this;\\n    }\\n}\\n</code></pre><p>线段类代码</p><pre><code data-query={} data-lang>Line: function (p1, p2) {\\n    this.sp = p1;\\n    this.ep = p2;\\n    //this.color;this.linewidth;\\n    this.move = function(offsetX,offsetY){\\n        this.sp.x+=offsetX;this.sp.y+=offsetY;\\n        this.ep.x+=offsetX;this.ep.y+=offsetY;\\n    };\\n    // 不足：未考虑线宽，用户较难选中\\n    this.isIn = function (point) {\\n        var x = point.x, y = point.y;\\n        if((y-this.sp.y)*(x-this.ep.x)==(y-this.ep.y)*(x-this.sp.x))\\n            return true;\\n        return false;\\n    };\\n    // 中点划线法\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth!=null?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        var ep = this.ep, sp = this.sp,\\n            dX = ep.x - sp.x,\\n            dY = ep.y - sp.y,\\n            a = sp.y - ep.y,\\n            b = ep.x - sp.x;\\n        if (Math.abs(dX) >= Math.abs(dY)) {\\n            if (dX >= 0 &amp&amp dY >= 0) {\\n                var d = b + 2 * a, d1 = 2 * a, d2 = 2 * (a + b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x + 1, y = sp.y; x &lt; ep.x; x++) {\\n                    if (d >= 0) d = d + d1;\\n                    else {\\n                        y++;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX >= 0 &amp&amp dY &lt;= 0) {\\n                var d = -b + a &lt;&lt; 1, d1 = (a - b) &lt;&lt; 1, d2 = a &lt;&lt; 1;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x + 1, y = sp.y; x &lt; ep.x; x++) {\\n                    if (d >= 0) {\\n                        y--;\\n                        d = d + d1;\\n                    }\\n                    else d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX &lt;= 0 &amp&amp dY &lt;= 0) {\\n                var d = -b - 2 * a, d1 = -2 * a, d2 = -2 * (a + b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\\n                    if (d >= 0) d = d + d1;\\n                    else {\\n                        y--;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else {\\n                var d = b - 2 * a, d1 = 2 * (b - a), d2 = -2 * a;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x - 1, y = sp.y; x > ep.x; x--) {\\n                    if (d >= 0) {\\n                        y++;\\n                        d = d + d1;\\n                    }\\n                    else d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n        }\\n        else {\\n            if (dX >= 0 &amp&amp dY >= 0) {\\n                var d = a + 2 * b, d1 = 2 * (a + b), d2 = 2 * b;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y + 1; y &lt; ep.y; y++) {\\n                    if (d >= 0) {\\n                        x++;\\n                        d = d + d1;\\n                    }\\n                    else {\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n            else if (dX >= 0 &amp&amp dY &lt;= 0) {\\n                var d = a - 2 * b, d1 = -2 * b, d2 = 2 * (a - b);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\\n                    if (d >= 0)      d = d + d1;\\n                    else {\\n                        x++;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n\\n            }\\n            else if (dX &lt;= 0 &amp&amp dY &lt;= 0) {\\n                var d = -a - 2 * b, d1 = -2 * (a + b), d2 = -2 * b;\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y - 1; y > ep.y; y--) {\\n                    if (d >= 0) {\\n                        x--;\\n                        d = d + d1;\\n                    }\\n                    else               d = d + d2;\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n\\n            }\\n            else {\\n                var d = -a + 2 * b, d1 = 2 * b, d2 = 2 * (b - a);\\n                new Shape.Point(sp.x, sp.y).draw(paint, color, linewidth);\\n                for (var x = sp.x, y = sp.y + 1; y &lt; ep.y; y++) {\\n                    if (d >= 0)           d = d + d1;\\n                    else {\\n                        x--;\\n                        d = d + d2;\\n                    }\\n                    new Shape.Point(x, y).draw(paint, color, linewidth);\\n                }\\n            }\\n        }\\n        return this;\\n    }\\n}\\n</code></pre><p>圆类代码</p><pre><code data-query={} data-lang>Circle: function (cp, r) {\\n    this.cp = cp;\\n    this.r = r;\\n    this.move = function(offsetX,offsetY){\\n        this.cp.x+=offsetX;this.cp.y+=offsetY;\\n    };\\n    //this.color;this.linewidth;\\n    this.isIn = function (point) {\\n        var x = point.x, y = point.y;\\n        return (x-this.cp.x)*(x-this.cp.x)+(y-this.cp.y)*(y-this.cp.y)&lt;=this.r*this.r;\\n    };\\n    // 八分法画圆\\n    this.draw = function (paint, color, linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        //console.log(color);\\n        var r = this.r, cp = this.cp,\\n            d = 1 - r, p = new Shape.Point(0, r);\\n        while (p.x &lt;= p.y) {\\n            new Shape.Point(cp.x + p.x, cp.y + p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.x, cp.y - p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.x, cp.y + p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.x, cp.y - p.y).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.y, cp.y + p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x + p.y, cp.y - p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.y, cp.y + p.x).draw(paint, color, linewidth);\\n            new Shape.Point(cp.x - p.y, cp.y - p.x).draw(paint, color, linewidth);\\n            p.x++;\\n            if (d &lt; 0) d = d + 2 * p.x + 1;\\n            else {\\n                p.y--;\\n                d = d + 2 * p.x - 2 * p.y + 1;\\n            }\\n        }\\n        return this;\\n    };\\n    //种子填充算法 深度优先搜索，基于栈，isam表示是否含动画填充效果\\n    this.dfsFill = function (paint,p,color,isam) {\\n        isam = isam || false;\\n        var stack = [p],hashmap = {},container=[];\\n        while (stack.length !== 0){\\n            p = stack.pop();\\n            if(isam)\\n                container.push(p);\\n            else\\n                p.draw(paint,color);\\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\\n                .forEach(ele=>{\\n                    if(this.isIn(ele) &amp&amp !hashmap[ele]) {\\n                        stack.push(ele);\\n                        hashmap[ele] = hashmap[ele]+1 || 0;\\n                    }\\n                });\\n        }\\n        console.log(hashmap);\\n        if(isam) {\\n            var animate = requestAnimationFrame;\\n            animate(function () {\\n                if (!container.length) return;\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                animate(arguments.callee);\\n            })\\n        }\\n    };\\n    //种子填充算法 广度优先搜索，基于队列。\\n    this.bfsFill = function (paint,p,color,isam) {\\n        isam = isam || false;\\n        var queue = [p],hashmap = {},container=[];\\n        while (queue.length !== 0){\\n            p = queue.shift();\\n            if(isam)\\n                container.push(p);\\n            else\\n                p.draw(paint,color);\\n            [new Shape.Point(p.x,p.y-1), new Shape.Point(p.x-1,p.y), new Shape.Point(p.x,p.y+1), new Shape.Point(p.x+1,p.y)]\\n                .forEach(ele=>{\\n                    if(this.isIn(ele) &amp&amp !hashmap[ele]) {\\n                        queue.push(ele);\\n                        hashmap[ele] = hashmap[ele]+1 || 0;\\n                    }\\n                });\\n        }\\n        console.log(hashmap);\\n        if(isam) {\\n            var animate = requestAnimationFrame;\\n            animate(function () {\\n                if (!container.length) return;\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                container.shift().draw(paint, color);container.shift().draw(paint, color);\\n                animate(arguments.callee);\\n            })\\n        }\\n    }\\n}\\n</code></pre><p>路径类代码</p><pre><code data-query={} data-lang>Path: function (points) {\\n    this.ps = points;\\n    this.move = function(offsetX,offsetY){\\n        for(var i = 0;i&lt;this.ps.length;i++){\\n            this.ps[i].x+=offsetX;\\n            this.ps[i].y+=offsetY;\\n        }\\n    };\\n    this.isIn = function (point) {\\n        var p = this.ps[0];\\n        for(var i=1;i&lt;this.ps.length;i++){\\n            if(new Shape.Line(p,this.ps[i]).isIn(point))\\n                return true;\\n            p = this.ps[i];\\n        }\\n        return false;\\n    };\\n    // 调用canvas提供的api\\n    this.draw = function (paint,color,linewidth) {\\n        this.color = color?color:this.color;\\n        this.linewidth = linewidth?linewidth:this.linewidth;\\n        color = this.color; linewidth = this.linewidth;\\n        //console.log(color);\\n        var arr = this.ps;\\n        if(arr.length==0)  return;\\n        paint.beginPath();\\n        paint.strokeStyle = color ? color : 'black';\\n        paint.lineWidth = linewidth ? linewidth : 1;\\n        paint.moveTo(arr[0].x,arr[0].y);\\n        for(var i =1;i&lt;arr.length;i++){\\n            paint.lineTo(arr[i].x,arr[i].y);\\n        }\\n        paint.stroke();\\n        return this;\\n    }\\n}\\n</code></pre><p><code>canvas.js: 包含其他一些对事件的绑定或者对控件的控制等代码</code></p><p>选中图形进行拖动函数</p><pre><code data-query={} data-lang>dragMoveHandle = function () {\\n    var f1 = function(e){\\n    var x = e.offsetX, y = e.offsetY;\\n    var v = Tool.getInFirstShape(new Shape.Point(x,y));\\n    if(v){\\n    var f2 = function (e2) {\\n        if(e2.buttons==1){\\n        var offsetx = e2.offsetX-x, offsety = e2.offsetY-y;\\n        x=e2.offsetX; y = e2.offsetY;\\n        v.move(offsetx,offsety);\\n        Tool.refresh();\\n        }\\n    },f3 = function (e3) {\\n        var offsetx = e3.offsetX-x, offsety = e3.offsetY-y;\\n        v.move(offsetx,offsety);\\n        Tool.refresh();\\n        // e3.stopPropagation();\\n        $(this).off('mousemove',f2).off('mouseup',f3);\\n    };\\n    $(paint.canvas).on('mousemove',f2).on('mouseup',f3).off('mousedown',f1);\\n    }else\\n    $('[role=opType-item]').removeClass('active');\\n}\\n$(paint.canvas).on('mousedown',f1)\\n}\\n</code></pre><p>关于Tool对象</p><pre><code data-query={} data-lang>Tool = {\\n    getInFirstShape : function(p){\\n        var f = function(d){\\n            for(var i =0;i&lt; d.length;i++){\\n                if(d[i].isIn(p))//点p是否在d[i]图形对象中？\\n                    return d[i];\\n            }\\n            return false;\\n        };\\n        var r;\\n        for(var d in paint.data)\\n            //paint.data 表示存在于画布中的所有图形对象\\n            if((r=f(paint.data[d]))!=false)\\n                return r;\\n    },\\n    // 重新绘制\\n    refresh : function () {\\n        paint.clearRect(0,0,paint.canvas.width,paint.canvas.height);\\n        for(var i =0;i&lt;paint.data.Paths.length;i++)\\n            paint.data.Paths[i].draw(paint);\\n        for(var i =0;i&lt;paint.data.Lines.length;i++)\\n            paint.data.Lines[i].draw(paint);\\n        for(var i =0;i&lt;paint.data.Circles.length;i++)\\n            paint.data.Circles[i].draw(paint);\\n    }\\n}\\n</code></pre><h3 id=不足之处><a href=#%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>不足之处</h3><ol><li>对于<code>Line</code>的<code>isIn</code>方法，未考虑到线宽的因素，用户很难准确选中线段</li><li>对于拖动图形的事件处理逻辑较复杂。</li><li>对于图形类中未使用到<code>js</code>中的原型与原型继承，降低了代码复用度。</li></ol><h2 id=三次贝赛尔曲线应用-绘制平面动态花瓣><a href=#%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%BA%94%E7%94%A8-%E7%BB%98%E5%88%B6%E5%B9%B3%E9%9D%A2%E5%8A%A8%E6%80%81%E8%8A%B1%E7%93%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>三次贝赛尔曲线应用-绘制平面动态花瓣</h2><h3 id=介绍-1><a href=#%E4%BB%8B%E7%BB%8D-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>主要运用HTML5 canvas API与相关图形学知识实现的平面动态花瓣绘制。</p><h3 id=演示图片-1><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif2.gif alt=img width=992 height=604><h3 id=代码解释-1><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><ul><li>核心代码</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Flower</span>(<span class=hljs-params>c,petals,size,x,y,rotate</span>)</span>{\\n\\t<span class=hljs-keyword>this</span>.c = c || [<span class=hljs-number>255</span>,<span class=hljs-number>255</span>,<span class=hljs-number>255</span>];\\n\\t<span class=hljs-keyword>this</span>.petals = petals || <span class=hljs-number>4</span>;\\n\\t<span class=hljs-keyword>this</span>.size = size || <span class=hljs-number>5</span>;\\n\\t<span class=hljs-keyword>this</span>.x = x || <span class=hljs-number>0</span>;\\n\\t<span class=hljs-keyword>this</span>.y = y || <span class=hljs-number>0</span>;\\n\\t<span class=hljs-keyword>this</span>.rotate = rotate || <span class=hljs-number>0</span>;\\n}\\nFlower.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n\\t<span class=hljs-keyword>var</span> _rad = <span class=hljs-keyword>this</span>.size,_num_pts=<span class=hljs-keyword>this</span>.petals,_x=<span class=hljs-keyword>this</span>.x,_y=<span class=hljs-keyword>this</span>.y,c=<span class=hljs-keyword>this</span>.c;\\n\\tctx.save();\\n\\tctx.shadowBlur = <span class=hljs-number>30</span>; <span class=hljs-comment>//阴影程度</span>\\n\\tctx.lineWidth = <span class=hljs-number>1</span>;\\n\\tctx.shadowColor = utils.rgba(c[<span class=hljs-number>0</span>],c[<span class=hljs-number>1</span>],c[<span class=hljs-number>2</span>],<span class=hljs-number>1</span>); <span class=hljs-comment>//阴影颜色</span>\\n\\tctx.fillStyle = utils.rgba(c[<span class=hljs-number>0</span>],c[<span class=hljs-number>1</span>],c[<span class=hljs-number>2</span>],<span class=hljs-number>.6</span>); <span class=hljs-comment>//填充颜色</span>\\n\\tc2 = c.map(<span class=hljs-function>(<span class=hljs-params>x</span>)=></span><span class=hljs-built_in>Math</span>.floor(x/<span class=hljs-number>1.6</span>));           <span class=hljs-comment>//lambda表达式写法</span>\\n\\tctx.strokeStyle = utils.rgba(c2[<span class=hljs-number>0</span>],c2[<span class=hljs-number>1</span>],c2[<span class=hljs-number>2</span>],<span class=hljs-number>1</span>);  <span class=hljs-comment>//边框颜色</span>\\n\\t<span class=hljs-keyword>var</span> pts = [];\\n\\t<span class=hljs-keyword>var</span> _a = <span class=hljs-keyword>this</span>.rotate+(tick*<span class=hljs-number>1</span>);\\n\\t<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span> ; i &lt;= _num_pts ; i++){<span class=hljs-comment>//增量法提高效率</span>\\n\\t\\tpts.push({<span class=hljs-attr>x</span>:utils.P2L(_rad, _a).x,<span class=hljs-attr>y</span>:utils.P2L(_rad, _a).y}); <span class=hljs-comment>//P2L将极坐标转换为平面坐标</span>\\n\\t\\t_a += (<span class=hljs-number>360</span>/_num_pts);\\n\\t}\\n\\t<span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>1</span> ; i&lt;= _num_pts; i+=<span class=hljs-number>2</span>){\\n\\t\\tidx= i%_num_pts;\\n\\t\\tctx.beginPath();<span class=hljs-comment>//开始绘制</span>\\n\\t\\tctx.moveTo(_x,_y);<span class=hljs-comment>//起点为(_x,_y)</span>\\n\\t\\tctx.bezierCurveTo(_x+pts[i<span class=hljs-number>-1</span>].x,_y+pts[i<span class=hljs-number>-1</span>].y,_x+pts[idx+<span class=hljs-number>1</span>].x,_y+pts[idx+<span class=hljs-number>1</span>].y,_x,_y);<span class=hljs-comment>//绘制贝塞尔曲线</span>\\n\\t\\tctx.stroke();<span class=hljs-comment>//闭合图形边框</span>\\n\\t\\tctx.fill();<span class=hljs-comment>//填充图形</span>\\n\\t}\\n\\tctx.restore();\\n}\\nHTMLCanvasElement.prototype.magicBg = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n\\t<span class=hljs-keyword>var</span> ctx = <span class=hljs-keyword>this</span>.getContext(<span class=hljs-string>'2d'</span>);\\n\\t<span class=hljs-keyword>if</span>(!<span class=hljs-keyword>this</span>.grd){\\n\\t\\t<span class=hljs-comment>//实现从画布中心往外呈圆形扩散，渐变。</span>\\n\\t\\t<span class=hljs-keyword>this</span>.grd=ctx.createRadialGradient(<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>,<span class=hljs-built_in>Math</span>.min(<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height)/<span class=hljs-number>1.2</span>);\\n\\t\\t<span class=hljs-keyword>this</span>.grd.addColorStop(<span class=hljs-number>0</span>,<span class=hljs-string>\\\"rgba(255,255,255,.25)\\\"</span>);\\n\\t\\t<span class=hljs-keyword>this</span>.grd.addColorStop(<span class=hljs-number>1</span>,<span class=hljs-keyword>this</span>.utils.rgba(<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>200</span>+<span class=hljs-keyword>this</span>.utils.randomInt(<span class=hljs-number>56</span>),<span class=hljs-number>.65</span>));\\n\\t}\\n\\tctx.save();\\n\\tctx.clearRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height);\\n\\tctx.fillStyle = <span class=hljs-keyword>this</span>.grd;\\n\\tctx.fillRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,<span class=hljs-keyword>this</span>.width,<span class=hljs-keyword>this</span>.height);\\n\\tctx.restore();\\n}</code></pre><ul><li>Flower对象解释</li></ul><table><thead><tr><th>参数</th><th>说明</th><th>默认</th><th>类型</th></tr></thead><tbody><tr><td><code>c</code></td><td>花瓣的颜色</td><td>[255,255,255]</td><td>Array</td></tr><tr><td><code>petals</code></td><td>花瓣个数</td><td>4</td><td>Number</td></tr><tr><td><code>size</code></td><td>半径大小</td><td>5</td><td>Number</td></tr><tr><td><code>x</code></td><td>中心 x 坐标</td><td>0</td><td>Number</td></tr><tr><td><code>y</code></td><td>中心 y 坐标</td><td>0</td><td>Number</td></tr><tr><td><code>rotate</code></td><td>绕中心旋转角度</td><td>0</td><td>Number(单位：度)</td></tr></tbody></table><ul><li><code>Flower.draw</code> 方法解释</li></ul><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td><code>_rad</code></td><td>radix，对应<code>size</code></td></tr><tr><td><code>_num_pts</code></td><td>对应<code>petals</code></td></tr><tr><td><code>_x</code></td><td>对应<code>x</code></td></tr><tr><td><code>_y</code></td><td>对应<code>y</code></td></tr><tr><td><code>c</code></td><td>对应<code>c</code></td></tr></tbody></table><ul><li>关于贝塞尔曲线，<a href=http://bbs.csdn.net/topics/390358020>参考资料</a></li></ul><img src=/images/bezier3.gif alt=IMG width=240 height=100><center>图：三次贝塞尔曲线动态绘制效果</center><img src=false alt=ClipboardImage width=746 height=725 data-src=http://obu9je6ng.bkt.clouddn.com/FqrMRZZXMInLzy27Mc6CCWwHrC_v?imageslim><center>图：花瓣与其贝塞尔曲线控制点</center>- 怎么使用？ 1. `<script src=drawflower.js></script>` 2. `canvas.drawFlower(option);`<pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>//default option</span>\\n{\\n\\t<span class=hljs-attr>animate</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>rotate</span>:<span class=hljs-number>90</span>,\\n\\t<span class=hljs-attr>randomSize</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>randomColor</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>randomPetals</span>: <span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>pos</span>:{\\n\\t\\t<span class=hljs-attr>x</span>:<span class=hljs-keyword>this</span>.width/<span class=hljs-number>2</span>,\\n\\t\\t<span class=hljs-attr>y</span>:<span class=hljs-keyword>this</span>.height/<span class=hljs-number>2</span>\\n\\t}\\n}</code></pre><p>or</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>{\\n\\t<span class=hljs-attr>animate</span>:<span class=hljs-literal>true</span>,\\n\\t<span class=hljs-attr>rotate</span>:<span class=hljs-number>-20</span>,\\n\\t<span class=hljs-attr>randomSize</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>size</span>:<span class=hljs-number>10</span>,\\n\\t<span class=hljs-attr>randomColor</span>:<span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>color</span>:[<span class=hljs-number>100</span>,<span class=hljs-number>100</span>,<span class=hljs-number>100</span>],\\n\\t<span class=hljs-attr>randomPetals</span>: <span class=hljs-literal>false</span>,\\n\\t<span class=hljs-attr>petals</span>:<span class=hljs-number>6</span>,\\n\\t<span class=hljs-attr>pos</span>:{\\n\\t\\t<span class=hljs-attr>x</span>:<span class=hljs-number>0</span>,\\n\\t\\t<span class=hljs-attr>y</span>:<span class=hljs-number>0</span>\\n\\t}\\n}</code></pre><h2 id=动态绘制三次贝赛尔曲线><a href=#%E5%8A%A8%E6%80%81%E7%BB%98%E5%88%B6%E4%B8%89%E6%AC%A1%E8%B4%9D%E8%B5%9B%E5%B0%94%E6%9B%B2%E7%BA%BF aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>动态绘制三次贝赛尔曲线</h2><h3 id=介绍-2><a href=#%E4%BB%8B%E7%BB%8D-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>应用canvas API, 事件绑定, 达到动态绘制三次贝赛尔曲线效果。</p><h3 id=演示图片-2><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif3.gif alt=img width=792 height=649><h3 id=代码解释-2><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p>自己定义的<code>Pos</code> <code>Rect</code> <code>Circle</code> 类</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Pos</span>(<span class=hljs-params>x,y</span>)</span>{<span class=hljs-keyword>this</span>.x=x;<span class=hljs-keyword>this</span>.y=y;}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Circle</span>(<span class=hljs-params>p,r</span>)</span>{<span class=hljs-keyword>this</span>.p=p;<span class=hljs-keyword>this</span>.r=r;}\\nCircle.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>sty</span>)</span>{\\n    ctx.save();\\n    ctx.strokeStyle=sty||<span class=hljs-string>'blue'</span>;\\n    ctx.beginPath();\\n    ctx.arc(<span class=hljs-keyword>this</span>.p.x, <span class=hljs-keyword>this</span>.p.y, <span class=hljs-keyword>this</span>.r, <span class=hljs-number>0</span>, <span class=hljs-built_in>Math</span>.PI * <span class=hljs-number>2</span>, <span class=hljs-literal>true</span>);\\n    ctx.stroke();\\n    ctx.restore();\\n}\\n<span class=hljs-comment>// p is in Circle?</span>\\nCircle.prototype.around=<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>p</span>)</span>{\\n    <span class=hljs-keyword>return</span> (p.x-<span class=hljs-keyword>this</span>.p.x)*(p.x-<span class=hljs-keyword>this</span>.p.x)+ (p.y-<span class=hljs-keyword>this</span>.p.y)*(p.y-<span class=hljs-keyword>this</span>.p.y)&lt;=<span class=hljs-keyword>this</span>.r*<span class=hljs-keyword>this</span>.r;\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Rect</span>(<span class=hljs-params>p,w,h</span>)</span>{<span class=hljs-keyword>this</span>.p=p;<span class=hljs-keyword>this</span>.w=w;<span class=hljs-keyword>this</span>.h=h;};\\nRect.prototype.draw = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>style</span>) </span>{\\n    ctx.save();\\n    ctx.strokeStyle=style||<span class=hljs-string>'blue'</span>;\\n    <span class=hljs-keyword>var</span> v = <span class=hljs-keyword>this</span>.w>>> <span class=hljs-number>1</span>,t = <span class=hljs-keyword>this</span>.h>>><span class=hljs-number>1</span>;\\n    ctx.strokeRect(<span class=hljs-keyword>this</span>.p.x-v, <span class=hljs-keyword>this</span>.p.y-t,<span class=hljs-keyword>this</span>.w,<span class=hljs-keyword>this</span>.h);\\n    ctx.restore();\\n}\\n<span class=hljs-comment>// p is in Rect?</span>\\nRect.prototype.around = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>p</span>) </span>{\\n    <span class=hljs-keyword>var</span> v = <span class=hljs-keyword>this</span>.w>>> <span class=hljs-number>1</span>,t = <span class=hljs-keyword>this</span>.h>>><span class=hljs-number>1</span>;\\n    <span class=hljs-keyword>return</span> p.x>=<span class=hljs-keyword>this</span>.p.x-v &amp&amp p.x&lt;=<span class=hljs-keyword>this</span>.p.x+v &amp&amp p.y>=<span class=hljs-keyword>this</span>.p.y-t &amp&amp p.y&lt;=<span class=hljs-keyword>this</span>.p.y+t;\\n}</code></pre><p>初始化</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> midP = <span class=hljs-keyword>new</span> Pos(<span class=hljs-built_in>window</span>.innerWidth>>><span class=hljs-number>1</span>,<span class=hljs-built_in>window</span>.innerHeight>>><span class=hljs-number>1</span>),\\n    sP = <span class=hljs-keyword>new</span> Circle(<span class=hljs-keyword>new</span> Pos(midP.x<span class=hljs-number>-100</span>,midP.y<span class=hljs-number>-100</span>),<span class=hljs-number>4</span>),\\n    cP1= <span class=hljs-keyword>new</span> Rect(<span class=hljs-keyword>new</span> Pos(midP.x<span class=hljs-number>-80</span>,midP.y+<span class=hljs-number>10</span>),<span class=hljs-number>8</span>,<span class=hljs-number>8</span>),\\n    cP2= <span class=hljs-keyword>new</span> Rect(<span class=hljs-keyword>new</span> Pos(midP.x+<span class=hljs-number>80</span>,midP.y+<span class=hljs-number>20</span>),<span class=hljs-number>8</span>,<span class=hljs-number>8</span>),\\n    eP = <span class=hljs-keyword>new</span> Circle(<span class=hljs-keyword>new</span> Pos(midP.x+<span class=hljs-number>100</span>,midP.y+<span class=hljs-number>100</span>),<span class=hljs-number>4</span>);</code></pre><p>绘制三次贝塞尔曲线</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>drawBezier</span>(<span class=hljs-params>ps</span>)</span>{\\n    ctx.save();\\n    ctx.beginPath();\\n    ctx.moveTo(ps[<span class=hljs-number>0</span>].x,ps[<span class=hljs-number>0</span>].y);\\n    ctx.bezierCurveTo(ps[<span class=hljs-number>1</span>].x,ps[<span class=hljs-number>1</span>].y,ps[<span class=hljs-number>2</span>].x,ps[<span class=hljs-number>2</span>].y,ps[<span class=hljs-number>3</span>].x,ps[<span class=hljs-number>3</span>].y);\\n    ctx.stroke();\\n    <span class=hljs-comment>// 自己实现的绘制虚线方法</span>\\n    ctx.dashedLineTo(ps[<span class=hljs-number>0</span>].x,ps[<span class=hljs-number>0</span>].y,ps[<span class=hljs-number>1</span>].x,ps[<span class=hljs-number>1</span>].y);\\n    ctx.dashedLineTo(ps[<span class=hljs-number>3</span>].x,ps[<span class=hljs-number>3</span>].y,ps[<span class=hljs-number>2</span>].x,ps[<span class=hljs-number>2</span>].y);\\n    ctx.restore();\\n}</code></pre><p><code>ctx.dashedLineTo</code>方法</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>CanvasRenderingContext2D.prototype.dashedLineTo = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>fromX, fromY, toX, toY, pattern</span>) </span>{\\n    <span class=hljs-comment>// default interval distance -> 5px</span>\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> pattern === <span class=hljs-string>\\\"undefined\\\"</span>) {\\n        pattern = <span class=hljs-number>5</span>;\\n    }\\n    <span class=hljs-comment>// calculate the delta x and delta y</span>\\n    <span class=hljs-keyword>var</span> dx = (toX - fromX);\\n    <span class=hljs-keyword>var</span> dy = (toY - fromY);\\n    <span class=hljs-keyword>var</span> distance = <span class=hljs-built_in>Math</span>.floor(<span class=hljs-built_in>Math</span>.sqrt(dx*dx + dy*dy));\\n    <span class=hljs-keyword>var</span> dashlineInteveral = (pattern &lt;= <span class=hljs-number>0</span>) ? distance : (distance/pattern);\\n    <span class=hljs-keyword>var</span> deltay = (dy/distance) * pattern;\\n    <span class=hljs-keyword>var</span> deltax = (dx/distance) * pattern;\\n\\n    <span class=hljs-comment>// draw dash line</span>\\n    <span class=hljs-keyword>this</span>.beginPath();\\n    <span class=hljs-keyword>var</span> f = <span class=hljs-number>1</span>;\\n    <span class=hljs-keyword>while</span> (dashlineInteveral--><span class=hljs-number>0</span>){\\n        <span class=hljs-keyword>if</span>(f) {\\n            <span class=hljs-keyword>this</span>.lineTo(fromX, fromY);\\n        } <span class=hljs-keyword>else</span> {\\n            <span class=hljs-keyword>this</span>.moveTo(fromX, fromY);\\n        }\\n        fromX += deltax; fromY += deltay; <span class=hljs-comment>// 增量法</span>\\n        f = <span class=hljs-number>1</span>-f;\\n    }\\n    <span class=hljs-keyword>this</span>.stroke();\\n};</code></pre><p>鼠标事件绑定处理</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>canvas.addEventListener(<span class=hljs-string>'mousedown'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e1</span>) </span>{\\n    <span class=hljs-keyword>var</span> p1 = <span class=hljs-keyword>new</span> Pos(e1.offsetX,e1.offsetY),c;\\n    [sP,cP1,cP2,eP].every(<span class=hljs-function><span class=hljs-params>ele</span>=></span>{\\n        <span class=hljs-keyword>if</span>(ele.around(p1)){\\n            c = ele;\\n            <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\\n        }\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;\\n    });\\n    <span class=hljs-keyword>if</span>(c){\\n        c.draw(<span class=hljs-string>'red'</span>);\\n        canvas.addEventListener(<span class=hljs-string>'mousemove'</span>,<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\\n            <span class=hljs-keyword>this</span>.mousemove = <span class=hljs-built_in>arguments</span>.callee;\\n            <span class=hljs-keyword>if</span>(e.buttons===<span class=hljs-number>1</span>){<span class=hljs-comment>// left mouse pressed down</span>\\n                <span class=hljs-keyword>var</span> pos = <span class=hljs-keyword>new</span> Pos(e.offsetX,e.offsetY);\\n                c.p = pos;\\n                rePaint([c]);\\n                c.draw(<span class=hljs-string>'red'</span>);\\n            }\\n        });\\n    }\\n})\\ncanvas.addEventListener(<span class=hljs-string>'mouseup'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{\\n    <span class=hljs-keyword>this</span>.removeEventListener(<span class=hljs-string>'mousemove'</span>,<span class=hljs-keyword>this</span>.mousemove);\\n    rePaint();\\n});</code></pre><p><code>rePaint(ignores)</code> 重新绘制函数</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-comment>// ignores 为跳过不重绘的点(Circle/Rect)</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>rePaint</span>(<span class=hljs-params>ignores</span>)</span>{\\n    ctx.save();\\n    ctx.clearRect(<span class=hljs-number>0</span>,<span class=hljs-number>0</span>,canvas.width,canvas.height);\\n    <span class=hljs-keyword>if</span>(ignores==<span class=hljs-literal>null</span>){\\n        cP1.draw();\\n        cP2.draw();\\n        sP.draw();\\n        eP.draw();\\n    }\\n    <span class=hljs-keyword>else</span> {\\n        [sP,cP1,cP2,eP].forEach(<span class=hljs-function><span class=hljs-params>el</span>=></span>{\\n            <span class=hljs-keyword>if</span>(ignores.indexOf(el)==<span class=hljs-number>-1</span>)\\n                el.draw();\\n        });\\n    }\\n    drawBezier([sP.p,cP1.p,cP2.p,eP.p]);\\n    ctx.restore();\\n}</code></pre><h2 id=三维几何体的基本变换与组合变换应用><a href=#%E4%B8%89%E7%BB%B4%E5%87%A0%E4%BD%95%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2%E5%BA%94%E7%94%A8 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>三维几何体的基本变换与组合变换应用</h2><h3 id=介绍-3><a href=#%E4%BB%8B%E7%BB%8D-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>介绍</h3><p>运用前端WebGL框架<a href=http://three.org>threejs</a>，结合相关矩阵变换知识完成。</p><h3 id=演示图片-3><a href=#%E6%BC%94%E7%A4%BA%E5%9B%BE%E7%89%87-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>演示图片</h3><img src=/images/gif4.gif alt=img width=1920 height=995><h3 id=代码解释-3><a href=#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>代码解释</h3><p><a href=/htm/4%E4%B8%89%E7%BB%B4%E5%9F%BA%E6%9C%AC%E5%8F%98%E6%8D%A25%E7%BB%84%E5%90%88%E5%8F%98%E6%8D%A2.doc>三维基本变换组合变换文档参考下载</a></p><ol><li><p>基本变换之平移变换 <img src=false alt=ClipboardImage width=586 height=156 data-src=http://obu9je6ng.bkt.clouddn.com/FlInRAsxX_jMvJHaZQvaKK0vF2O8?imageslim></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> matD = <span class=hljs-keyword>new</span> THREE.Matrix4();\\n<span class=hljs-comment>//thressjs 封装的API，产生平移变换矩阵</span>\\nmatD.makeTranslation(myctls[<span class=hljs-number>0</span>].x,myctls[<span class=hljs-number>0</span>].y,myctls[<span class=hljs-number>0</span>].z);\\n<span class=hljs-comment>// mesh为几何体，将其矩阵与平移变换矩阵相乘</span>\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>基本变换之比例变换 <img src=false alt=ClipboardImage width=531 height=141 data-src=http://obu9je6ng.bkt.clouddn.com/FpnmgsA3Km1IRwmog3nOD45TsJRb?imageslim></p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>matD.makeScale(myctls[<span class=hljs-number>1</span>].x,myctls[<span class=hljs-number>1</span>].y,myctls[<span class=hljs-number>1</span>].z);\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>组合变换之关于任意向量旋转</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>var</span> v3 = myctls[<span class=hljs-number>2</span>].vector.toVector3();\\nmatD.makeRotationAxis(v3.normalize(),myctls[<span class=hljs-number>2</span>].degree/<span class=hljs-number>360</span>*<span class=hljs-built_in>Math</span>.PI)\\nmesh.matrix.multiply(matD);</code></pre></li><li><p>...</p></li></ol><h1 id=总结><a href=#%E6%80%BB%E7%BB%93 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>总结</h1><ol><li>学习巩固了相关图形学的知识。</li><li>学习了相关前端技术对图形的处理方法。</li><li>对于WebGL简单入门了，以后可以往更酷炫的3D效果靠近。</li></ol>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/some-fegl-programs.md\n// module id = 1233\n// module chunks = 32"],"sourceRoot":""}