webpackJsonp([52,90],{1011:function(s,n){s.exports={content:'<p>今天，来小结一下纠结我几个小时的linux C。需求是这样的，<em>用c实现tcp的文件上传与下载</em></p>\n<p>一开始，很容易想到的上传思路是，直接在内存中开一块<code>buffer</code>，得到一个<code>file description</code>后，进行一读一发。</p>\n<!--more-->\n<pre><code class="hljs language-c" data-query="{}" data-lang="c"><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">1024</span>];\n<span class="hljs-keyword">int</span> fd = open(path, O_RDONLY);\n<span class="hljs-keyword">int</span> n = read(fd, buffer, <span class="hljs-number">1024</span>);\n<span class="hljs-keyword">if</span>(n&#x3C;<span class="hljs-number">0</span>) {\n    perror(<span class="hljs-string">"read"</span>);\n}\nbuffer[n] = <span class="hljs-number">0</span>;\n\nwrite(socket, buffer, n);\n\n<span class="hljs-comment">//...</span></code></pre>\n<p><strong>然而，其实在linux内核中已经实现了一种更为高效的方法，<code>sendfile</code></strong><br>\n不需要频繁的调用<code>read/write</code>,也不需要开辟buffer，减少了内核函数的调用，提高性能。</p>\n<h2 id="函数说明"><a href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E" aria-hidden="true"><span class="icon icon-link"></span></a>函数说明</h2>\n<ul>\n<li>\n<p>定义</p>\n<pre><code data-query="{}" data-lang="">  int sendfile(int fd, int s, off_t offset, off_t *len, struct sf_hdtr *hdtr, int flags);\n</code></pre>\n</li>\n<li>\n<p>解释</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>argument name</th>\n<th>explantion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>fd</td>\n<td>需要发送的文件的fd(file description)</td>\n</tr>\n<tr>\n<td>s</td>\n<td>socket的fd</td>\n</tr>\n<tr>\n<td>offset</td>\n<td>文件从那开始发,NULL表示为0</td>\n</tr>\n<tr>\n<td>len</td>\n<td>输出参数，输出一共发送了多少byte,包括后面的hdtr</td>\n</tr>\n<tr>\n<td>hdtr</td>\n<td>额外发送的头和尾</td>\n</tr>\n<tr>\n<td>flags</td>\n<td>设置为0即可</td>\n</tr>\n</tbody>\n</table>\n<p>关于flags, man page原文如下:</p>\n<blockquote>\n<p>The flags parameter is reserved for future expansion and must be set to 0. Any other value will cause sendfile() to return EINVAL.</p>\n</blockquote>\n<p>意思是，flags是为了后面备用的，现在还没实现，现在传入0即可。</p>\n<p>下面着重解释<code>len</code>与<code>hdtr</code>参数\n结构体<code>sf_hdtr</code>, 成员如下</p>\n<pre><code class="hljs language-c" data-query="{}" data-lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sf_hdtr</span> {</span>\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">headers</span>;</span>  <span class="hljs-comment">/* pointer to header iovecs */</span>\n    <span class="hljs-keyword">int</span> hdr_cnt;            <span class="hljs-comment">/* number of header iovecs */</span>\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> *<span class="hljs-title">trailers</span>;</span> <span class="hljs-comment">/* pointer to trailer iovecs */</span>\n    <span class="hljs-keyword">int</span> trl_cnt;            <span class="hljs-comment">/* number of trailer iovecs */</span>\n};</code></pre>\n<p>而，结构体<code>iovec</code></p>\n<pre><code class="hljs language-c" data-query="{}" data-lang="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> {</span>\n\t<span class="hljs-keyword">void</span> *   iov_base;\t<span class="hljs-comment">/* [XSI] Base address of I/O memory region */</span>\n\t<span class="hljs-keyword">size_t</span>\t iov_len;\t<span class="hljs-comment">/* [XSI] Size of region iov_base points to */</span>\n};</code></pre>\n<p>可以看到，iovec数据就是表示一段<code>iov_len</code>长度的数据区，而sf_hdtr则是2个<code>iov_len</code>数组(指针)。</p>\n<p><code>headers</code>就是发送文件数据前发送的数据段，<code>trailers</code>则是跟在文件数据EOF之后的。</p>\n<p>解释完该方法后，其实上传文件，只需要调用该方法即可，而<code>headers</code>和<code>trailers</code>可以用来界定文件数据，ngnix osx版本中，便有使用该方法。</p>\n<p>为了简化文件数据划分的逻辑，我未采用，http协议中类似<code>Content-Length</code>字段来表示文件的大小，从而拼接出完整的文件内容，而是简单的在文件数据头尾加上了自定义的字符串。</p>\n<h2 id="代码"><a href="#%E4%BB%A3%E7%A0%81" aria-hidden="true"><span class="icon icon-link"></span></a>代码</h2>\n<p><a href="https://github.com/moyuyc/c_cpp-node_c_cpp_addon/tree/master/cpp_src">cpp_src</a></p>\n<ul>\n<li>发送文件</li>\n</ul>\n<pre><code class="hljs language-c" data-query="{}" data-lang="c"><span class="hljs-keyword">bool</span> _sendFile(<span class="hljs-keyword">int</span> out_fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file) {\n    <span class="hljs-keyword">int</span> fd = open(file, O_RDONLY);\n    <span class="hljs-keyword">char</span>* tmp = <span class="hljs-built_in">strrchr</span>(file, <span class="hljs-string">\'/\'</span>);\n    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* filename = tmp!=<span class="hljs-literal">NULL</span>? tmp+<span class="hljs-number">1</span>: file;\n    <span class="hljs-keyword">if</span>(fd==<span class="hljs-number">-1</span>) {\n        <span class="hljs-keyword">char</span> b[<span class="hljs-number">1024</span>];\n        <span class="hljs-built_in">sprintf</span>(b, <span class="hljs-string">"open failed %s"</span>, file);\n        perror(b);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">state</span>;</span>\n    fstat(fd, &#x26;state);\n\n    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sending File %s ...\\n"</span>, file);\n    <span class="hljs-keyword">off_t</span> offset = <span class="hljs-number">0</span>;\n    <span class="hljs-keyword">off_t</span> len = <span class="hljs-number">0</span>; <span class="hljs-comment">// 必须初始化0, 不然下次重入时，会被旧值覆盖</span>\n\n    <span class="hljs-keyword">char</span> head[<span class="hljs-number">1024</span>], sizehd[<span class="hljs-number">1024</span>];\n    <span class="hljs-built_in">sprintf</span>(head, <span class="hljs-string">"---file: %s\\r\\n"</span>, filename); <span class="hljs-comment">// 拼装头部字符串</span>\n<span class="hljs-comment">//    sprintf(sizehd, "---size: %lld\\r\\n\\r\\n", state.st_size);</span>\n\n    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sf_hdtr</span> <span class="hljs-title">hdtr</span> = <span class="hljs-title">NULL</span>;</span>\n    iovec headers = <span class="hljs-literal">NULL</span>, trailers = <span class="hljs-literal">NULL</span>;\n    headers.iov_base = head;\n    headers.iov_len = <span class="hljs-built_in">strlen</span>(head);\n<span class="hljs-comment">//    trailers.iov_base = (void *)"file---\\r\\n"; //todo: don\'t recv sometimes ??</span>\n<span class="hljs-comment">//    trailers.iov_len = 9;</span>\n    hdtr.headers = &#x26;headers;\n    hdtr.hdr_cnt = <span class="hljs-number">1</span>;\n    hdtr.trailers = <span class="hljs-literal">NULL</span>;\n    hdtr.trl_cnt = <span class="hljs-number">0</span>;\n\n    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == sendfile(fd, out_fd, offset, &#x26;len, &#x26;hdtr, <span class="hljs-number">0</span>)) {\n        close(fd);\n        write(out_fd, <span class="hljs-string">"file---\\r\\n"</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// 未使用trailers，因为有时候上传大文件，trailers会丢失。</span>\n        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sendFile %s success, return len: %lld.\\n"</span>, file, len);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n    } <span class="hljs-keyword">else</span> {\n        close(fd);\n        write(out_fd, <span class="hljs-string">"file---\\r\\n"</span>, <span class="hljs-number">9</span>);\n        perror(<span class="hljs-string">"sendfile"</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n}</code></pre>\n<ul>\n<li>接收文件</li>\n</ul>\n<pre><code class="hljs language-c" data-query="{}" data-lang="c"><span class="hljs-keyword">bool</span> _receFile(FILE* &#x26;pfsile, <span class="hljs-keyword">char</span>* buffer, <span class="hljs-keyword">ssize_t</span> n, <span class="hljs-keyword">bool</span>&#x26; receiveing, <span class="hljs-keyword">char</span>* rfilename, <span class="hljs-keyword">int</span> size) {\n    <span class="hljs-keyword">bool</span> run = <span class="hljs-literal">false</span>;\n    <span class="hljs-keyword">char</span>* last = <span class="hljs-literal">NULL</span>;\n    <span class="hljs-keyword">if</span>(!receiveing &#x26;&#x26; isfileHead(buffer)) {\n        <span class="hljs-built_in">memset</span>(rfilename, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);\n        <span class="hljs-built_in">strcpy</span>(rfilename, <span class="hljs-string">"data/"</span>);\n        <span class="hljs-keyword">if</span> (stat(rfilename, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) {\n            mkdir(rfilename, <span class="hljs-number">0700</span>);\n        }\n\n        <span class="hljs-keyword">char</span> name[<span class="hljs-number">40</span>];\n        <span class="hljs-built_in">sscanf</span>(buffer, <span class="hljs-string">"---file: %s\\r\\n"</span>, name);\n        <span class="hljs-keyword">int</span> othlen = <span class="hljs-number">11</span>+<span class="hljs-built_in">strlen</span>(name);\n        <span class="hljs-keyword">int</span> addonlen = n-othlen;\n\n        <span class="hljs-built_in">strcat</span>(rfilename, name);\n        pfile = fopen(rfilename, <span class="hljs-string">"wb+"</span>); <span class="hljs-comment">//!! 以二进制打开文件</span>\n\n        receiveing = <span class="hljs-literal">true</span>;\n        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Downloading %s ...\\nhead addon: %s\\n\\n"</span>,\n               rfilename, buffer+othlen);\n        <span class="hljs-keyword">if</span>(addonlen > <span class="hljs-number">0</span>) {\n            fwrite(buffer+othlen, addonlen, <span class="hljs-number">1</span>, pfile);\n        }\n        run= <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">if</span>(receiveing &#x26;&#x26; (last = fileTail(buffer, n))!=<span class="hljs-literal">NULL</span>) {\n        receiveing = <span class="hljs-literal">false</span>;\n        fwrite(buffer, last-buffer, <span class="hljs-number">1</span>, pfile);\n        fclose(pfile);\n        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Downloaded %s. and saved\\n"</span>, rfilename);\n        run= <span class="hljs-literal">true</span>;\n    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(receiveing &#x26;&#x26; !run) {\n        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"download chunk, size: %ld\\n"</span>, n);\n        <span class="hljs-keyword">if</span>(n&#x3C;size) {\n            receiveing = <span class="hljs-literal">false</span>;\n            fclose(pfile);\n        }\n        fwrite(buffer, n, <span class="hljs-number">1</span>, pfile);\n        run= <span class="hljs-literal">true</span>;\n    }\n    <span class="hljs-keyword">return</span> run;\n}</code></pre>\n<h2 id="最后"><a href="#%E6%9C%80%E5%90%8E" aria-hidden="true"><span class="icon icon-link"></span></a>最后</h2>\n<p>其实还是会有bug的，比如<code>---file: a.png\\r\\n ... ---file\\r\\n</code>的数据，接收方buffer设置较小，不能容纳完整的<code>---file</code>标志，可能就不会被认为是file；或者结尾截断了。而对于上诉情况，应用层只能通过更复杂的代码逻辑来控制了。</p>\n',extra:{}}}});