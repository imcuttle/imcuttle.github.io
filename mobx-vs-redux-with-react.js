webpackJsonp([64,113],{1200:function(s,n){s.exports={content:"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><blockquote><p>我人就是闲不下来 - -<br>辛辛苦苦上了一周班，周末又捣鼓起 React+Mobx 一套了</p><p>下周要开始疯狂踩 React Native 的坑了，公司要我着手开发 app 了，心塞（mmp，拿着农民工的钱，干着“打天下”的事，本人还不是专业的 - -）</p><p>还有，最近有童鞋反映我的文章看不懂，不照顾基础不好的童鞋，希望我想阮一峰大神一样循循善诱、由浅入深。（这可苦了我一个理科生了，阮大师好歹是位文科生）</p></blockquote><p>不扯淡了。</p><h3 id=react><a href=#react aria-hidden=true><span class=\"icon icon-link\"></span></a>React</h3><p>React 是由 Facebook 提出的 View 层框架。之所以不在之前加上“前端”修饰，是因为 React 在提出时，目标就不仅仅是前端，Virtual Dom 的提出，使得 React 能运行在服务端(ssr)、移动端(react-native)、web端。所以是 <strong>Learn once, write anywhere</strong></p><img src=false alt=ClipboardImage width=623 height=396 data-src=https://ooo.0o0.ooo/2017/01/23/5884d71e7ed1d.jpg><p>React 希望通过状态改变来更新视图（diff算法，找到最佳的渲染），还可以通过一些组件内的生命周期方法，来改变视图，达到想要的交互效果。</p><p>React 入门看这就够了，<a href=http://www.ruanyifeng.com/blog/2015/03/react.html>React 简单入门教程，阮大牛</a></p><h3 id=redux><a href=#redux aria-hidden=true><span class=\"icon icon-link\"></span></a>Redux</h3><p>由于 React 只是一层 View，对于其数据需要自己管理，对于复杂的应用，如果缺少可维护的状态管理，这对于后面的开发工作是灾难性的。</p><p>Redux 便是一套可维护的状态管理工具，</p><p>其主张应用只有一个 store 存储数据，将该 store 层层分离、传入子组件。因此组件（纯渲染）只需要关注自己的需要的数据即可，具有很强的复用性！</p><p>搭配一系列的 actions，通过 action ID 找到对应的 reducer 处理流程，更新 store，相应的，视图也更新了。</p><p>所以在组件中的生命周期函数，用户触发的事件函数中，调用 action 即可。</p><img src=false alt width=800 height=600 data-src=https://ooo.0o0.ooo/2017/01/22/58845a7e4a302.jpg><p>可以看出 redux 十分对大型应用的口味，而且很配合 react 的理念，<strong>组件化</strong>。</p><p><em>但是</em>，Redux 比较难上手，太多的新概念提出（action、reducer、store），这对于没有体会到 react 开发痛点的新同学来说，是晦涩的。</p><blockquote><p>当初在百度实习，我也是死磕了几天文档才懵懵懂懂的明白了一点，写了个简单的 demo，之后在看项目代码，写项目代码的时候才慢慢会用。</p><p>但又过了这么久之后，自己独立从零开发，使用 react react-router redux 一套之后，才发现以前关于 redux 的疑问都迎刃而解了。之前写的都是个 xx 啊，真是苦了后面维护我代码的兄弟...</p></blockquote><p>所以，Mobx 出现了。</p><h3 id=mobx><a href=#mobx aria-hidden=true><span class=\"icon icon-link\"></span></a>Mobx</h3><p>正如官方所说</p><blockquote><p><em>Simple, scalable state management</em></p></blockquote><p>mobx 是一个简单，可扩展的状态管理器。</p><p>Mobx 希望所有需要管理的状态, 都应该被提取出来， 并自动化，不需要书写代码判断是否需要更新视图。</p><p>Mobx 搭配 ES6 的<a href=http://es6.ruanyifeng.com/#docs/decorator>修饰器</a>使用，代码更简单优雅。</p><p>Babel 需要 babel-plugin-transform-decorators-legacy 才能使用修饰器</p><p>Mobx 希望一个 View 对应一个 Model，这对于熟悉面向对象编程的同学十分友好。</p><p>更新 Model 后，View 也自动更新，十分直接（从 Store => View => Update）</p><p>Redux 需要关注 Store => View => Action => Reducer 一套闭环</p><p>以下为 ES6 的一个<a href=https://github.com/moyuyc/react-mobx-starter>评论列表demo</a></p><pre><code class=\"hljs language-javascript\"data-query={} data-lang=javascript><span class=hljs-keyword>import</span> React <span class=hljs-keyword>from</span> <span class=hljs-string>'react'</span>;\n<span class=hljs-keyword>import</span> {render} <span class=hljs-keyword>from</span> <span class=hljs-string>'react-dom'</span>;\n<span class=hljs-keyword>import</span> {observable, computed, action, useStrict, toJS} <span class=hljs-keyword>from</span> <span class=hljs-string>'mobx'</span>;\n<span class=hljs-keyword>import</span> {Provider, inject, observer} <span class=hljs-keyword>from</span> <span class=hljs-string>'mobx-react'</span>;\n\n<span class=hljs-comment>// View</span>\n<span class=hljs-comment>// 视为观察者，其视图更新交给 mobx 管理</span>\n@observer\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Comment</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\n    <span class=hljs-keyword>constructor</span>(props) {\n        <span class=hljs-keyword>super</span>(props)\n    }\n    render() {\n        <span class=hljs-keyword>const</span> {author, date, content, text} = <span class=hljs-keyword>this</span>.props.store;\n        <span class=hljs-keyword>const</span> {onDelete} = <span class=hljs-keyword>this</span>.props;\n\n        <span class=hljs-keyword>return</span> (\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>></span>\n                </span>&lt;div>{content}&lt;/div><span class=xml>\n                </span>&lt;p>{text}&lt;/p><span class=xml>\n                </span>&lt;span>{author}&lt;time>{date}&lt;/time>&lt;/span><span class=xml>\n                </span>&lt;button onClick={onDelete}>Delete&lt;/button><span class=xml>\n            <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span></span>\n        )\n    }\n}\n<span class=hljs-comment>// 注入 context 中 comments 属性  并且视为观察者</span>\n@inject(<span class=hljs-string>'comments'</span>) @observer\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>CommentList</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\n    shouldComponentUpdate() {\n        <span class=hljs-comment>// 这里的代码不会起作用</span>\n        alert(<span class=hljs-number>1</span>);\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;\n    }\n\n    render() {\n        <span class=hljs-keyword>const</span> {comments} = <span class=hljs-keyword>this</span>.props;\n        <span class=hljs-keyword>return</span> (\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ul</span>></span>\n                {comments &amp&amp comments.get().map((comment, index) =>\n                    </span>&lt;Comment key={index} store={comment} onDelete={() => {comments.del(index)} }/>\n                )}\n            &lt;/ul><span class=xml>\n        )\n    }\n}\n\n// Model\n// 严格模式下，只能在 @action 修饰的方法才能修改被观察的数据\nuseStrict(true);\n\nclass CommentState {\n    // 被观察者，观察者将检查到其的改变，从而更新视图\n    @observable author = \"\";\n\n    @observable date = \"\";\n\n    @observable content = \"\";\n\n    // 计算属性\n    @computed get text () {\n        return `${this.author} at ${this.date}: ${this.content}`;\n    }\n\n    constructor({author, date, content}) {\n        this.author = author;\n        this.date = date;\n        this.content = content;\n    }\n}\n\nclass CommentListState {\n    @observable comments = [new CommentState({author: 'auth', datetime: 'date', content: 'content'})];\n\n    toJSON() {\n        return toJS(this.comments);\n    }\n    constructor(comments) {\n        if (comments) {\n            this.set(comments);\n        }\n    }\n\n    get() {\n        return this.comments;\n    }\n\n    @action del(index) {\n        this.comments.splice(index, 1);\n    }\n\n    @action set(list) {\n        this.comments = list.map(x => new CommentState(x))\n    }\n\n    @action fetch() {\n        setTimeout(() => {\n            this.push([{author: 'John', datetime: '123', content: 'hahahaha'}]);\n        }, 1000);\n        return this;\n    }\n\n    @action push(list) {\n        this.comments.push(...new CommentListState(list).comments);\n    }\n\n}\n\n\nvar store = {\n    comments: new CommentListState().fetch()\n}\n// Provider : 将 props 写入 Context, 使得其子代（非直系亦可）共享数据。\nrender(\n    </span>&lt;Provider {...store} >\n        &lt;CommentList />\n    &lt;/Provider><span class=xml>,\n    document.getElementById('root')\n);</span></code></pre><p>综上，Redux、MobX 各有千秋，MobX 虽然简单直接；但破坏了纯渲染组件结构，必须需要对应的 Model 才能正确使用；且其文档与生态环境没有 Redux 良好。 喜欢简洁，爱尝试的同学可以试一下。</p>",extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=mobx-vs-redux-with-react.js.map