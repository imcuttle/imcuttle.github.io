webpackJsonp([63,90],{1e3:function(a,n){a.exports={content:'<p>题目：刷脸签到系统<br>\n姓名：余聪<br>\n学号：19130126</p>\n<p>主要完成了 nodejs 调用 opencv 的工作；后续利用 javascript 进行样本的预处理（灰化，级联分类器检测，裁剪等），样本的训练与人脸的对比识别...</p>\n<h2 id="知识点介绍"><a href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span class="icon icon-link"></span></a>知识点介绍</h2>\n<ul>\n<li>nodejs 调用 C/C++<br>\n需要使用 <a href="https://nodejs.org/api/addons.html"><code>C/C++ Addons</code></a>   。图像处理最强大的库 opencv 便是用 C++ 实现的，这就不得不需要 nodeJs 与 C++ 之前通信，通过 nodeJs 调用 opencv 的方法，node-opencv 便是利用 nan （解决平台间兼容性问题，将异步事件驱动封装）与 v8 （javascript 对应的数据类型与 C++映射） ，通过 node-gyp 工具，将 C++ 打包成 一个动态链接库 *.node，通过 require 即可调用。</li>\n</ul>\n<ul>\n<li>\n<p>人脸识别流程<br>\n人脸识别实际包括构建人脸识别系统的一系列相关技术，包括人脸图像采集、人脸定位、人脸识别预处理、身份确认以及身份查找等。上一步已经完成了人脸的采集； 人脸定位也就是人脸的检测，在一张图片中，找出人脸的位置。通过一些特征提取的方法，如HOG特征，LBP特征，Haar特征，训练得到级联分类器，分类器对图像的任意位置和任意尺寸的部分(通常是正方形或长方形)进行分类，判定是或不是人脸。opencv源码中提供了一些常用的分类器（XML）。人脸识别预处理也就是对图像进行灰化，人脸检测，得到统一大小的人脸图片；然后便是识别了，对样本训练生成特征脸后，对于输入的人脸进行预处理后，得到其特征脸权重向量，计算向量距离，找到最小距离的样本人脸。</p>\n</li>\n<li>\n<p>特征脸<br>\n特征脸（Eigenface）是指用于机器视觉领域中的人脸识别问题的一组特征向量。这些特征向量是从高维矢量空间的人脸图像的协方差矩阵计算而来。一组特征脸 可以通过在一大组描述不同人脸的图像上进行主成分分析（PCA）获得。任意一张人脸图像都可以被认为是这些标准脸的组合。另外，由于人脸是通过一系列向量（每个特征脸一个比例值）而不是数字图像进行保存，可以节省很多存储空间。可以看到特征脸的生成是需要整个样本数据的，所以如果用户修改了样本数据，需要对全部样本重新训练，得到一组全新的特征脸。</p>\n</li>\n<li>\n<p>PCA<br>\n主成分分析（Principal components analysis，PCA）是一种分析、简化数据集的技术。主成分分析经常用于减少数据集的维数，同时保持数据集中的对方差贡献最大的特征。这是通过保留低阶主成分，忽略高阶主成分做到的。这样低阶成分往往能够保留住数据的最重要方面。</p>\n</li>\n</ul>\n<h2 id="工作"><a href="#%E5%B7%A5%E4%BD%9C" aria-hidden="true"><span class="icon icon-link"></span></a>工作</h2>\n<p>整合了数据库和 opencv 后，系统架构如下：\n<img src="https://ooo.0o0.ooo/2017/04/16/58f2ca8f8c500.jpg" width="448" height="385"/></p>\n<h3 id="opencv-环境安装"><a href="#opencv-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85" aria-hidden="true"><span class="icon icon-link"></span></a>opencv 环境安装</h3>\n<p>由于开发平台是 OSX ，而 OSX 有 Homebrew 神器</p>\n<pre><code class="hljs language-bash" data-query="{}" data-lang="bash"><span class="hljs-comment"># 安装 Homebrew</span>\n/usr/bin/ruby -e <span class="hljs-string">"<span class="hljs-variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span>\n\n<span class="hljs-comment"># 设置 Homebrew镜像代理，国内下载加速</span>\n<span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$(brew --repo)</span>"</span>\ngit remote <span class="hljs-built_in">set</span>-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git\n<span class="hljs-built_in">cd</span> <span class="hljs-string">"<span class="hljs-variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span>\ngit remote <span class="hljs-built_in">set</span>-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git\nbrew update\n<span class="hljs-built_in">echo</span> <span class="hljs-string">\'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles\'</span> >> ~/.bash_profile\n<span class="hljs-built_in">source</span> ~/.bash_profile\n\n<span class="hljs-comment"># 安装 opencv</span>\nbrew tap homebrew/science\nbrew install opencv</code></pre>\n<h3 id="node-addons尝试"><a href="#node-addons%E5%B0%9D%E8%AF%95" aria-hidden="true"><span class="icon icon-link"></span></a>node addons尝试</h3>\n<p>node addons 是在 node 环境调用 C 系列接口的方法，已经有人用该方法写过 node-opencv，并在此基础上我还加上了 <code>CircleLBP</code> <code>RectLBP</code> <code>ToThreeChannels</code> <code>PCA</code> 算法。其中 <code>ToThreeChannels</code> 是将 单通道（灰）或者 RGBA 通道变成 RGB 通道。</p>\n<pre><code class="hljs language-c++" data-query="{}" data-lang="c++">NAN_METHOD(Matrix::ToThreeChannels) {\n  Nan::HandleScope scope;\n  Matrix *self = Nan::ObjectWrap::Unwrap&#x3C;Matrix>(info.This());\n  cv::Mat image;\n\n  <span class="hljs-keyword">if</span> (self->mat.channels() == <span class="hljs-number">3</span>) {\n    image = self->mat;\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self->mat.channels() == <span class="hljs-number">1</span>) {\n    cv::Mat myimg = self->mat;\n    cv::cvtColor(myimg, image, CV_GRAY2RGB);\n  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(self->mat.channels() == <span class="hljs-number">4</span>){\n    cv::Mat myimg = self->mat;\n    cv::cvtColor(myimg, image, CV_BGRA2RGB);\n  } <span class="hljs-keyword">else</span> {\n    Nan::ThrowError(<span class="hljs-string">"those channels are not supported"</span>);\n  }\n\n  self->mat = image;\n  info.GetReturnValue().Set(Nan::Null());\n}</code></pre>\n<h3 id="图片预处理（人脸检测）"><a href="#%E5%9B%BE%E7%89%87%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%88%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%EF%BC%89" aria-hidden="true"><span class="icon icon-link"></span></a>图片预处理（人脸检测...）</h3>\n<p>通道统一 -> 灰化 -> 级联分类器检测人脸 -> 人脸尺寸统一 -> 保存</p>\n<p>经过多次尝试后，对于学生证件照，最终比较得出，采用 LBP 级联分类器，窗口放大 1.95 倍左右效果较好。（测试数据在 <code>backend/data/summary.json</code>）</p>\n<img src="https://ooo.0o0.ooo/2017/01/22/5884929797559.jpg" alt="" width="770" height="436">\n<img src="https://ooo.0o0.ooo/2017/01/22/588492ae5471e.jpg" alt="" width="770" height="436">\n<h3 id="识别算法测试与确定"><a href="#%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%A1%AE%E5%AE%9A" aria-hidden="true"><span class="icon icon-link"></span></a>识别算法测试与确定</h3>\n<p>比较 opencv 中三种人脸识别算法，Eigen、Fisher、LBPH。数据在<code>backend/cpptest</code> 中</p>\n<table border="0"><caption><em>opencv 人脸识别算法比较</em></caption><tbody><tr><th rowspan="2" style="text-align: center;">算法/时间(ms)</th><th colspan="2">实验1</th><th colspan="2">实验2</th><th colspan="2">实验3</th></tr><tr><td>训练</td><td>预测</td><td>训练</td><td>预测</td><td>训练</td><td>预测</td></tr><tr><th>Eigen</th><td>0.030648</td><td>0.010711</td><td>0.025524</td><td>0.011132</td><td>0.029332</td><td>0.007791</td></tr><tr><th>Fisher</th><td>0.040043</td><td>0.0089</td><td>0.039244</td><td>0.007145</td><td>0.033777</td><td>0.008276</td></tr><tr><th>LBPH</th><td>0.035812</td><td>0.071586</td><td>0.034822</td><td>0.075267</td><td>0.03204</td><td>0.067166</td>\n</tr></tbody></table>\n<p>综合比较可以得出，效率 Eigen > Fisher > LBPH\n所以采用Eigen（特征脸）算法</p>\n<h3 id="学生信息接口（爬虫）"><a href="#%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3%EF%BC%88%E7%88%AC%E8%99%AB%EF%BC%89" aria-hidden="true"><span class="icon icon-link"></span></a>学生信息接口（爬虫）</h3>\n<p>该系统还需要获取到学生的个人信息，比如通过学号和密码验证是否正确等等。在同一届的同学中，已经有一位同学研究教务系统比较透彻了，而且做了一个<a href="http://njnu.chaiziyi.com.cn/">查南师</a>网站，所以我只需要爬取该网站的接口即可。</p>\n<h3 id="图片预处理指令解释"><a href="#%E5%9B%BE%E7%89%87%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A" aria-hidden="true"><span class="icon icon-link"></span></a>图片预处理指令解释</h3>\n<pre><code class="hljs language-bash" data-query="{}" data-lang="bash"><span class="hljs-comment"># location: gp-njnu-photos-backend/package.json</span>\n<span class="hljs-comment"># usage: (cd gp-njnu-photos-backend &#x26;&#x26; npm run $scriptName)</span>\n\n<span class="hljs-comment"># 图片预处理</span>\n<span class="hljs-comment"># detect face, then gray, save</span>\n<span class="hljs-comment"># eg.  $ npm run grayface 2013 191301</span>\n<span class="hljs-comment">#      $ npm run grayface 2013</span>\n<span class="hljs-comment">#      $ npm run grayface</span>\n<span class="hljs-comment"># npm run grayface year classno</span>\n\n\n<span class="hljs-comment"># 样本训练并写入文件。</span>\n<span class="hljs-comment"># after read grayface images, then train and save it</span>\n<span class="hljs-comment"># eg.  $ node pretreat/train_save.js -f --args 2013</span>\n<span class="hljs-comment">#      $ node pretreat/train_save.js -f --args 2013 191301</span>\n<span class="hljs-comment"># -f：force 重新训练，不论是否已存在训练数据</span>\n<span class="hljs-comment"># --args year classno 训练哪一年哪一班级的图片</span></code></pre>\n<h3 id="数据解释"><a href="#%E6%95%B0%E6%8D%AE%E8%A7%A3%E9%87%8A" aria-hidden="true"><span class="icon icon-link"></span></a>数据解释</h3>\n<p>在 <code>gp-njnu-photos-backend/data</code> 目录中</p>\n<pre><code data-query="{}" data-lang="">data/\n├── cache.json  # 由于学生的数据和身份验证需要通过查南师网站，其中中转的服务器较多，所以在本服务器做了个缓存数据，过7天将会清理该缓存。\n├── face-recognizer/\n│   ├── 2013-011301.yaml    # 特征脸数据\n│   ├── 2013-011302.yaml  \n│   └── facesNumObj.json    # 保存每个学号对应多少张人脸\n├── face-recognizer.json    # 保存每年级每个班级对应的学生照片的路径地址\n├── haarcascade_eye_tree_eyeglasses.xml  # 一系列分类器数据\n├── haarcascade_eye.xml\n├── haarcascade_frontalface_alt_tree.xml\n├── haarcascade_frontalface_alt.xml\n├── haarcascade_frontalface_alt2.xml\n├── haarcascade_frontalface_default.xml\n├── haarcascade_fullbody.xml\n├── haarcascade_lefteye_2splits.xml\n├── haarcascade_lowerbody.xml\n├── haarcascade_mcs_eyepair_big.xml\n├── haarcascade_mcs_eyepair_small.xml\n├── haarcascade_mcs_lefteye.xml\n├── haarcascade_mcs_mouth.xml\n├── haarcascade_mcs_nose.xml\n├── haarcascade_mcs_righteye.xml\n├── haarcascade_mcs_upperbody.xml\n├── haarcascade_profileface.xml\n├── haarcascade_righteye_2splits.xml\n├── haarcascade_upperbody.xml\n├── hogcascade_cars_sideview.xml\n├── images/         # 预处理后的样本，真正的样本数据\n│   ├── 2013/\n│   ├── 2015/\n│   └── 2016/\n├── students.json   # 不同分类器不同参数的比对\n└── summary.json    # 每个年级每个班级学生学号的集合\n</code></pre>\n<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true"><span class="icon icon-link"></span></a>总结</h2>\n<p>由于核心算法调用的为开源的 opencv 方法，适用性不是特别高，准确率有待提高。</p>\n',extra:{}}}});