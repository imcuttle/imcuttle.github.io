webpackJsonp([45,90],{1018:function(n,s){n.exports={content:'<blockquote>\n<p>我人就是闲不下来 - -<br>\n辛辛苦苦上了一周班，周末又捣鼓起 React+Mobx 一套了</p>\n<p>下周要开始疯狂踩 React Native 的坑了，公司要我着手开发 app 了，心塞（mmp，拿着农民工的钱，干着“打天下”的事，本人还不是专业的 - -）</p>\n<p>还有，最近有童鞋反映我的文章看不懂，不照顾基础不好的童鞋，希望我想阮一峰大神一样循循善诱、由浅入深。（这可苦了我一个理科生了，阮大师好歹是位文科生）</p>\n</blockquote>\n<p>不扯淡了。</p>\n<h3 id="react"><a href="#react" aria-hidden="true"><span class="icon icon-link"></span></a>React</h3>\n<p>React 是由 Facebook 提出的 View 层框架。之所以不在之前加上“前端”修饰，是因为 React  在提出时，目标就不仅仅是前端，Virtual Dom 的提出，使得 React 能运行在服务端(ssr)、移动端(react-native)、web端。所以是 <strong>Learn once, write anywhere</strong></p>\n<img src="https://ooo.0o0.ooo/2017/01/23/5884d71e7ed1d.jpg" alt="ClipboardImage" width="623" height="396">\n<p>React 希望通过状态改变来更新视图（diff算法，找到最佳的渲染），还可以通过一些组件内的生命周期方法，来改变视图，达到想要的交互效果。</p>\n<p>React 入门看这就够了，<a href="http://www.ruanyifeng.com/blog/2015/03/react.html">React 简单入门教程，阮大牛</a></p>\n<h3 id="redux"><a href="#redux" aria-hidden="true"><span class="icon icon-link"></span></a>Redux</h3>\n<p>由于 React 只是一层 View，对于其数据需要自己管理，对于复杂的应用，如果缺少可维护的状态管理，这对于后面的开发工作是灾难性的。</p>\n<p>Redux 便是一套可维护的状态管理工具，</p>\n<p>其主张应用只有一个 store 存储数据，将该 store 层层分离、传入子组件。因此组件（纯渲染）只需要关注自己的需要的数据即可，具有很强的复用性！</p>\n<p>搭配一系列的 actions，通过 action ID 找到对应的 reducer 处理流程，更新 store，相应的，视图也更新了。</p>\n<p>所以在组件中的生命周期函数，用户触发的事件函数中，调用 action 即可。</p>\n<img src="https://ooo.0o0.ooo/2017/01/22/58845a7e4a302.jpg" alt="" width="800" height="600">\n<p>可以看出 redux 十分对大型应用的口味，而且很配合 react 的理念，<strong>组件化</strong>。</p>\n<p><em>但是</em>，Redux 比较难上手，太多的新概念提出（action、reducer、store），这对于没有体会到 react 开发痛点的新同学来说，是晦涩的。</p>\n<blockquote>\n<p>当初在百度实习，我也是死磕了几天文档才懵懵懂懂的明白了一点，写了个简单的 demo，之后在看项目代码，写项目代码的时候才慢慢会用。</p>\n<p>但又过了这么久之后，自己独立从零开发，使用 react react-router redux 一套之后，才发现以前关于 redux 的疑问都迎刃而解了。之前写的都是个 xx 啊，真是苦了后面维护我代码的兄弟...</p>\n</blockquote>\n<p>所以，Mobx 出现了。</p>\n<h3 id="mobx"><a href="#mobx" aria-hidden="true"><span class="icon icon-link"></span></a>Mobx</h3>\n<p>正如官方所说 </p>\n<blockquote>\n<p><em>Simple, scalable state management</em></p>\n</blockquote>\n<p>mobx 是一个简单，可扩展的状态管理器。</p>\n<p>Mobx 希望所有需要管理的状态, 都应该被提取出来， 并自动化，不需要书写代码判断是否需要更新视图。</p>\n<p>Mobx 搭配 ES6 的<a href="http://es6.ruanyifeng.com/#docs/decorator">修饰器</a>使用，代码更简单优雅。</p>\n<p>Babel 需要 babel-plugin-transform-decorators-legacy 才能使用修饰器</p>\n<p>Mobx 希望一个 View 对应一个 Model，这对于熟悉面向对象编程的同学十分友好。</p>\n<p>更新 Model 后，View 也自动更新，十分直接（从 Store => View => Update）</p>\n<p>Redux 需要关注 Store => View => Action => Reducer 一套闭环</p>\n<p>以下为 ES6 的一个<a href="https://github.com/moyuyc/react-mobx-starter">评论列表demo</a></p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">\'react\'</span>;\n<span class="hljs-keyword">import</span> {render} <span class="hljs-keyword">from</span> <span class="hljs-string">\'react-dom\'</span>;\n<span class="hljs-keyword">import</span> {observable, computed, action, useStrict, toJS} <span class="hljs-keyword">from</span> <span class="hljs-string">\'mobx\'</span>;\n<span class="hljs-keyword">import</span> {Provider, inject, observer} <span class="hljs-keyword">from</span> <span class="hljs-string">\'mobx-react\'</span>;\n\n<span class="hljs-comment">// View</span>\n<span class="hljs-comment">// 视为观察者，其视图更新交给 mobx 管理</span>\n@observer\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n    <span class="hljs-keyword">constructor</span>(props) {\n        <span class="hljs-keyword">super</span>(props)\n    }\n    render() {\n        <span class="hljs-keyword">const</span> {author, date, content, text} = <span class="hljs-keyword">this</span>.props.store;\n        <span class="hljs-keyword">const</span> {onDelete} = <span class="hljs-keyword">this</span>.props;\n\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>\n                </span>&#x3C;div>{content}&#x3C;/div><span class="xml">\n                </span>&#x3C;p>{text}&#x3C;/p><span class="xml">\n                </span>&#x3C;span>{author}&#x3C;time>{date}&#x3C;/time>&#x3C;/span><span class="xml">\n                </span>&#x3C;button onClick={onDelete}>Delete&#x3C;/button><span class="xml">\n            <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>\n        )\n    }\n}\n<span class="hljs-comment">// 注入 context 中 comments 属性  并且视为观察者</span>\n@inject(<span class="hljs-string">\'comments\'</span>) @observer\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommentList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{\n    shouldComponentUpdate() {\n        <span class="hljs-comment">// 这里的代码不会起作用</span>\n        alert(<span class="hljs-number">1</span>);\n        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n    }\n\n    render() {\n        <span class="hljs-keyword">const</span> {comments} = <span class="hljs-keyword">this</span>.props;\n        <span class="hljs-keyword">return</span> (\n            <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>\n                {comments &#x26;&#x26; comments.get().map((comment, index) =>\n                    </span>&#x3C;Comment key={index} store={comment} onDelete={() => {comments.del(index)} }/>\n                )}\n            &#x3C;/ul><span class="xml">\n        )\n    }\n}\n\n// Model\n// 严格模式下，只能在 @action 修饰的方法才能修改被观察的数据\nuseStrict(true);\n\nclass CommentState {\n    // 被观察者，观察者将检查到其的改变，从而更新视图\n    @observable author = "";\n\n    @observable date = "";\n\n    @observable content = "";\n\n    // 计算属性\n    @computed get text () {\n        return `${this.author} at ${this.date}: ${this.content}`;\n    }\n\n    constructor({author, date, content}) {\n        this.author = author;\n        this.date = date;\n        this.content = content;\n    }\n}\n\nclass CommentListState {\n    @observable comments = [new CommentState({author: \'auth\', datetime: \'date\', content: \'content\'})];\n\n    toJSON() {\n        return toJS(this.comments);\n    }\n    constructor(comments) {\n        if (comments) {\n            this.set(comments);\n        }\n    }\n\n    get() {\n        return this.comments;\n    }\n\n    @action del(index) {\n        this.comments.splice(index, 1);\n    }\n\n    @action set(list) {\n        this.comments = list.map(x => new CommentState(x))\n    }\n\n    @action fetch() {\n        setTimeout(() => {\n            this.push([{author: \'John\', datetime: \'123\', content: \'hahahaha\'}]);\n        }, 1000);\n        return this;\n    }\n\n    @action push(list) {\n        this.comments.push(...new CommentListState(list).comments);\n    }\n\n}\n\n\nvar store = {\n    comments: new CommentListState().fetch()\n}\n// Provider : 将 props 写入 Context, 使得其子代（非直系亦可）共享数据。\nrender(\n    </span>&#x3C;Provider {...store} >\n        &#x3C;CommentList />\n    &#x3C;/Provider><span class="xml">,\n    document.getElementById(\'root\')\n);</span></code></pre>\n<p>综上，Redux、MobX 各有千秋，MobX 虽然简单直接；但破坏了纯渲染组件结构，必须需要对应的 Model 才能正确使用；且其文档与生态环境没有 Redux 良好。\n喜欢简洁，爱尝试的同学可以试一下。</p>\n',extra:{}}}});