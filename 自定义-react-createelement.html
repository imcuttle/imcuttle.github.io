<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> 自定义 React.createElement - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="1735393010"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">自定义 React.createElement</h1><div class="post-info" data-reactid="12"><time datetime="2020-02-16T07:49:44+00:00" data-reactid="13">Feb 16, 2020 7:49 AM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h1 id="背景" data-reactid="17"><a href="#%E8%83%8C%E6%99%AF" aria-hidden="true" data-reactid="18"><span class="icon icon-link" data-reactid="19"></span></a><!-- react-text: 20 -->背景<!-- /react-text --></h1><p data-reactid="21"><!-- react-text: 22 -->在开发 React 应用中，可能会有这么一个需求，对于浏览器默认的 hovering title 行为，如下图： <!-- /react-text --><img src="https://i.loli.net/2020/02/16/zP8EfqWRK6NXvDZ.jpg" alt="Jietu20200216-161740.jpg" data-reactid="23"/></p><p data-reactid="24"><!-- react-text: 25 -->有一天，PM 或者 UI MM 突然要求换成自定义的样式，甚至希望显示的时间更可控，如下图 <!-- /react-text --><img src="https://i.loli.net/2020/02/16/69kyKxUWlsPRBoE.png" data-reactid="26"/></p><p data-reactid="27"><!-- react-text: 28 -->对于这个需求，我们一般就需要全局搜索 <!-- /react-text --><code data-reactid="29">title</code><!-- react-text: 30 --> 这种关键字，然后进行如下替换<!-- /react-text --></p><pre data-reactid="31"><code data-query="{}" data-lang="data-lang" data-reactid="32">&lt;p title=&quot;我是一个无辜的title&quot;&gt;Hi!&lt;/p&gt;
// =&gt;
// HoverTitle 为实现了 Hovering title 交互的组件
&lt;HoverTitle title=&quot;我是一个无辜的title&quot;&gt;
    &lt;p&gt;Hi!&lt;/p&gt;
&lt;/HoverTitle&gt;
</code></pre><p data-reactid="33">这样改动量比较大，也容易有几个漏网之鱼。 有没有什么一劳永逸的方法呢？</p><h1 id="有什么方式" data-reactid="34"><a href="#%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F" aria-hidden="true" data-reactid="35"><span class="icon icon-link" data-reactid="36"></span></a><!-- react-text: 37 -->有什么方式<!-- /react-text --></h1><p data-reactid="38"><!-- react-text: 39 -->下面有几种方式来实现以上需求： 但实现思路都是覆盖 <!-- /react-text --><code data-reactid="40">React.createElement</code><!-- react-text: 41 -->，如下代码：<!-- /react-text --></p><pre data-reactid="42"><code class="hljs language-jsx" data-query="{}" data-lang="jsx" data-reactid="43"><span class="hljs-keyword" data-reactid="44">const</span><!-- react-text: 45 --> rawCreateElement = React.createElement;
<!-- /react-text --><span class="hljs-keyword" data-reactid="46">const</span><!-- react-text: 47 --> myCreateElement = <!-- /react-text --><span class="hljs-function" data-reactid="48"><!-- react-text: 49 -->(<!-- /react-text --><span class="hljs-params" data-reactid="50">name, props, ...children</span><!-- react-text: 51 -->) =&gt;<!-- /react-text --></span><!-- react-text: 52 --> {
    <!-- /react-text --><span class="hljs-keyword" data-reactid="53">const</span><!-- react-text: 54 --> next = <!-- /react-text --><span class="hljs-function" data-reactid="55"><span class="hljs-params" data-reactid="56">()</span><!-- react-text: 57 --> =&gt;<!-- /react-text --></span><!-- react-text: 58 --> rawCreateElement(name, props, ...children);
    <!-- /react-text --><span class="hljs-keyword" data-reactid="59">if</span><!-- react-text: 60 --> (<!-- /react-text --><span class="hljs-keyword" data-reactid="61">typeof</span><!-- react-text: 62 --> name === <!-- /react-text --><span class="hljs-string" data-reactid="63">&#x27;string&#x27;</span><!-- react-text: 64 --> &amp;&amp; <!-- /react-text --><span class="hljs-keyword" data-reactid="65">typeof</span><!-- react-text: 66 --> props.title === <!-- /react-text --><span class="hljs-string" data-reactid="67">&#x27;string&#x27;</span><!-- react-text: 68 --> &amp;&amp; props.title) {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="69">return</span><!-- react-text: 70 --> <!-- /react-text --><span class="xml" data-reactid="71"><span class="hljs-tag" data-reactid="72"><!-- react-text: 73 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="74">HoverTitle</span><!-- react-text: 75 --> <!-- /react-text --><span class="hljs-attr" data-reactid="76">title</span><!-- react-text: 77 -->=<!-- /react-text --><span class="hljs-string" data-reactid="78">{props.title}</span><!-- react-text: 79 -->&gt;<!-- /react-text --></span><!-- react-text: 80 -->{next()}<!-- /react-text --><span class="hljs-tag" data-reactid="81"><!-- react-text: 82 -->&lt;/<!-- /react-text --><span class="hljs-name" data-reactid="83">HoverTitle</span><!-- react-text: 84 -->&gt;<!-- /react-text --></span></span><!-- react-text: 85 -->
    }
    <!-- /react-text --><span class="hljs-keyword" data-reactid="86">return</span><!-- react-text: 87 --> next()
}<!-- /react-text --></code></pre><p data-reactid="88"><!-- react-text: 89 -->那么我们应该如何才能快捷地全局覆盖 <!-- /react-text --><code data-reactid="90">React.createElement</code><!-- react-text: 91 --> 呢？ 下面介绍如下几种方法<!-- /react-text --></p><h3 id="语法匹配替换用" data-reactid="92"><a href="#%E8%AF%AD%E6%B3%95%E5%8C%B9%E9%85%8D%E6%9B%BF%E6%8D%A2%E7%94%A8" aria-hidden="true" data-reactid="93"><span class="icon icon-link" data-reactid="94"></span></a><!-- react-text: 95 -->语法匹配替换用<!-- /react-text --></h3><p data-reactid="96"><!-- react-text: 97 -->使用 <!-- /react-text --><a href="https://www.npmjs.com/package/babel-plugin-transform-react-jsx" data-reactid="98"><code data-reactid="99">babel-plugin-transform-react-jsx</code></a><!-- react-text: 100 --> 来更改 jsx 转化逻辑，将 jsx 用到的 <!-- /react-text --><code data-reactid="101">createElement</code><!-- react-text: 102 --> 替换成 <!-- /react-text --><code data-reactid="103">myCreateElement</code></p><p data-reactid="104"><!-- react-text: 105 -->但是这样并不完备，比如直接显示使用 <!-- /react-text --><code data-reactid="106">React.createElment</code><!-- react-text: 107 --> 或者 <!-- /react-text --><code data-reactid="108">React.createFactory</code><!-- react-text: 109 --> 的地方则不能涵盖到，所以我们还需要额外书写 Babel 插件来替换 <!-- /react-text --><code data-reactid="110">React.createElment</code><!-- react-text: 111 --> <!-- /react-text --><code data-reactid="112">React.createFactory</code><!-- react-text: 113 --> 关键字<!-- /react-text --></p><h3 id="替换引入路径" data-reactid="114"><a href="#%E6%9B%BF%E6%8D%A2%E5%BC%95%E5%85%A5%E8%B7%AF%E5%BE%84" aria-hidden="true" data-reactid="115"><span class="icon icon-link" data-reactid="116"></span></a><!-- react-text: 117 -->替换引入路径<!-- /react-text --></h3><p data-reactid="118"><!-- react-text: 119 -->我们还可以换种思路，将 <!-- /react-text --><code data-reactid="120">import React from &#x27;react&#x27;</code><!-- react-text: 121 --> 替换成 <!-- /react-text --><code data-reactid="122">import React from &#x27;my-custom-react&#x27;</code></p><p data-reactid="123"><!-- react-text: 124 -->在 <!-- /react-text --><code data-reactid="125">&#x27;my-custom-react&#x27;</code><!-- react-text: 126 --> 文件中，覆盖 React<!-- /react-text --></p><pre data-reactid="127"><code data-query="{}" data-lang="data-lang" data-reactid="128">const React = require(&#x27;react&#x27;)

module.exports = Object.assign({}, React, {
    createElement: require(&#x27;./my-custom-create-element&#x27;),
    createFactory: require(&#x27;./my-custom-create-factory&#x27;)
})
</code></pre><p data-reactid="129"><!-- react-text: 130 -->同时我们在 <!-- /react-text --><code data-reactid="131">./my-custom-create-element</code><!-- react-text: 132 --> 和 <!-- /react-text --><code data-reactid="133">./my-custom-create-factory</code><!-- react-text: 134 --> 文件中用到的 <!-- /react-text --><code data-reactid="135">React.createElement</code><!-- react-text: 136 --> 和 <!-- /react-text --><code data-reactid="137">React.createFactory</code><!-- react-text: 138 --> 需要是原始的，不然会陷入无穷套娃中。<!-- /react-text --></p><p data-reactid="139"><!-- react-text: 140 -->下面有两种方式来实现这种方式 1. babel 插件修改规则 2. <!-- /react-text --><a href="https://github.com/webpack/enhanced-resolve" data-reactid="141">enhanced-resolve</a><!-- react-text: 142 --> 插件修改规则<!-- /react-text --></p><p data-reactid="143"><!-- react-text: 144 -->enhanced-resolve 是 Webpack 中使用的可拔插的 resolve 路径包，其实现了 Node.js 中的 <!-- /react-text --><code data-reactid="145">require.resolve</code><!-- react-text: 146 --> 算法(支持异步)，我们可以利用其暴露的一些勾子来自定义自己的 <!-- /react-text --><code data-reactid="147">resovle</code><!-- react-text: 148 --> 逻辑。即我们可以将 <!-- /react-text --><code data-reactid="149">resolve(&#x27;react&#x27;)</code><!-- react-text: 150 --> 输出为 <!-- /react-text --><code data-reactid="151">&#x27;my-custom-react&#x27;</code></p><p data-reactid="152"><!-- react-text: 153 -->以上两种方式各有优劣 |方式 | 优点 | 缺点| |---|----|----| |Babel插件|生态好，基本可以方便接入任何构建工具<!-- /react-text --><code data-reactid="154">webpack</code><!-- react-text: 155 -->/<!-- /react-text --><code data-reactid="156">rollup</code><!-- react-text: 157 --> 等|对于动态引入的模块，匹配麻烦，如 require(&#x27;rea&#x27; + &#x27;ct&#x27;)| |enhanced-resolve插件|webpack 接入方便，实现方便|在非webpack生态中，可能不好接入|<!-- /react-text --></p><p data-reactid="158">除了以上两种思路之外，还有一个不大合适的思路</p><h3 id="自定义-react-renderer" data-reactid="159"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-react-renderer" aria-hidden="true" data-reactid="160"><span class="icon icon-link" data-reactid="161"></span></a><!-- react-text: 162 -->自定义 React Renderer<!-- /react-text --></h3><p data-reactid="163"><!-- react-text: 164 -->在这里不深入展开，主要是自己使用<!-- /react-text --><a href="https://github.com/facebook/react/tree/master/packages/react-reconciler" data-reactid="165">react-reconciler</a><!-- react-text: 166 -->实现 <!-- /react-text --><code data-reactid="167">ReactDOM.render</code><!-- react-text: 168 -->。<!-- /react-text --></p><p data-reactid="169"><!-- react-text: 170 -->对于该需求，自己实现一个 <!-- /react-text --><code data-reactid="171">ReactDOM.render</code><!-- react-text: 172 --> 有些舍近求远，该方式更适合于渲染同一份 React 代码，在不同的运行环境（如浏览器: <!-- /react-text --><code data-reactid="173">ReactDOM</code><!-- react-text: 174 -->、服务端 <!-- /react-text --><code data-reactid="175">ReactDOMServer</code><!-- react-text: 176 -->、移动端 <!-- /react-text --><code data-reactid="177">ReactNative</code><!-- react-text: 178 -->）<!-- /react-text --></p><h1 id="实现" data-reactid="179"><a href="#%E5%AE%9E%E7%8E%B0" aria-hidden="true" data-reactid="180"><span class="icon icon-link" data-reactid="181"></span></a><!-- react-text: 182 -->实现<!-- /react-text --></h1><p data-reactid="183"><!-- react-text: 184 -->在这里，我使用的是 <!-- /react-text --><code data-reactid="185">enhanced-resolve</code><!-- react-text: 186 --> 插件实现 <!-- /react-text --><a href="https://github.com/imcuttle/module-mock-plugin" data-reactid="187">module-mock-plugin</a><!-- react-text: 188 -->，这里有一篇相当详尽的 <!-- /react-text --><a href="https://juejin.im/post/5c6b78cdf265da2da15db125" data-reactid="189"><code data-reactid="190">Webpack resolve</code></a><!-- react-text: 191 --> 介绍<!-- /react-text --></p><p data-reactid="192">使用该插件，我们可以如下组织我们的项目代码</p><pre data-reactid="193"><code data-query="{}" data-lang="data-lang" data-reactid="194">src/
    __mock/
        react/ # custom react
node_modules/
    react/
</code></pre><p data-reactid="195"><!-- react-text: 196 -->在 <!-- /react-text --><code data-reactid="197">src/__mock/react/index.js</code><!-- react-text: 198 --> 中可以覆写 React 实现<!-- /react-text --></p></article></div><div class="gitment-container" data-reactid="199"></div><div class="paginator" data-reactid="200"><a title="自研协同文档服务 - Dozo " class="prev" href="/自研协同文档服务-dozo" data-reactid="201">Prev</a><a title="孤云独去闲" class="next" href="/孤云独去闲" data-reactid="202">Next</a></div></div></main><footer data-reactid="203"><div class="copyright" data-reactid="204"><p data-reactid="205"><!-- react-text: 206 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="207">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
