<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> Node.js 前后端分离开发新思路 - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="-849902244"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">Node.js 前后端分离开发新思路</h1><div class="post-info" data-reactid="12"><time datetime="2019-06-24T14:42:24+00:00" data-reactid="13">Jun 24, 2019 2:42 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p data-reactid="17"><!-- react-text: 18 -->从事 Web 开发的程序员，对于前后端分离模式多半不陌生，这也是目前主流的 Web 开发模式，具体关于前后端分离的模式可以参看文章<!-- /react-text --><a href="https://juejin.im/post/5b71302351882560ea4afbb8" data-reactid="19">《你不得不了解的前后端分离原理! 》</a><!-- react-text: 20 -->，在这里写者不进行说明。<!-- /react-text --></p><p data-reactid="21">好了，让我们进入主题 —— Node.js 前后端分离开发新思路\ 在进入新思路之前，我们现需要了解“老思路”是什么？（注意：后面的案例都是以全栈工程师为例，即前后端代码在一起）</p><h2 id="前后端分离开发常规思路" data-reactid="22"><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF" aria-hidden="true" data-reactid="23"><span class="icon icon-link" data-reactid="24"></span></a><!-- react-text: 25 -->前后端分离开发常规思路<!-- /react-text --></h2><p data-reactid="26"><!-- react-text: 27 -->以一种具体情景为例：小牛是一名全栈工程师，喜欢前端后端全干，前端使用目前主流的 Webpack + React 全家桶（或 Vue 全家桶），后端使用 express（或 Koa），小牛在同时开发前后端过程中，开启两个进程（前后端各一个），同时使用 <!-- /react-text --><a href="https://www.npmjs.com/package/nodemon" data-reactid="28">nodemon</a><!-- react-text: 29 --> 热重启后台服务，使用 Webpack Proxy 转发实现跨域请求，然后哼哧哼哧开发。 如例子：<!-- /react-text --><a href="https://juejin.im/entry/58aa5ccf2f301e006c32a3be" data-reactid="30">一个前后端分离的简单案例</a></p><pre data-reactid="31"><code class="hljs language-text" data-query="{}" data-lang="text" data-reactid="32"><!-- react-text: 33 --> Process 1                Process 2
 ___________          ____________________
|<!-- /react-text --><span class="hljs-string" data-reactid="34">           </span><!-- react-text: 35 -->|<!-- /react-text --><span class="hljs-string" data-reactid="36"> Proxy  </span><!-- react-text: 37 -->|<!-- /react-text --><span class="hljs-string" data-reactid="38">          </span><!-- react-text: 39 -->|<!-- /react-text --><span class="hljs-string" data-reactid="40">         </span><!-- react-text: 41 -->|
|<!-- /react-text --><span class="hljs-string" data-reactid="42"> FrontEnd  </span><!-- react-text: 43 -->|<!-- /react-text --><span class="hljs-string" data-reactid="44"> &lt;----&gt; </span><!-- react-text: 45 -->|<!-- /react-text --><span class="hljs-string" data-reactid="46"> Nodemon  </span><!-- react-text: 47 -->|<!-- /react-text --><span class="hljs-string" data-reactid="48"> BackEnd </span><!-- react-text: 49 -->|
|<!-- /react-text --><span class="hljs-string" data-reactid="50">           </span><!-- react-text: 51 -->|<!-- /react-text --><span class="hljs-string" data-reactid="52">        </span><!-- react-text: 53 -->|<!-- /react-text --><span class="hljs-string" data-reactid="54">          </span><!-- react-text: 55 -->|<!-- /react-text --><span class="hljs-string" data-reactid="56"> (cp 1)  </span><!-- react-text: 57 -->|
-------------        ----------------------<!-- /react-text --></code></pre><p data-reactid="58">如上示意，该模式启动需要启动两个进程（前端 和 Nodemon），其中 BackEnd 程序作为子进程挂载在 Nodemon 进程，而且前端和 Nodemon 进程通过 Proxy 转发实现通信。</p><p data-reactid="59">乍看一下这样挺美好的，但是这种模式的缺陷也很容易暴露出来</p><h3 id="传统思路的缺陷" data-reactid="60"><a href="#%E4%BC%A0%E7%BB%9F%E6%80%9D%E8%B7%AF%E7%9A%84%E7%BC%BA%E9%99%B7" aria-hidden="true" data-reactid="61"><span class="icon icon-link" data-reactid="62"></span></a><!-- react-text: 63 -->传统思路的缺陷<!-- /react-text --></h3><ol data-reactid="64"><li data-reactid="65">BackEnd 程序复杂度提升后，启动时间也变得不可控，每次热启动后台服务时间过长；</li><li data-reactid="66">需要同时开启两个进程，一定程度提高了开发成本</li></ol><p data-reactid="67">那么对于上述的问题，需要介绍一下我们今天的主角！</p><h2 id="前后端分离开发新思路" data-reactid="68"><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91%E6%96%B0%E6%80%9D%E8%B7%AF" aria-hidden="true" data-reactid="69"><span class="icon icon-link" data-reactid="70"></span></a><!-- react-text: 71 -->前后端分离开发新思路<!-- /react-text --></h2><p data-reactid="72"><!-- react-text: 73 -->依旧是小牛的例子，大牛同样使用小牛相同的前后端技术栈，但不同的是，大牛不使用 Nodemon 实现后端程序的热重启，而是使用类似 <!-- /react-text --><a href="https://webpack.docschina.org/guides/hot-module-replacement/" data-reactid="74">Webpack HMR（Hot Module Replacement）</a><!-- react-text: 75 --> 的思路，热更新 Node.js 中的 module，具体实现使用 <!-- /react-text --><a href="https://github.com/imcuttle/hot-module-require" data-reactid="76">hot-module-require</a><!-- react-text: 77 -->。<!-- /react-text --></p><p data-reactid="78">原理图如下，前后端在一个进程（同一个端口）中，通过 Fs Watcher 热替换更新的 Module，而不是全量重启。</p><pre data-reactid="79"><code class="hljs language-text" data-query="{}" data-lang="text" data-reactid="80"><span class="hljs-code" data-reactid="81">          Process</span><!-- react-text: 82 -->
<!-- /react-text --><span class="hljs-code" data-reactid="83"> _________________________</span><!-- react-text: 84 -->
|          | File Watcher |
| Frontend |       +      |
<!-- /react-text --><span class="hljs-section" data-reactid="85">|          |    Backend   |
---------------------------</span></code></pre><p data-reactid="86">其中核心的 Node.js 端 HMR 实现思路如下</p><h3 id="nodejs-端-hmr-实现思路" data-reactid="87"><a href="#nodejs-%E7%AB%AF-hmr-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF" aria-hidden="true" data-reactid="88"><span class="icon icon-link" data-reactid="89"></span></a><!-- react-text: 90 -->Node.js 端 HMR 实现思路<!-- /react-text --></h3><p data-reactid="91"><!-- react-text: 92 -->首先我们来看看一个程序的依赖图关系 <!-- /react-text --><img src="https://i.loli.net/2019/06/25/5d1186625830173192.png" data-reactid="93"/></p><ol data-reactid="94"><li data-reactid="95"><!-- react-text: 96 -->得到程序依赖图<!-- /react-text --><br data-reactid="97"/><code data-reactid="98">index.js</code><!-- react-text: 99 --> 为程序入口，可以通过静态代码分析，得到 <!-- /react-text --><code data-reactid="100">index.js</code><!-- react-text: 101 --> 的直接依赖 <!-- /react-text --><code data-reactid="102">express/index.js</code><!-- react-text: 103 --> 和 <!-- /react-text --><code data-reactid="104">lib/middleware.js</code><!-- react-text: 105 -->，然后递归地进行，依次得到一个完整的依赖图，算法具体实现参看 <!-- /react-text --><a href="https://github.com/imcuttle/detect-dep" data-reactid="106">detect-dep</a><!-- react-text: 107 -->。<!-- /react-text --></li><li data-reactid="108"><!-- react-text: 109 -->监听依赖图中涉及到的文件<!-- /react-text --><br data-reactid="110"/><!-- react-text: 111 -->需要热更新，那就离不开文件改动的监听，所以进行依赖图中文件的监听（实际上只需要监听本地的文件，排除 node builtin modules 和第三方模块）<!-- /react-text --></li><li data-reactid="112"><p data-reactid="113"><!-- react-text: 114 -->某个时候，<!-- /react-text --><code data-reactid="115">lib/to-array.js</code><!-- react-text: 116 --> 文件发生改动！<!-- /react-text --></p><ol start="0" data-reactid="117"><li data-reactid="118"><!-- react-text: 119 -->删除更新模块 A 缓存 (<!-- /react-text --><code data-reactid="120">delete require.caches[modulePath]</code><!-- react-text: 121 -->)<!-- /react-text --></li><li data-reactid="122">以 A 为入口，更新依赖图</li><li data-reactid="123">发出 A 更新的信号</li><li data-reactid="124">根据依赖图，得到依赖 A 的模块集合 B</li><li data-reactid="125"><!-- react-text: 126 -->向上回溯 B，再次从 0. 开始执行<!-- /react-text --><br data-reactid="127"/><!-- react-text: 128 -->其中这一步需要注意环状依赖的处理，需要保证一条依赖路径，不进行重复的依赖更新。 如 <!-- /react-text --><code data-reactid="129">lib/to-array.js</code><!-- react-text: 130 -->，存在两条路径：<!-- /react-text --><code data-reactid="131">lib/to-array.js -&gt; lib/middleware.js -&gt; index/js</code><!-- react-text: 132 --> 和 <!-- /react-text --><code data-reactid="133">lib/to-array.js -&gt; lib/express-utils.js -&gt; lib/middleware.js -&gt; index/js</code></li></ol></li></ol><p data-reactid="134"><!-- react-text: 135 -->以上算法的具体实现参看 <!-- /react-text --><a href="https://github.com/imcuttle/hot-module-require" data-reactid="136">hot-module-require</a><!-- react-text: 137 -->， 具体的应用代码可以参看<!-- /react-text --><a href="https://github.com/imcuttle/live-markd/blob/master/client" data-reactid="138">这里</a></p><p data-reactid="139">相比与传统模式，新思路的优点十分突出。</p><h3 id="优势" data-reactid="140"><a href="#%E4%BC%98%E5%8A%BF" aria-hidden="true" data-reactid="141"><span class="icon icon-link" data-reactid="142"></span></a><!-- react-text: 143 -->优势<!-- /react-text --></h3><ol data-reactid="144"><li data-reactid="145">细化 Module 更新的颗粒度，避免不必要的更新开销，大大缩减服务更新时间</li><li data-reactid="146">只有一个进程，一定程度上缩减了进程调度，进程切换的开销</li></ol><p data-reactid="147">用一个具体的场景对比举例，如后端使用内存存储用户 session 数据。如使用传统方式开发，则每一次更新后台代码，都会丢失内存中的用户数据，所以每次都需要重新进行登录；但是在新方式，只需要不修改用户登录模块代码，则不会重置用户 session 数据，即不需重新登录。</p><pre data-reactid="148"><code data-query="{}" data-lang="data-lang" data-reactid="149">      Backend 入口
  /                \
 -                   -
登录 --&gt; Common &lt;-- 某业务逻辑
</code></pre><p data-reactid="150">如上简易模块依赖图，A -&gt; B 表示 A 依赖 B，所以上图中，Backend 入口直接依赖 “登录”和“某业务逻辑”，间接依赖“Common”；这时候我们只有在修改了“登录”或“Common”的代码，才会触发登录模块的热更新。</p><p data-reactid="151">但是新方法也不是无缺陷</p><h3 id="缺陷" data-reactid="152"><a href="#%E7%BC%BA%E9%99%B7" aria-hidden="true" data-reactid="153"><span class="icon icon-link" data-reactid="154"></span></a><!-- react-text: 155 -->缺陷<!-- /react-text --></h3><ol data-reactid="156"><li data-reactid="157">如代码模块中包含全局副作用代码，可能会有各种奇怪问题出现</li></ol><h2 id="扩展" data-reactid="158"><a href="#%E6%89%A9%E5%B1%95" aria-hidden="true" data-reactid="159"><span class="icon icon-link" data-reactid="160"></span></a><!-- react-text: 161 -->扩展<!-- /react-text --></h2><p data-reactid="162">使用 Node.js HMR 可以实现各种各样的热更新体验，如热更新 proxy，热更新 mock 数据，热更新配置文件...，非常 Cool！</p><h2 id="相关材料" data-reactid="163"><a href="#%E7%9B%B8%E5%85%B3%E6%9D%90%E6%96%99" aria-hidden="true" data-reactid="164"><span class="icon icon-link" data-reactid="165"></span></a><!-- react-text: 166 -->相关材料<!-- /react-text --></h2><ul data-reactid="167"><li data-reactid="168"><a href="https://github.com/imcuttle/detect-dep" data-reactid="169">静态依赖分析</a></li><li data-reactid="170"><a href="https://github.com/imcuttle/hot-module-require" data-reactid="171">Node.js HMR 实现</a></li><li data-reactid="172"><a href="https://github.com/imcuttle/live-markd/blob/master/client" data-reactid="173">Node.js HMR 在开发环境中的使用</a></li><li data-reactid="174"><a href="https://nodejs.org/api/modules.html#modules_cycles" data-reactid="175">Node.js 环状依赖</a></li></ul></article></div><div class="gitment-container" data-reactid="176"></div><div class="paginator" data-reactid="177"><a title="DIY 一个 CommonJS 运行环境吧" class="prev" href="/diy-一个-commonjs-运行环境吧" data-reactid="178">Prev</a><a title="如何实现 “灭霸” 响指动效" class="next" href="/about-snap-fade-away" data-reactid="179">Next</a></div></div></main><footer data-reactid="180"><div class="copyright" data-reactid="181"><p data-reactid="182"><!-- react-text: 183 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="184">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
