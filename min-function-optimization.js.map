{"version":3,"sources":["webpack:///min-function-optimization.js","webpack:///./source/_articles/min-function-optimization.md"],"names":["webpackJsonp","1198","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,ysNACAC,OACAC,oBACAC","file":"min-function-optimization.js","sourcesContent":["webpackJsonp([66,113],{\n\n/***/ 1198:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><blockquote><p>几周没有更新文章了，因为在忙着其他事，最近又是春招时期，又到了笔试面试刷题的时候，我就来讲讲常用算法中的 迭代与递归，甚至于延伸至尾递归。</p></blockquote><h2 id=问题提出><a href=#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>问题提出</h2><blockquote><p>用 JavaScript 实现一个类 Math.min 的方法。</p><p>min(1, 2, -3, 100, 7)<br>=> -3</p></blockquote><h2 id=方法一：迭代><a href=#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方法一：迭代</h2><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_0</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> min = <span class=hljs-built_in>arguments</span>[<span class=hljs-number>0</span>];\\n    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>1</span>; i &lt; <span class=hljs-built_in>arguments</span>.length; i++) {\\n        min = min > <span class=hljs-built_in>arguments</span>[i] ? <span class=hljs-built_in>arguments</span>[i] : min;\\n    }\\n    <span class=hljs-keyword>return</span> min;\\n}</code></pre><p>当然有些同学喜欢用些“高级”的 api，于是出现下面的方法：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_1</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> numbers = [].slice.call(<span class=hljs-built_in>arguments</span>)\\n    <span class=hljs-keyword>return</span> numbers.slice(<span class=hljs-number>1</span>).reduce(<span class=hljs-function>(<span class=hljs-params>p, n</span>) =></span> {\\n        <span class=hljs-keyword>return</span> p > n ? n : p;\\n    }, numbers[<span class=hljs-number>0</span>]);\\n}</code></pre><p>这种方法很直观地就可以想到，面试官肯定是不会善罢甘休的，继续延伸下去问<br>“用递归方式怎么实现呢？”</p><h2 id=方法二：递归><a href=#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方法二：递归</h2><p>诚然，递归往往会占用更多的系统资源，还可能会导致栈溢出等问题，但递归也是很能考察一个程序员，良好逻辑思维能力的知识点。</p><pre><code data-query={} data-lang>function min_2 () {\\n    var numbers = [].slice.call(arguments);\\n    if (numbers.length === 1) {\\n        return numbers[0];\\n    } else {\\n        var min = min_2.apply(null, numbers.slice(1));\\n        return min > numbers[0] ? numbers[0] : min;\\n    }\\n}\\n</code></pre><p>此题也不难写成递归算法，但是面试官可能还是会深究下去，可能会比较其中不同方式的差异。</p><h2 id=延伸问题><a href=#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><em>延伸问题</em></h2><ol><li><p><code>min0()</code>方法与 <code>min1()</code>方法比较，哪个效率会更高些（时间复杂度更低）呢？</p><p>很显然，min0 效率更高，其不仅多了一步 <code>slice</code>，而且还额外用 <code>reduce</code> 方法创建了一个闭包，显然底层调用会更多</p></li><li><p>如果把 <code>arguments</code> 转化成普通数组的 <code>slice</code> 方法用 <code>Array.from</code> 替换，哪个效率更高呢？</p><p>关于该问题，则需要用事实来说话了：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>slice_time</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.time(<span class=hljs-string>'slice'</span>);\\n    [].slice.call(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-built_in>console</span>.timeEnd(<span class=hljs-string>'slice'</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>from_time</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.time(<span class=hljs-string>'from'</span>);\\n    <span class=hljs-built_in>Array</span>.from(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-built_in>console</span>.timeEnd(<span class=hljs-string>'from'</span>);\\n}\\n\\n<span class=hljs-keyword>var</span> arr = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Array</span>(<span class=hljs-number>10000</span>).fill(<span class=hljs-number>1</span>);\\nslice_time.apply(<span class=hljs-literal>null</span>, arr);\\nfrom_time.apply(<span class=hljs-literal>null</span>, arr);\\n\\n<span class=hljs-comment>// slice: 0.267ms</span>\\n<span class=hljs-comment>// from: 5.787ms</span></code></pre><p>结果很明显，所以我们应该尽量不用<code>Array.from</code></p></li><li><p><code>min(1, 3, 4, 5)</code> 和 <code>min([1, 3, 4, 5])</code>的两种传参方式，各有什么优劣？</p><p>借用问题2的代码，如果数组大小设置的足够大，很有可能会看到 <code>Maximum call stack size exceeded</code> 错误，也就是栈溢出。但是方法中并没有递归调用啊，为什么会存在栈溢出呢？<br>回答该问题，就需要对编译原理的知识有所了解了，函数中的参数也是会压入栈中的，一般是参数从右往左开始，依次压入（还分为值传递和引用传递等），所以如果参数列表过长，也是会导致栈溢出的。</p><p>那第一种传参方式有什么好的呢？本人觉得除了书写更方便以外，还会把本来是（数组）引用传递的，更改为值传递（该例中是数字）</p></li><li><p>如何改造递归方法中的 <code>min_2</code> 方法，使其成为尾递归，有效避免栈溢出的问题？</p><p>首先我们知道递归最大的问题就是容易导致栈溢出，因为每次调用，内存中都需要保存调用记录。 那么尾递归则是递归的一种特殊形式，可以通过尾递归，来覆盖当前的调用环境(主要是参数)，成为自己的调用环境。 具体如下代码：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_3</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> numbers = [].slice.call(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>inner</span> (<span class=hljs-params>arr, min_pos, pos</span>) </span>{\\n<span class=hljs-meta>        'use strict'</span>;\\n        <span class=hljs-keyword>var</span> min = arr[min_pos], val = arr[pos];\\n        <span class=hljs-keyword>if</span> (pos === arr.length<span class=hljs-number>-1</span>) {\\n            <span class=hljs-keyword>return</span> min;\\n        } <span class=hljs-keyword>else</span> {\\n            <span class=hljs-keyword>if</span> (val &lt; min) {\\n                min_pos = pos;\\n            }\\n            <span class=hljs-keyword>return</span> inner(arr, min_pos, pos+<span class=hljs-number>1</span>);\\n        }\\n    }\\n    <span class=hljs-keyword>return</span> inner(numbers, <span class=hljs-number>0</span>, <span class=hljs-number>1</span>);\\n}</code></pre><p>可以看到，在 inner 递归方法中，在最后 <strong><code>return inner(...)</code></strong>，没有其他的参数，所以调用该方法是可以覆盖掉当前调用环境的，所以并没有爆栈。<br>chrome中默认未开启尾递归优化，需要在函数中加上<code>'use strict';</code> 同时需要在 <code>chrome://flags/#enable-javascript-harmony</code> 中开启</p></li></ol><h2 id=其他资料><a href=#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他资料</h2><p><a href=http://www.ruanyifeng.com/blog/2015/04/tail-call.html>尾调用优化</a></p>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// min-function-optimization.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><blockquote><p>几周没有更新文章了，因为在忙着其他事，最近又是春招时期，又到了笔试面试刷题的时候，我就来讲讲常用算法中的 迭代与递归，甚至于延伸至尾递归。</p></blockquote><h2 id=问题提出><a href=#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>问题提出</h2><blockquote><p>用 JavaScript 实现一个类 Math.min 的方法。</p><p>min(1, 2, -3, 100, 7)<br>=> -3</p></blockquote><h2 id=方法一：迭代><a href=#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方法一：迭代</h2><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_0</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> min = <span class=hljs-built_in>arguments</span>[<span class=hljs-number>0</span>];\\n    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>1</span>; i &lt; <span class=hljs-built_in>arguments</span>.length; i++) {\\n        min = min > <span class=hljs-built_in>arguments</span>[i] ? <span class=hljs-built_in>arguments</span>[i] : min;\\n    }\\n    <span class=hljs-keyword>return</span> min;\\n}</code></pre><p>当然有些同学喜欢用些“高级”的 api，于是出现下面的方法：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_1</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> numbers = [].slice.call(<span class=hljs-built_in>arguments</span>)\\n    <span class=hljs-keyword>return</span> numbers.slice(<span class=hljs-number>1</span>).reduce(<span class=hljs-function>(<span class=hljs-params>p, n</span>) =></span> {\\n        <span class=hljs-keyword>return</span> p > n ? n : p;\\n    }, numbers[<span class=hljs-number>0</span>]);\\n}</code></pre><p>这种方法很直观地就可以想到，面试官肯定是不会善罢甘休的，继续延伸下去问<br>“用递归方式怎么实现呢？”</p><h2 id=方法二：递归><a href=#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>方法二：递归</h2><p>诚然，递归往往会占用更多的系统资源，还可能会导致栈溢出等问题，但递归也是很能考察一个程序员，良好逻辑思维能力的知识点。</p><pre><code data-query={} data-lang>function min_2 () {\\n    var numbers = [].slice.call(arguments);\\n    if (numbers.length === 1) {\\n        return numbers[0];\\n    } else {\\n        var min = min_2.apply(null, numbers.slice(1));\\n        return min > numbers[0] ? numbers[0] : min;\\n    }\\n}\\n</code></pre><p>此题也不难写成递归算法，但是面试官可能还是会深究下去，可能会比较其中不同方式的差异。</p><h2 id=延伸问题><a href=#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><em>延伸问题</em></h2><ol><li><p><code>min0()</code>方法与 <code>min1()</code>方法比较，哪个效率会更高些（时间复杂度更低）呢？</p><p>很显然，min0 效率更高，其不仅多了一步 <code>slice</code>，而且还额外用 <code>reduce</code> 方法创建了一个闭包，显然底层调用会更多</p></li><li><p>如果把 <code>arguments</code> 转化成普通数组的 <code>slice</code> 方法用 <code>Array.from</code> 替换，哪个效率更高呢？</p><p>关于该问题，则需要用事实来说话了：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>slice_time</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.time(<span class=hljs-string>'slice'</span>);\\n    [].slice.call(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-built_in>console</span>.timeEnd(<span class=hljs-string>'slice'</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>from_time</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.time(<span class=hljs-string>'from'</span>);\\n    <span class=hljs-built_in>Array</span>.from(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-built_in>console</span>.timeEnd(<span class=hljs-string>'from'</span>);\\n}\\n\\n<span class=hljs-keyword>var</span> arr = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Array</span>(<span class=hljs-number>10000</span>).fill(<span class=hljs-number>1</span>);\\nslice_time.apply(<span class=hljs-literal>null</span>, arr);\\nfrom_time.apply(<span class=hljs-literal>null</span>, arr);\\n\\n<span class=hljs-comment>// slice: 0.267ms</span>\\n<span class=hljs-comment>// from: 5.787ms</span></code></pre><p>结果很明显，所以我们应该尽量不用<code>Array.from</code></p></li><li><p><code>min(1, 3, 4, 5)</code> 和 <code>min([1, 3, 4, 5])</code>的两种传参方式，各有什么优劣？</p><p>借用问题2的代码，如果数组大小设置的足够大，很有可能会看到 <code>Maximum call stack size exceeded</code> 错误，也就是栈溢出。但是方法中并没有递归调用啊，为什么会存在栈溢出呢？<br>回答该问题，就需要对编译原理的知识有所了解了，函数中的参数也是会压入栈中的，一般是参数从右往左开始，依次压入（还分为值传递和引用传递等），所以如果参数列表过长，也是会导致栈溢出的。</p><p>那第一种传参方式有什么好的呢？本人觉得除了书写更方便以外，还会把本来是（数组）引用传递的，更改为值传递（该例中是数字）</p></li><li><p>如何改造递归方法中的 <code>min_2</code> 方法，使其成为尾递归，有效避免栈溢出的问题？</p><p>首先我们知道递归最大的问题就是容易导致栈溢出，因为每次调用，内存中都需要保存调用记录。 那么尾递归则是递归的一种特殊形式，可以通过尾递归，来覆盖当前的调用环境(主要是参数)，成为自己的调用环境。 具体如下代码：</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>min_3</span> (<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> numbers = [].slice.call(<span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>inner</span> (<span class=hljs-params>arr, min_pos, pos</span>) </span>{\\n<span class=hljs-meta>        'use strict'</span>;\\n        <span class=hljs-keyword>var</span> min = arr[min_pos], val = arr[pos];\\n        <span class=hljs-keyword>if</span> (pos === arr.length<span class=hljs-number>-1</span>) {\\n            <span class=hljs-keyword>return</span> min;\\n        } <span class=hljs-keyword>else</span> {\\n            <span class=hljs-keyword>if</span> (val &lt; min) {\\n                min_pos = pos;\\n            }\\n            <span class=hljs-keyword>return</span> inner(arr, min_pos, pos+<span class=hljs-number>1</span>);\\n        }\\n    }\\n    <span class=hljs-keyword>return</span> inner(numbers, <span class=hljs-number>0</span>, <span class=hljs-number>1</span>);\\n}</code></pre><p>可以看到，在 inner 递归方法中，在最后 <strong><code>return inner(...)</code></strong>，没有其他的参数，所以调用该方法是可以覆盖掉当前调用环境的，所以并没有爆栈。<br>chrome中默认未开启尾递归优化，需要在函数中加上<code>'use strict';</code> 同时需要在 <code>chrome://flags/#enable-javascript-harmony</code> 中开启</p></li></ol><h2 id=其他资料><a href=#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他资料</h2><p><a href=http://www.ruanyifeng.com/blog/2015/04/tail-call.html>尾调用优化</a></p>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/min-function-optimization.md\n// module id = 1198\n// module chunks = 66"],"sourceRoot":""}