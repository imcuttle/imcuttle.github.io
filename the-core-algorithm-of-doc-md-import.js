webpackJsonp([11,90],{1052:function(n,a){n.exports={content:'<h2 id="算法需要做什么事情"><a href="#%E7%AE%97%E6%B3%95%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85" aria-hidden="true"><span class="icon icon-link"></span></a>算法需要做什么事情</h2>\n<ul>\n<li>\n<p>Input -> Output<br>\n将原始的markdown文本解析成为一颗树形结构。</p>\n<pre><code class="hljs language-markdown" data-query="{}" data-lang="markdown"><span class="hljs-section"># A               ->  # A --- i\'m an apple.</span>\ni\'m an apple.             |-- i\'m an egg.\ni\'m an egg.               |-- > <span class="hljs-code">```\n> ```                     |   > code A\n> code A                  |   > ``` \n> ```                     \\-- ## A-1 --- text in A-1 \n                                    |-- 1. A-1-1\n## A-1                               |      |-- description1 in A-1-1 \n                                    |      \\-- description2 in A-1-1\ntext in A-1                          |-- 2. A-1-2\n                                    |-- 3. A-1-3\n1. A-1-1                             |-- not description \ndescription1 in A-1-1                \\-- ~~~\\ncode\\n~~~\ndescription2 in A-1-1\n2. A-1-2\n\n3. A-1-3\n\nnot description\n\n~~~\ncode B\n~~~</span></code></pre>\n</li>\n</ul>\n<h2 id="树形数据结构的储存方式"><a href="#%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>树形数据结构的储存方式</h2>\n<p>简单的有两种(Java 代码，针对于<strong>单棵树</strong>)</p>\n<ol>\n<li>\n<p>多叉树  </p>\n<pre><code data-query="{}" data-lang="">    root\n/   |  \\\na1   a2   a3\n|    / \\    \\\nnull b1  b2   b3\n    |     \\     \\\n    null   null   null\n</code></pre>\n<pre><code class="hljs language-java" data-query="{}" data-lang="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{\n    TreeNode[] children;\n    Object value;\n    <span class="hljs-comment">// 可有可无</span>\n    TreeNode parent;\n}\n\n<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>{\n    TreeNode root;\n}</code></pre>\n</li>\n<li>\n<p>一维数组  </p>\n<pre><code data-query="{}" data-lang="">{}:          {}:        {}:        {}:        {}:        {}:         ...\npid: null    pid: 0;    pid: 0;    pid: 0;    pid: 2;    pid: 2;\nval: root;   val: a1;   val: a2;   val: a3;   val: b1;   val: b2;   \n</code></pre>\n<p>其中节点id是数组中的索引位置。<br>\n这种方式相比于多叉树方法，逻辑更简单，但是对于父子之间的关系联系没有多叉树"密切"。</p>\n<pre><code class="hljs language-java" data-query="{}" data-lang="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{\n    Object value;\n    <span class="hljs-keyword">int</span> parentId;\n}</code></pre>\n</li>\n</ol>\n<h2 id="思考"><a href="#%E6%80%9D%E8%80%83" aria-hidden="true"><span class="icon icon-link"></span></a>思考</h2>\n<p>最后树的存储方式使用的是<strong>一维数组</strong>，\b\b更多的原因是doc本身用的就是这种方式传参。</p>\n<p>下面\b较为详细地解释解析markdown文本的算法。  </p>\n<p><strong>注意：以下\b语法解析单元均是以行为单位</strong>\n1. 首先需要"拎出"会\b产生父子关系的语法<br>\n形如:</p>\n<pre><code data-query="{}" data-lang="">```\n# Head\n\n## child of Head\n\n- Disorder  Item A\n    child of Item A\n- Disorder  Item B\n\n1. Order Item 1\n    child of Item 1\n2. Order Item 2\n```\n</code></pre>\n<ol start="2">\n<li>\n<p>"拎出"多行的语法块<br>\n形如:</p>\n<pre><code data-query="{}" data-lang="">```\nint a = 123;\n```\n\n> BlockQuote line1\n> BlockQuote line2\n</code></pre>\n</li>\n<li>\n<p>"拎出"\b空行<br>\n因为空行可能是区分父子关系的依据  </p>\n<pre><code data-query="{}" data-lang=""> - item a\n\n     child of a\n\n   i\'m child of a\n\n i\'m not child of a\n\n - item b\n     child of b\n\n     i\'m child of b\n</code></pre>\n</li>\n</ol>\n<pre><code data-query="{}" data-lang="">i\'m not child of b\n</code></pre>\n<pre><code data-query="{}" data-lang="">4. \b匹配一些无关的语法行\n\n### 一些特殊情况\n\n1. 列表的父子关系区分  \n ```\n - a                a\n - b                b \n  - c         ->     \\- c\n   - d               |   \\- d\n  - e                |- e\n ```\n\n ```\n - c                c\n   - d        ->     \\- d\n  - e                    \\- e\n ```\n\n2. 标题的父子关系区别（较列表简单）  \n ```\n # a           a\n ### b          \\- b\n ## c     ->    |- c\n ## d           |- d\n # e           e  \n ```\n\n[源码实现](https://github.com/imcuttle/doc-md-import/blob/master/lib/parser-factory/md-to-tree.js)\n</code></pre>\n',extra:{}}}});