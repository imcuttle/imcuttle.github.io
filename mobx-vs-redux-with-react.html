<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> Mobx VS Redux（React状态控制） - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="-2089457261"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">Mobx VS Redux（React状态控制）</h1><div class="post-info" data-reactid="12"><time datetime="2017-02-26T16:45:45+00:00" data-reactid="13">Feb 26, 2017 4:45 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><blockquote data-reactid="17"><p data-reactid="18"><!-- react-text: 19 -->我人就是闲不下来 - -<!-- /react-text --><br data-reactid="20"/><!-- react-text: 21 -->辛辛苦苦上了一周班，周末又捣鼓起 React+Mobx 一套了<!-- /react-text --></p><p data-reactid="22">下周要开始疯狂踩 React Native 的坑了，公司要我着手开发 app 了，心塞（mmp，拿着农民工的钱，干着“打天下”的事，本人还不是专业的 - -）</p><p data-reactid="23">还有，最近有童鞋反映我的文章看不懂，不照顾基础不好的童鞋，希望我想阮一峰大神一样循循善诱、由浅入深。（这可苦了我一个理科生了，阮大师好歹是位文科生）</p></blockquote><p data-reactid="24">不扯淡了。</p><h3 id="react" data-reactid="25"><a href="#react" aria-hidden="true" data-reactid="26"><span class="icon icon-link" data-reactid="27"></span></a><!-- react-text: 28 -->React<!-- /react-text --></h3><p data-reactid="29"><!-- react-text: 30 -->React 是由 Facebook 提出的 View 层框架。之所以不在之前加上“前端”修饰，是因为 React 在提出时，目标就不仅仅是前端，Virtual Dom 的提出，使得 React 能运行在服务端(ssr)、移动端(react-native)、web端。所以是 <!-- /react-text --><strong data-reactid="31">Learn once, write anywhere</strong></p><div data-reactid="32"><style data-reactid="33">
.medium-image-progressive-container {
  position: relative;
  width: 100%;
  margin: 0 auto;
  margin-top: 43px;
  display: block;
}
.image-loaded.medium-image-progressive canvas {
  visibility: hidden;
  opacity: 0;
  -webkit-transition: visibility 0s linear .5s,opacity .1s .4s;
  transition: visibility 0s linear .5s,opacity .1s .4s;
}
.image-loaded.medium-image-progressive .medium-image-origin {
  visibility: visible;
  opacity: 1;
  -webkit-transition: visibility 0s linear 0s,opacity .4s 0s;
  transition: visibility 0s linear 0s,opacity .4s 0s;
}
.medium-image-progressive-container .medium-image-progressive:not(.image-loaded):not(.canvas-loaded) {
  background-color: rgba(0, 0, 0, 0.05);
}
.medium-image-progressive-container .medium-image-progressive {
  position: absolute;
  top:0;left:0;width:100%;height:100%;
  max-width: 100%;
}
.medium-image-progressive-container .medium-image-origin,
.medium-image-progressive-container .medium-image-progressive canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
}
.medium-image-progressive-container img, .medium-image-progressive-container canvas {
  margin: 0 auto;
}
.medium-image-progressive-container .canvas-loaded.medium-image-progressive:not(.image-loaded) canvas {
  visibility: visible;
  opacity: 1;
  -webkit-transition: visibility 0s linear 0s,opacity .4s 0s;
  transition: visibility 0s linear 0s,opacity .4s 0s;
}
.medium-image-progressive-container .medium-image-origin,
.medium-image-progressive-container .medium-image-progressive canvas {
  visibility: hidden;
  opacity: 0;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
}
</style><div class="medium-image-progressive-container" style="max-width:623px;max-height:623pxpx;" data-reactid="34"><div class="medium-image-progressive-placeholder" style="padding-bottom:63.56340288924559%;" data-reactid="35"></div><div class="medium-image-progressive" data-reactid="36"><canvas data-reactid="37"></canvas><img class="medium-image-progress" src="false" style="display:none;" data-reactid="38"/><img class="medium-image-origin" src="https://ooo.0o0.ooo/2017/01/23/5884d71e7ed1d.jpg" data-reactid="39"/><noscript data-reactid="40"><img class="medium-image-origin" src="https://ooo.0o0.ooo/2017/01/23/5884d71e7ed1d.jpg" data-reactid="41"/></noscript></div></div></div><p data-reactid="42">React 希望通过状态改变来更新视图（diff算法，找到最佳的渲染），还可以通过一些组件内的生命周期方法，来改变视图，达到想要的交互效果。</p><p data-reactid="43"><!-- react-text: 44 -->React 入门看这就够了，<!-- /react-text --><a href="http://www.ruanyifeng.com/blog/2015/03/react.html" data-reactid="45">React 简单入门教程，阮大牛</a></p><h3 id="redux" data-reactid="46"><a href="#redux" aria-hidden="true" data-reactid="47"><span class="icon icon-link" data-reactid="48"></span></a><!-- react-text: 49 -->Redux<!-- /react-text --></h3><p data-reactid="50">由于 React 只是一层 View，对于其数据需要自己管理，对于复杂的应用，如果缺少可维护的状态管理，这对于后面的开发工作是灾难性的。</p><p data-reactid="51">Redux 便是一套可维护的状态管理工具，</p><p data-reactid="52">其主张应用只有一个 store 存储数据，将该 store 层层分离、传入子组件。因此组件（纯渲染）只需要关注自己的需要的数据即可，具有很强的复用性！</p><p data-reactid="53">搭配一系列的 actions，通过 action ID 找到对应的 reducer 处理流程，更新 store，相应的，视图也更新了。</p><p data-reactid="54">所以在组件中的生命周期函数，用户触发的事件函数中，调用 action 即可。</p><div data-reactid="55"><style data-reactid="56">
.medium-image-progressive-container {
  position: relative;
  width: 100%;
  margin: 0 auto;
  margin-top: 43px;
  display: block;
}
.image-loaded.medium-image-progressive canvas {
  visibility: hidden;
  opacity: 0;
  -webkit-transition: visibility 0s linear .5s,opacity .1s .4s;
  transition: visibility 0s linear .5s,opacity .1s .4s;
}
.image-loaded.medium-image-progressive .medium-image-origin {
  visibility: visible;
  opacity: 1;
  -webkit-transition: visibility 0s linear 0s,opacity .4s 0s;
  transition: visibility 0s linear 0s,opacity .4s 0s;
}
.medium-image-progressive-container .medium-image-progressive:not(.image-loaded):not(.canvas-loaded) {
  background-color: rgba(0, 0, 0, 0.05);
}
.medium-image-progressive-container .medium-image-progressive {
  position: absolute;
  top:0;left:0;width:100%;height:100%;
  max-width: 100%;
}
.medium-image-progressive-container .medium-image-origin,
.medium-image-progressive-container .medium-image-progressive canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
}
.medium-image-progressive-container img, .medium-image-progressive-container canvas {
  margin: 0 auto;
}
.medium-image-progressive-container .canvas-loaded.medium-image-progressive:not(.image-loaded) canvas {
  visibility: visible;
  opacity: 1;
  -webkit-transition: visibility 0s linear 0s,opacity .4s 0s;
  transition: visibility 0s linear 0s,opacity .4s 0s;
}
.medium-image-progressive-container .medium-image-origin,
.medium-image-progressive-container .medium-image-progressive canvas {
  visibility: hidden;
  opacity: 0;
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
}
</style><div class="medium-image-progressive-container" style="max-width:800px;max-height:800pxpx;" data-reactid="57"><div class="medium-image-progressive-placeholder" style="padding-bottom:75%;" data-reactid="58"></div><div class="medium-image-progressive" data-reactid="59"><canvas data-reactid="60"></canvas><img class="medium-image-progress" src="false" style="display:none;" data-reactid="61"/><img class="medium-image-origin" src="https://ooo.0o0.ooo/2017/01/22/58845a7e4a302.jpg" data-reactid="62"/><noscript data-reactid="63"><img class="medium-image-origin" src="https://ooo.0o0.ooo/2017/01/22/58845a7e4a302.jpg" data-reactid="64"/></noscript></div></div></div><p data-reactid="65"><!-- react-text: 66 -->可以看出 redux 十分对大型应用的口味，而且很配合 react 的理念，<!-- /react-text --><strong data-reactid="67">组件化</strong><!-- react-text: 68 -->。<!-- /react-text --></p><p data-reactid="69"><em data-reactid="70">但是</em><!-- react-text: 71 -->，Redux 比较难上手，太多的新概念提出（action、reducer、store），这对于没有体会到 react 开发痛点的新同学来说，是晦涩的。<!-- /react-text --></p><blockquote data-reactid="72"><p data-reactid="73">当初在百度实习，我也是死磕了几天文档才懵懵懂懂的明白了一点，写了个简单的 demo，之后在看项目代码，写项目代码的时候才慢慢会用。</p><p data-reactid="74">但又过了这么久之后，自己独立从零开发，使用 react react-router redux 一套之后，才发现以前关于 redux 的疑问都迎刃而解了。之前写的都是个 xx 啊，真是苦了后面维护我代码的兄弟...</p></blockquote><p data-reactid="75">所以，Mobx 出现了。</p><h3 id="mobx" data-reactid="76"><a href="#mobx" aria-hidden="true" data-reactid="77"><span class="icon icon-link" data-reactid="78"></span></a><!-- react-text: 79 -->Mobx<!-- /react-text --></h3><p data-reactid="80">正如官方所说</p><blockquote data-reactid="81"><p data-reactid="82"><em data-reactid="83">Simple, scalable state management</em></p></blockquote><p data-reactid="84">mobx 是一个简单，可扩展的状态管理器。</p><p data-reactid="85">Mobx 希望所有需要管理的状态, 都应该被提取出来， 并自动化，不需要书写代码判断是否需要更新视图。</p><p data-reactid="86"><!-- react-text: 87 -->Mobx 搭配 ES6 的<!-- /react-text --><a href="http://es6.ruanyifeng.com/#docs/decorator" data-reactid="88">修饰器</a><!-- react-text: 89 -->使用，代码更简单优雅。<!-- /react-text --></p><p data-reactid="90">Babel 需要 babel-plugin-transform-decorators-legacy 才能使用修饰器</p><p data-reactid="91">Mobx 希望一个 View 对应一个 Model，这对于熟悉面向对象编程的同学十分友好。</p><p data-reactid="92">更新 Model 后，View 也自动更新，十分直接（从 Store =&gt; View =&gt; Update）</p><p data-reactid="93">Redux 需要关注 Store =&gt; View =&gt; Action =&gt; Reducer 一套闭环</p><p data-reactid="94"><!-- react-text: 95 -->以下为 ES6 的一个<!-- /react-text --><a href="https://github.com/moyuyc/react-mobx-starter" data-reactid="96">评论列表demo</a></p><pre data-reactid="97"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="98"><span class="hljs-keyword" data-reactid="99">import</span><!-- react-text: 100 --> React <!-- /react-text --><span class="hljs-keyword" data-reactid="101">from</span><!-- react-text: 102 --> <!-- /react-text --><span class="hljs-string" data-reactid="103">&#x27;react&#x27;</span><!-- react-text: 104 -->;
<!-- /react-text --><span class="hljs-keyword" data-reactid="105">import</span><!-- react-text: 106 --> {render} <!-- /react-text --><span class="hljs-keyword" data-reactid="107">from</span><!-- react-text: 108 --> <!-- /react-text --><span class="hljs-string" data-reactid="109">&#x27;react-dom&#x27;</span><!-- react-text: 110 -->;
<!-- /react-text --><span class="hljs-keyword" data-reactid="111">import</span><!-- react-text: 112 --> {observable, computed, action, useStrict, toJS} <!-- /react-text --><span class="hljs-keyword" data-reactid="113">from</span><!-- react-text: 114 --> <!-- /react-text --><span class="hljs-string" data-reactid="115">&#x27;mobx&#x27;</span><!-- react-text: 116 -->;
<!-- /react-text --><span class="hljs-keyword" data-reactid="117">import</span><!-- react-text: 118 --> {Provider, inject, observer} <!-- /react-text --><span class="hljs-keyword" data-reactid="119">from</span><!-- react-text: 120 --> <!-- /react-text --><span class="hljs-string" data-reactid="121">&#x27;mobx-react&#x27;</span><!-- react-text: 122 -->;

<!-- /react-text --><span class="hljs-comment" data-reactid="123">// View</span><!-- react-text: 124 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="125">// 视为观察者，其视图更新交给 mobx 管理</span><!-- react-text: 126 -->
@observer
<!-- /react-text --><span class="hljs-class" data-reactid="127"><span class="hljs-keyword" data-reactid="128">class</span><!-- react-text: 129 --> <!-- /react-text --><span class="hljs-title" data-reactid="130">Comment</span><!-- react-text: 131 --> <!-- /react-text --><span class="hljs-keyword" data-reactid="132">extends</span><!-- react-text: 133 --> <!-- /react-text --><span class="hljs-title" data-reactid="134">React</span><!-- react-text: 135 -->.<!-- /react-text --><span class="hljs-title" data-reactid="136">Component</span><!-- react-text: 137 --> <!-- /react-text --></span><!-- react-text: 138 -->{
    <!-- /react-text --><span class="hljs-keyword" data-reactid="139">constructor</span><!-- react-text: 140 -->(props) {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="141">super</span><!-- react-text: 142 -->(props)
    }
    render() {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="143">const</span><!-- react-text: 144 --> {author, date, content, text} = <!-- /react-text --><span class="hljs-keyword" data-reactid="145">this</span><!-- react-text: 146 -->.props.store;
        <!-- /react-text --><span class="hljs-keyword" data-reactid="147">const</span><!-- react-text: 148 --> {onDelete} = <!-- /react-text --><span class="hljs-keyword" data-reactid="149">this</span><!-- react-text: 150 -->.props;

        <!-- /react-text --><span class="hljs-keyword" data-reactid="151">return</span><!-- react-text: 152 --> (
            <!-- /react-text --><span class="xml" data-reactid="153"><span class="hljs-tag" data-reactid="154"><!-- react-text: 155 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="156">div</span><!-- react-text: 157 -->&gt;<!-- /react-text --></span><!-- react-text: 158 -->
                <!-- /react-text --></span><!-- react-text: 159 -->&lt;div&gt;{content}&lt;/div&gt;<!-- /react-text --><span class="xml" data-reactid="160">
                </span><!-- react-text: 161 -->&lt;p&gt;{text}&lt;/p&gt;<!-- /react-text --><span class="xml" data-reactid="162">
                </span><!-- react-text: 163 -->&lt;span&gt;{author}&lt;time&gt;{date}&lt;/time&gt;&lt;/span&gt;<!-- /react-text --><span class="xml" data-reactid="164">
                </span><!-- react-text: 165 -->&lt;button onClick={onDelete}&gt;Delete&lt;/button&gt;<!-- /react-text --><span class="xml" data-reactid="166"><!-- react-text: 167 -->
            <!-- /react-text --><span class="hljs-tag" data-reactid="168"><!-- react-text: 169 -->&lt;/<!-- /react-text --><span class="hljs-name" data-reactid="170">div</span><!-- react-text: 171 -->&gt;<!-- /react-text --></span></span><!-- react-text: 172 -->
        )
    }
}
<!-- /react-text --><span class="hljs-comment" data-reactid="173">// 注入 context 中 comments 属性  并且视为观察者</span><!-- react-text: 174 -->
@inject(<!-- /react-text --><span class="hljs-string" data-reactid="175">&#x27;comments&#x27;</span><!-- react-text: 176 -->) @observer
<!-- /react-text --><span class="hljs-class" data-reactid="177"><span class="hljs-keyword" data-reactid="178">class</span><!-- react-text: 179 --> <!-- /react-text --><span class="hljs-title" data-reactid="180">CommentList</span><!-- react-text: 181 --> <!-- /react-text --><span class="hljs-keyword" data-reactid="182">extends</span><!-- react-text: 183 --> <!-- /react-text --><span class="hljs-title" data-reactid="184">React</span><!-- react-text: 185 -->.<!-- /react-text --><span class="hljs-title" data-reactid="186">Component</span><!-- react-text: 187 --> <!-- /react-text --></span><!-- react-text: 188 -->{
    shouldComponentUpdate() {
        <!-- /react-text --><span class="hljs-comment" data-reactid="189">// 这里的代码不会起作用</span><!-- react-text: 190 -->
        alert(<!-- /react-text --><span class="hljs-number" data-reactid="191">1</span><!-- react-text: 192 -->);
        <!-- /react-text --><span class="hljs-keyword" data-reactid="193">return</span><!-- react-text: 194 --> <!-- /react-text --><span class="hljs-literal" data-reactid="195">false</span><!-- react-text: 196 -->;
    }

    render() {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="197">const</span><!-- react-text: 198 --> {comments} = <!-- /react-text --><span class="hljs-keyword" data-reactid="199">this</span><!-- react-text: 200 -->.props;
        <!-- /react-text --><span class="hljs-keyword" data-reactid="201">return</span><!-- react-text: 202 --> (
            <!-- /react-text --><span class="xml" data-reactid="203"><span class="hljs-tag" data-reactid="204"><!-- react-text: 205 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="206">ul</span><!-- react-text: 207 -->&gt;<!-- /react-text --></span><!-- react-text: 208 -->
                {comments &amp;&amp; comments.get().map((comment, index) =&gt;
                    <!-- /react-text --></span><!-- react-text: 209 -->&lt;Comment key={index} store={comment} onDelete={() =&gt; {comments.del(index)} }/&gt;
                )}
            &lt;/ul&gt;<!-- /react-text --><span class="xml" data-reactid="210">
        )
    }
}

// Model
// 严格模式下，只能在 @action 修饰的方法才能修改被观察的数据
useStrict(true);

class CommentState {
    // 被观察者，观察者将检查到其的改变，从而更新视图
    @observable author = &quot;&quot;;

    @observable date = &quot;&quot;;

    @observable content = &quot;&quot;;

    // 计算属性
    @computed get text () {
        return `${this.author} at ${this.date}: ${this.content}`;
    }

    constructor({author, date, content}) {
        this.author = author;
        this.date = date;
        this.content = content;
    }
}

class CommentListState {
    @observable comments = [new CommentState({author: &#x27;auth&#x27;, datetime: &#x27;date&#x27;, content: &#x27;content&#x27;})];

    toJSON() {
        return toJS(this.comments);
    }
    constructor(comments) {
        if (comments) {
            this.set(comments);
        }
    }

    get() {
        return this.comments;
    }

    @action del(index) {
        this.comments.splice(index, 1);
    }

    @action set(list) {
        this.comments = list.map(x =&gt; new CommentState(x))
    }

    @action fetch() {
        setTimeout(() =&gt; {
            this.push([{author: &#x27;John&#x27;, datetime: &#x27;123&#x27;, content: &#x27;hahahaha&#x27;}]);
        }, 1000);
        return this;
    }

    @action push(list) {
        this.comments.push(...new CommentListState(list).comments);
    }

}


var store = {
    comments: new CommentListState().fetch()
}
// Provider : 将 props 写入 Context, 使得其子代（非直系亦可）共享数据。
render(
    </span><!-- react-text: 211 -->&lt;Provider {...store} &gt;
        &lt;CommentList /&gt;
    &lt;/Provider&gt;<!-- /react-text --><span class="xml" data-reactid="212">,
    document.getElementById(&#x27;root&#x27;)
);</span></code></pre><p data-reactid="213">综上，Redux、MobX 各有千秋，MobX 虽然简单直接；但破坏了纯渲染组件结构，必须需要对应的 Model 才能正确使用；且其文档与生态环境没有 Redux 良好。 喜欢简洁，爱尝试的同学可以试一下。</p></article></div><div class="gitment-container" data-reactid="214"></div><div class="paginator" data-reactid="215"><a title="你不知道的Console" class="prev" href="/you-don&#x27;t-know-console" data-reactid="216">Prev</a><a title="node.js 同步请求" class="next" href="/sync-request-in-nodejs" data-reactid="217">Next</a></div></div></main><footer data-reactid="218"><div class="copyright" data-reactid="219"><p data-reactid="220"><!-- react-text: 221 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="222">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
