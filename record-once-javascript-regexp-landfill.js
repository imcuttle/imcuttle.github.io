webpackJsonp([44,113],{1221:function(e,o){e.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=问题重现><a href=#%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0 aria-hidden=true><span class="icon icon-link"></span></a>问题重现</h2><p>不知道各位旁友在<code>webpack</code>的使用中，有没有碰到下面的问题情景： 1. 在使用了<code>css Module</code>的情况下，同时又希望用一些<code>global</code>的布局，其实在<code>css Module</code>中直接用</p><pre><code data-query={} data-lang>:global(.title) {\n    color: green;\n}\n</code></pre><p>也是可以实现的，但是如果需要引入第三方css，如<code>Animate.css</code>，如果对每一个<code>classname</code>都进行手动的全局定义，工作量可不小。</p><ol start=2><li>关于<code>css</code>的打包问题，对于一些组件的样式，可以将<code>css</code>打包在<code>js</code>文件中，但是一些全局的<code>css</code>，或者一些需要第一时间加载的<code>css</code> (如<code>pace.css</code>，在页面加载过程中就需要第一时间解析出样式)，就需要使用<code>ExtractTextPlugin</code>打包成为单独的<code>css</code>文件了。</li></ol><p>以上都是需要对于同一类型文件的不同处理。在<code>webpack</code>中就体现成用正则表达式进行文件名匹配。</p><p>为了更优雅的命名，第一种情景来举例，我将全局的样式文件命名成<code>foo.global.less</code>，其他需要进行<code>css module</code>处理的则正常命名，如<code>bar.less</code>。</p><h2 id=思路><a href=#%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>思路</h2><p>在进入主题之前，我先分享一个实用的在线正则网站<a href=http://refiddle.com/>refiddle</a>，包含了不仅仅<code>Javascript</code>的正则</p><p>下面的重头戏便是<br><strong>如何正则匹配<code>*.global.less</code>和<code>*.less</code>(不包括<code>*.global.less</code>)？</strong></p><p>众所周知，<code>webpack</code>中是不存在多次正则匹配的，所以需要分别使用2个正则表达式来解决上面两种字符串的匹配。</p><p><code>*.global.less</code>字符串匹配？恩, so easy，<code>/\\.global\\.less$/</code>, 那么<code>*.less</code>(不包括<code>*.global.less</code>)呢？</p><p>显然，这就需要用到正则的位置匹配了(<code>(^\\.global)</code>和<code>[^\\.global]</code>都是不正确的)，匹配前面不是<code>.global</code>的的位置。</p><table><thead><tr><th>分类</th><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td><code>(exp)</code></td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>捕获</td><td><code>(?&lt;name>exp)</code></td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?\'name\'exp)</td></tr><tr><td>捕获</td><td><code>(?:exp)</code></td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>位置匹配</td><td><code>(?=exp)</code></td><td>匹配exp前面的位置</td></tr><tr><td>位置匹配</td><td><code>(?&lt;=exp)</code></td><td>匹配exp后面的位置</td></tr><tr><td>位置匹配</td><td><code>(?!exp)</code></td><td>匹配后面跟的不是exp的位置</td></tr><tr><td>位置匹配</td><td><code>(?&lt;!exp)</code></td><td>匹配前面不是exp的位置</td></tr><tr><td>注释</td><td><code>(?#comment)</code></td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>如上表，很显然需要使用<code>(?&lt;!exp)</code>，所以正则表达式是<code>/(?&lt;!global)\\.less$/</code>，完结撒花！</p><p>但是！真的就这样可以了吗？？很不幸的是在js中并没有实现<code>(?&lt;=exp)</code>和<code>(?&lt;!exp)</code>的位置匹配。（可能是大家伙都没想到Js能走到今天这个地步，以为只是在浏览器上耍耍，数据验证没必要太复杂吧 ）<br>参看<a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp>RegExp</a>.</p><p>经过一番查找和头脑风暴，最终得到了Js中不包含某子串的正则匹配<br><strong><code>/^(.(?!\\.global))+\\.less$/</code></strong></p><p><code>(?!\\.global)</code>匹配的是后面不是<code>.global</code>的位置<br><code>(.(?!\\.global))+</code>匹配的就是若干个后面跟着不是<code>.global</code>的字符<br><code>^</code>字符串首位置不能丢！，如果丢了，<code>/(.(?!\\.global))+\\.less$/</code>也能够匹配<code>foo.global.less</code>，因为从<code>foo</code>后面的<code>.</code>开始，后面跟着的就不是<code>.global</code>了。</p><p>但是对于<code>.global.less</code>字符串，该正则也无能为力了。</p><h2 id=参考><a href=#%E5%8F%82%E8%80%83 aria-hidden=true><span class="icon icon-link"></span></a>参考</h2><ol><li><a href=http://deerchao.net/tutorials/regex/regex.htm>正则表达式30分钟入门教程</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp>JavaScript RegExp</a></li><li><a href=http://www.cnblogs.com/bvbook/archive/2010/11/03/1867775.html>正则表达式匹配“不包含某个字符串” (通俗易懂还有图！)</a></li></ol><p><strong>2018年05月15日更新： ES2018已经支持后行断言。<a href=https://github.com/tc39/proposal-regexp-lookbehind>https://github.com/tc39/proposal-regexp-lookbehind</a></strong></p>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=record-once-javascript-regexp-landfill.js.map