{"version":3,"sources":["webpack:///advanced-bash-scripting-guide-1.js","webpack:///./source/_articles/advanced-bash-scripting-guide-1.md"],"names":["webpackJsonp","1153","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,i3VACAC,OACAC,oBACAC","file":"advanced-bash-scripting-guide-1.js","sourcesContent":["webpackJsonp([110,113],{\n\n/***/ 1153:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>原文：<a href=http://www.tldp.org/LDP/abs/abs-guide.pdf>Advanced Bash-Scripting Guide</a></p><p>部分<a href=https://github.com/moyuyc/advanced-bash-scripting-learning>学习代码</a></p><p>只做部分翻译，一些个人遗漏的点。</p><h3 id=关于脚本头><a href=#%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E5%A4%B4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>关于脚本头</h3><p>Bash 中头部 <code>#!</code> ，如果没有用上 Bash 专用的语法（比如 A=abc，赋值语句），是可以被不加上。</p><p><code>#!/bin/sh</code> 调用的是默认的 Shell 解释器，在 Linux 中是 <code>/bin/bash</code></p><h3 id=参数个数到数组长度><a href=#%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%88%B0%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参数个数到数组长度</h3><p>下面脚本中，<code>$#</code> 是参数数组的长度，可以用下面脚本判断参数的输入</p><pre><code class=\\\"hljs language-sh\\\"data-query={} data-lang=sh><span class=hljs-meta>#!/bin/sh\\n</span>\\nE_WRONG_ARGS=85\\nscript_parameters=<span class=hljs-string>\\\"-a -h -m -z\\\"</span>\\nNumber_of_expected_args=1\\n<span class=hljs-comment># -a = all, -h = help, etc.</span>\\n<span class=hljs-keyword>if</span> [ <span class=hljs-variable>$#</span> -ne <span class=hljs-variable>$Number_of_expected_args</span> ]\\n<span class=hljs-keyword>then</span>\\n <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"Usage: `basename <span class=hljs-variable>$0</span>` <span class=hljs-variable>$script_parameters</span>\\\"</span>\\n <span class=hljs-comment># `basename $0` is the script's filename.</span>\\n <span class=hljs-built_in>exit</span> <span class=hljs-variable>$E_WRONG_ARGS</span>\\n<span class=hljs-keyword>fi</span></code></pre><p>上面例子可以看到<code>#</code>可以表示一个数组（字符串）的长度，如下例</p><pre><code data-query={} data-lang>arr=(a b c) &amp&amp str=string &amp&amp echo ${#arr}-${#str} # 3-6\\n</code></pre><h3 id=脚本的执行方法><a href=#%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>脚本的执行方法</h3><p>比如有<code>sh scriptname.sh</code> <code>bash scriptname.sh</code>，当然还有 <code>sh &lt; scriptname.sh</code> ( 这种方法不建议，因为不能在脚本中读 <code>stdin</code> )。最方便的方法还是，直接用<code>chmod</code>变成可执行（executable）文件。</p><pre><code data-query={} data-lang>chmod 555 scriptname # readable/executable for all\\nchmod +rx scriptname # readable/executable for all\\nchmod u+rx scriptname # readable/executable for user\\n</code></pre><h3 id=字符-><a href=#%E5%AD%97%E7%AC%A6- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>字符 <code>#</code></h3><ol><li><p>普通字符<code>#</code></p><pre><code data-query={} data-lang>echo \\\"hello\\\\n# comment\\\\nworld\\\" | \\\\\\nsed -e '/#/d' | # 删除带有`#`字符的行 \\\\  \\ntr -d '\\\\n' | # 删除换行符 \\\\   \\nsed -e 's/world/,Bash scripting/g'  # 字符替换\\n</code></pre></li><li><p>字符串匹配</p><pre><code data-query={} data-lang>str=abc123456123ABC\\necho ${str#*123}  # 删除 str 中匹配*123的 最短匹配\\necho ${str##*123} # 删除 str 中匹配*123的 贪心匹配\\n</code></pre></li><li><p>数字表达式</p><pre><code data-query={} data-lang>echo $((2#101011))  # 二进制的101011\\n</code></pre></li></ol><h3 id=字符--1><a href=#%E5%AD%97%E7%AC%A6--1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>字符 <code>;</code></h3><p>在同一行中执行多条指令</p><pre><code data-query={} data-lang>echo one; echo two\\n\\nif [ true ]; then  # ; 不能少, if/then 两条指令\\n    echo \\\"true statement\\\"\\nfi\\n</code></pre><h3 id=双分号-><a href=#%E5%8F%8C%E5%88%86%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>双分号 <code>;;</code></h3><p>在 case 选项中</p><pre><code data-query={} data-lang>variable=abc\\ncase \\\"$variable\\\" in\\n    abc)  echo \\\"\\\\$variable = abc\\\" ;;\\n    xyz)  echo \\\"\\\\$variable = xyz\\\" ;;\\nesac\\n</code></pre><h3 id=逗号-><a href=#%E9%80%97%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>逗号 <code>,</code></h3><p>字符串的拼接</p><pre><code data-query={} data-lang>ls /usr{,/lib} # 列出 `/usr` 和 `/usr/lib` 下的文件\\nmv file{,B}.txt # file.txt -> fileB.txt\\n</code></pre><h3 id=冒号-><a href=#%E5%86%92%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>冒号 <code>:</code></h3><p>nop 操作，空操作，退出状态为0</p><pre><code data-query={} data-lang>not-exist-command; echo $?\\n\\nnot-exist-command; :; echo $?\\n</code></pre><p>选择符</p><pre><code data-query={} data-lang>a=123\\nb=456\\necho ${a:-$b} # 123\\n\\na=\\nb=456\\necho ${a:-$b} # 456\\n</code></pre><h3 id=-与-><a href=#-%E4%B8%8E- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>\\\"<code></code>\\\" 与 $()</h3><p>指令运行输出结果赋值给某变量</p><pre><code data-query={} data-lang>files=(*); echo ${files[@]} # or ${files}\\necho $(ls)\\necho `ls`\\n</code></pre><h3 id=通配符><a href=#%E9%80%9A%E9%85%8D%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>通配符</h3><p>在 Unix 文件系统中，有 <code>*</code>、<code>?</code>、<code>[]</code></p><pre><code data-query={} data-lang>echo /usr/*    # * 配对任意长，任意字符\\necho /usr/li?  # ? 配对一个字符\\necho /usr/li[a-z]\\n</code></pre><h3 id=--三目运算符><a href=#--%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>? :</code> 三目运算符</h3><pre><code data-query={} data-lang>((x = 2>0?123:456)); echo $x\\n</code></pre><h3 id><code>$$</code></h3><pre><code data-query={} data-lang>echo $$;   # process ID\\n</code></pre><h3 id=-扩充><a href=#-%E6%89%A9%E5%85%85 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>{}</code> 扩充</h3><p><code>{}</code> 内不允许任何空格，除非是转义后或是引号内</p><ol><li><p>字符串组合 echo \\\\\\\"{These,words,are,quoted}\\\\\\\" # \\\" prefix and suffix</p><pre><code data-query={} data-lang># \\\"These\\\" \\\"words\\\" \\\"are\\\" \\\"quoted\\\"\\n\\ncp file22.{txt,backup}\\n# Copies \\\"file22.txt\\\" to \\\"file22.backup\\\"\\n\\necho {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z\\n# Echoes characters between a and z.\\necho {0..3} # 0 1 2 3\\n# Echoes characters between 0 and 3.\\nbase64_charset=( {A..Z} {a..z} {0..9} + / = )\\n\\necho {file1,file2}\\\\ :{\\\\ A,\\\" B\\\",' C'}\\n# file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C\\necho {file1,file2} :{\\\\ A,\\\" B\\\",' C'}\\n# file1 file2 : A : B : C\\n</code></pre></li><li><p>代码块</p><pre><code class=\\\"hljs language-bash\\\"data-query={} data-lang=bash><span class=hljs-meta>#!/bin/sh</span>\\n<span class=hljs-comment># readfile line by line</span>\\nFile=<span class=hljs-variable>${me=`basename \\\"$0\\\"`}</span>\\n{\\n    <span class=hljs-built_in>read</span> line1\\n    <span class=hljs-built_in>read</span> line2\\n} &lt; <span class=hljs-variable>$File</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"First line in <span class=hljs-variable>$File</span> is:\\\"</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"<span class=hljs-variable>$line1</span>\\\"</span>\\n<span class=hljs-built_in>echo</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"Second line in <span class=hljs-variable>$File</span> is:\\\"</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"<span class=hljs-variable>$line2</span>\\\"</span></code></pre><pre><code class=\\\"hljs language-bash\\\"data-query={} data-lang=bash><span class=hljs-meta>#!/bin/sh</span>\\n<span class=hljs-comment># output save to out.html</span>\\n{\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;html>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;head>&lt;/head>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;body>&lt;h1>Output&lt;/h1>&lt;/body>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;/html>\\\"</span>\\n} > out.html\\n\\nopen out.html</code></pre></li></ol><h3 id=后台进程-><a href=#%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>后台进程 <code>&amp</code></h3><p><code>&amp</code> 不仅仅可以用于单条指令，对于一个完整的语句块也是可以的。</p><pre><code data-query={} data-lang>for i in 1 2 3 4 5 6 7 8 9 10\\ndo\\n  echo -n \\\"$i \\\"\\ndone &amp\\n</code></pre><h3 id=对的误解><a href=#%E5%AF%B9%E7%9A%84%E8%AF%AF%E8%A7%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>对<code>&amp&amp</code>的误解</h3><p><code>&amp&amp</code> 并不是无条件的顺序执行下一条指令，而是需要上一条指令 <code>exit code</code> 等于 0。</p><pre><code data-query={} data-lang>(exit 1) &amp&amp echo 123  # print nothing.\\n(exit 1); echo 123    # print 123.\\n</code></pre><h3 id=比较操作符><a href=#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>比较操作符</h3><pre><code data-query={} data-lang>#!/usr/bin/env bash\\n\\nfiles=(*.sh)\\nfile1=${files[1]}\\nfile2=${files[2]}\\n\\nif [ $file1 -ot $file2 ]\\nthen #      ^\\n  echo \\\"File $file1 is older than $file2.\\\"\\nfi\\n\\na=123\\nb=123\\n\\nif [ \\\"$a\\\" -eq \\\"$b\\\" ]\\nthen #    ^\\n  echo \\\"$a is equal to $b.\\\"\\nfi\\n\\nc=24\\nd=47\\n\\nif [ \\\"$c\\\" -eq 24 -a \\\"$d\\\" -eq 47 ] # [[ \\\"$c\\\" = 24 &amp&amp \\\"$d\\\" = 47 ]]\\nthen #    ^              ^\\n  echo \\\"$c equals 24 and $d equals 47.\\\"\\nfi\\n</code></pre><h3 id=--的扩展><a href=#--%E7%9A%84%E6%89%A9%E5%B1%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>-</code> 的扩展</h3><p><code>-</code> 除了是对于指令的选项，如 <code>ls -al</code> ，还可以表示 <code>stdio</code></p><pre><code data-query={} data-lang>tar cf - .  #stdout\\n# The 'c' option 'tar' archiving command creates a new archive,\\n# the 'f' (file) option, followed by '-' designates the target file\\n# as stdout, and do it in current directory tree ('.').\\n\\ntar xpvf -  #stdin\\n# Unarchive ('x'), preserve ownership and file permissions ('p'),\\n# and send verbose messages to stdout ('v'),\\n# reading data from stdin ('f' followed by '-').\\n\\nfile -  #stdin\\n\\ndiff file.js - # stdin\\n</code></pre><p><code>cd -</code> 可以对 pwd 的切换，主要是保存了 OLDPWD</p><pre><code data-query={} data-lang>cd /\\ncd ~\\necho $OLDPWD\\necho $PWD\\n</code></pre><h3 id=其他符号><a href=#%E5%85%B6%E4%BB%96%E7%AC%A6%E5%8F%B7 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他符号</h3><pre><code data-query={} data-lang>echo ~+   # echo $PWD\\necho ~-   # echo $OLDPWD\\n</code></pre><h3 id=有用的快捷键><a href=#%E6%9C%89%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>有用的快捷键</h3><ol><li>Ctl - Z 挂起前台进程</li><li>Ctl - T 交换 2 个相邻字符</li><li>Ctl - W 删除左边一个单词</li><li>Ctl - X 选择高亮</li><li>Ctl - Y 插入之前删除的文本（Ctl - W/U）</li><li>Ctl - R 搜索历史指令</li><li>Ctl - S 中断控制台输出</li><li>Ctl - Q 恢复控制台输出</li></ol><h3 id=ifs-内部域分隔符><a href=#ifs-%E5%86%85%E9%83%A8%E5%9F%9F%E5%88%86%E9%9A%94%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>IFS</code> 内部域分隔符</h3><pre><code data-query={} data-lang>#!/bin/sh\\n\\noutput_args_one_per_line()\\n{\\n    arg_list=$*\\n    echo \\\"\\\\$*='$*'\\\"\\n    for arg in $arg_list\\n    do\\n        echo \\\"[$arg]\\\"\\n    done\\n}\\n\\nx=\\\"a b c d e\\\"\\nIFS=' '\\noutput_args_one_per_line $x\\n\\nx=\\\"a b c\\\"$'\\\\t'\\\"d e\\\"\\nIFS=$'\\\\t'\\noutput_args_one_per_line $x\\n</code></pre><h3 id=-与--1><a href=#-%E4%B8%8E--1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>$*</code> 与 <code>$@</code></h3><pre><code data-query={} data-lang> IFS=\\\";\\\"\\n set x y z\\n echo $*    # x y z\\n echo \\\"$*\\\"  # x;y;z\\n echo \\\"$@\\\"  # x y z\\n</code></pre>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// advanced-bash-scripting-guide-1.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>原文：<a href=http://www.tldp.org/LDP/abs/abs-guide.pdf>Advanced Bash-Scripting Guide</a></p><p>部分<a href=https://github.com/moyuyc/advanced-bash-scripting-learning>学习代码</a></p><p>只做部分翻译，一些个人遗漏的点。</p><h3 id=关于脚本头><a href=#%E5%85%B3%E4%BA%8E%E8%84%9A%E6%9C%AC%E5%A4%B4 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>关于脚本头</h3><p>Bash 中头部 <code>#!</code> ，如果没有用上 Bash 专用的语法（比如 A=abc，赋值语句），是可以被不加上。</p><p><code>#!/bin/sh</code> 调用的是默认的 Shell 解释器，在 Linux 中是 <code>/bin/bash</code></p><h3 id=参数个数到数组长度><a href=#%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%88%B0%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>参数个数到数组长度</h3><p>下面脚本中，<code>$#</code> 是参数数组的长度，可以用下面脚本判断参数的输入</p><pre><code class=\\\"hljs language-sh\\\"data-query={} data-lang=sh><span class=hljs-meta>#!/bin/sh\\n</span>\\nE_WRONG_ARGS=85\\nscript_parameters=<span class=hljs-string>\\\"-a -h -m -z\\\"</span>\\nNumber_of_expected_args=1\\n<span class=hljs-comment># -a = all, -h = help, etc.</span>\\n<span class=hljs-keyword>if</span> [ <span class=hljs-variable>$#</span> -ne <span class=hljs-variable>$Number_of_expected_args</span> ]\\n<span class=hljs-keyword>then</span>\\n <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"Usage: `basename <span class=hljs-variable>$0</span>` <span class=hljs-variable>$script_parameters</span>\\\"</span>\\n <span class=hljs-comment># `basename $0` is the script's filename.</span>\\n <span class=hljs-built_in>exit</span> <span class=hljs-variable>$E_WRONG_ARGS</span>\\n<span class=hljs-keyword>fi</span></code></pre><p>上面例子可以看到<code>#</code>可以表示一个数组（字符串）的长度，如下例</p><pre><code data-query={} data-lang>arr=(a b c) &amp&amp str=string &amp&amp echo ${#arr}-${#str} # 3-6\\n</code></pre><h3 id=脚本的执行方法><a href=#%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>脚本的执行方法</h3><p>比如有<code>sh scriptname.sh</code> <code>bash scriptname.sh</code>，当然还有 <code>sh &lt; scriptname.sh</code> ( 这种方法不建议，因为不能在脚本中读 <code>stdin</code> )。最方便的方法还是，直接用<code>chmod</code>变成可执行（executable）文件。</p><pre><code data-query={} data-lang>chmod 555 scriptname # readable/executable for all\\nchmod +rx scriptname # readable/executable for all\\nchmod u+rx scriptname # readable/executable for user\\n</code></pre><h3 id=字符-><a href=#%E5%AD%97%E7%AC%A6- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>字符 <code>#</code></h3><ol><li><p>普通字符<code>#</code></p><pre><code data-query={} data-lang>echo \\\"hello\\\\n# comment\\\\nworld\\\" | \\\\\\nsed -e '/#/d' | # 删除带有`#`字符的行 \\\\  \\ntr -d '\\\\n' | # 删除换行符 \\\\   \\nsed -e 's/world/,Bash scripting/g'  # 字符替换\\n</code></pre></li><li><p>字符串匹配</p><pre><code data-query={} data-lang>str=abc123456123ABC\\necho ${str#*123}  # 删除 str 中匹配*123的 最短匹配\\necho ${str##*123} # 删除 str 中匹配*123的 贪心匹配\\n</code></pre></li><li><p>数字表达式</p><pre><code data-query={} data-lang>echo $((2#101011))  # 二进制的101011\\n</code></pre></li></ol><h3 id=字符--1><a href=#%E5%AD%97%E7%AC%A6--1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>字符 <code>;</code></h3><p>在同一行中执行多条指令</p><pre><code data-query={} data-lang>echo one; echo two\\n\\nif [ true ]; then  # ; 不能少, if/then 两条指令\\n    echo \\\"true statement\\\"\\nfi\\n</code></pre><h3 id=双分号-><a href=#%E5%8F%8C%E5%88%86%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>双分号 <code>;;</code></h3><p>在 case 选项中</p><pre><code data-query={} data-lang>variable=abc\\ncase \\\"$variable\\\" in\\n    abc)  echo \\\"\\\\$variable = abc\\\" ;;\\n    xyz)  echo \\\"\\\\$variable = xyz\\\" ;;\\nesac\\n</code></pre><h3 id=逗号-><a href=#%E9%80%97%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>逗号 <code>,</code></h3><p>字符串的拼接</p><pre><code data-query={} data-lang>ls /usr{,/lib} # 列出 `/usr` 和 `/usr/lib` 下的文件\\nmv file{,B}.txt # file.txt -> fileB.txt\\n</code></pre><h3 id=冒号-><a href=#%E5%86%92%E5%8F%B7- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>冒号 <code>:</code></h3><p>nop 操作，空操作，退出状态为0</p><pre><code data-query={} data-lang>not-exist-command; echo $?\\n\\nnot-exist-command; :; echo $?\\n</code></pre><p>选择符</p><pre><code data-query={} data-lang>a=123\\nb=456\\necho ${a:-$b} # 123\\n\\na=\\nb=456\\necho ${a:-$b} # 456\\n</code></pre><h3 id=-与-><a href=#-%E4%B8%8E- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>\\\"<code></code>\\\" 与 $()</h3><p>指令运行输出结果赋值给某变量</p><pre><code data-query={} data-lang>files=(*); echo ${files[@]} # or ${files}\\necho $(ls)\\necho `ls`\\n</code></pre><h3 id=通配符><a href=#%E9%80%9A%E9%85%8D%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>通配符</h3><p>在 Unix 文件系统中，有 <code>*</code>、<code>?</code>、<code>[]</code></p><pre><code data-query={} data-lang>echo /usr/*    # * 配对任意长，任意字符\\necho /usr/li?  # ? 配对一个字符\\necho /usr/li[a-z]\\n</code></pre><h3 id=--三目运算符><a href=#--%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>? :</code> 三目运算符</h3><pre><code data-query={} data-lang>((x = 2>0?123:456)); echo $x\\n</code></pre><h3 id><code>$$</code></h3><pre><code data-query={} data-lang>echo $$;   # process ID\\n</code></pre><h3 id=-扩充><a href=#-%E6%89%A9%E5%85%85 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>{}</code> 扩充</h3><p><code>{}</code> 内不允许任何空格，除非是转义后或是引号内</p><ol><li><p>字符串组合 echo \\\\\\\"{These,words,are,quoted}\\\\\\\" # \\\" prefix and suffix</p><pre><code data-query={} data-lang># \\\"These\\\" \\\"words\\\" \\\"are\\\" \\\"quoted\\\"\\n\\ncp file22.{txt,backup}\\n# Copies \\\"file22.txt\\\" to \\\"file22.backup\\\"\\n\\necho {a..z} # a b c d e f g h i j k l m n o p q r s t u v w x y z\\n# Echoes characters between a and z.\\necho {0..3} # 0 1 2 3\\n# Echoes characters between 0 and 3.\\nbase64_charset=( {A..Z} {a..z} {0..9} + / = )\\n\\necho {file1,file2}\\\\ :{\\\\ A,\\\" B\\\",' C'}\\n# file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C\\necho {file1,file2} :{\\\\ A,\\\" B\\\",' C'}\\n# file1 file2 : A : B : C\\n</code></pre></li><li><p>代码块</p><pre><code class=\\\"hljs language-bash\\\"data-query={} data-lang=bash><span class=hljs-meta>#!/bin/sh</span>\\n<span class=hljs-comment># readfile line by line</span>\\nFile=<span class=hljs-variable>${me=`basename \\\"$0\\\"`}</span>\\n{\\n    <span class=hljs-built_in>read</span> line1\\n    <span class=hljs-built_in>read</span> line2\\n} &lt; <span class=hljs-variable>$File</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"First line in <span class=hljs-variable>$File</span> is:\\\"</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"<span class=hljs-variable>$line1</span>\\\"</span>\\n<span class=hljs-built_in>echo</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"Second line in <span class=hljs-variable>$File</span> is:\\\"</span>\\n<span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"<span class=hljs-variable>$line2</span>\\\"</span></code></pre><pre><code class=\\\"hljs language-bash\\\"data-query={} data-lang=bash><span class=hljs-meta>#!/bin/sh</span>\\n<span class=hljs-comment># output save to out.html</span>\\n{\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;html>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;head>&lt;/head>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;body>&lt;h1>Output&lt;/h1>&lt;/body>\\\"</span>\\n    <span class=hljs-built_in>echo</span> <span class=hljs-string>\\\"&lt;/html>\\\"</span>\\n} > out.html\\n\\nopen out.html</code></pre></li></ol><h3 id=后台进程-><a href=#%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B- aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>后台进程 <code>&amp</code></h3><p><code>&amp</code> 不仅仅可以用于单条指令，对于一个完整的语句块也是可以的。</p><pre><code data-query={} data-lang>for i in 1 2 3 4 5 6 7 8 9 10\\ndo\\n  echo -n \\\"$i \\\"\\ndone &amp\\n</code></pre><h3 id=对的误解><a href=#%E5%AF%B9%E7%9A%84%E8%AF%AF%E8%A7%A3 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>对<code>&amp&amp</code>的误解</h3><p><code>&amp&amp</code> 并不是无条件的顺序执行下一条指令，而是需要上一条指令 <code>exit code</code> 等于 0。</p><pre><code data-query={} data-lang>(exit 1) &amp&amp echo 123  # print nothing.\\n(exit 1); echo 123    # print 123.\\n</code></pre><h3 id=比较操作符><a href=#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>比较操作符</h3><pre><code data-query={} data-lang>#!/usr/bin/env bash\\n\\nfiles=(*.sh)\\nfile1=${files[1]}\\nfile2=${files[2]}\\n\\nif [ $file1 -ot $file2 ]\\nthen #      ^\\n  echo \\\"File $file1 is older than $file2.\\\"\\nfi\\n\\na=123\\nb=123\\n\\nif [ \\\"$a\\\" -eq \\\"$b\\\" ]\\nthen #    ^\\n  echo \\\"$a is equal to $b.\\\"\\nfi\\n\\nc=24\\nd=47\\n\\nif [ \\\"$c\\\" -eq 24 -a \\\"$d\\\" -eq 47 ] # [[ \\\"$c\\\" = 24 &amp&amp \\\"$d\\\" = 47 ]]\\nthen #    ^              ^\\n  echo \\\"$c equals 24 and $d equals 47.\\\"\\nfi\\n</code></pre><h3 id=--的扩展><a href=#--%E7%9A%84%E6%89%A9%E5%B1%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>-</code> 的扩展</h3><p><code>-</code> 除了是对于指令的选项，如 <code>ls -al</code> ，还可以表示 <code>stdio</code></p><pre><code data-query={} data-lang>tar cf - .  #stdout\\n# The 'c' option 'tar' archiving command creates a new archive,\\n# the 'f' (file) option, followed by '-' designates the target file\\n# as stdout, and do it in current directory tree ('.').\\n\\ntar xpvf -  #stdin\\n# Unarchive ('x'), preserve ownership and file permissions ('p'),\\n# and send verbose messages to stdout ('v'),\\n# reading data from stdin ('f' followed by '-').\\n\\nfile -  #stdin\\n\\ndiff file.js - # stdin\\n</code></pre><p><code>cd -</code> 可以对 pwd 的切换，主要是保存了 OLDPWD</p><pre><code data-query={} data-lang>cd /\\ncd ~\\necho $OLDPWD\\necho $PWD\\n</code></pre><h3 id=其他符号><a href=#%E5%85%B6%E4%BB%96%E7%AC%A6%E5%8F%B7 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>其他符号</h3><pre><code data-query={} data-lang>echo ~+   # echo $PWD\\necho ~-   # echo $OLDPWD\\n</code></pre><h3 id=有用的快捷键><a href=#%E6%9C%89%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>有用的快捷键</h3><ol><li>Ctl - Z 挂起前台进程</li><li>Ctl - T 交换 2 个相邻字符</li><li>Ctl - W 删除左边一个单词</li><li>Ctl - X 选择高亮</li><li>Ctl - Y 插入之前删除的文本（Ctl - W/U）</li><li>Ctl - R 搜索历史指令</li><li>Ctl - S 中断控制台输出</li><li>Ctl - Q 恢复控制台输出</li></ol><h3 id=ifs-内部域分隔符><a href=#ifs-%E5%86%85%E9%83%A8%E5%9F%9F%E5%88%86%E9%9A%94%E7%AC%A6 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>IFS</code> 内部域分隔符</h3><pre><code data-query={} data-lang>#!/bin/sh\\n\\noutput_args_one_per_line()\\n{\\n    arg_list=$*\\n    echo \\\"\\\\$*='$*'\\\"\\n    for arg in $arg_list\\n    do\\n        echo \\\"[$arg]\\\"\\n    done\\n}\\n\\nx=\\\"a b c d e\\\"\\nIFS=' '\\noutput_args_one_per_line $x\\n\\nx=\\\"a b c\\\"$'\\\\t'\\\"d e\\\"\\nIFS=$'\\\\t'\\noutput_args_one_per_line $x\\n</code></pre><h3 id=-与--1><a href=#-%E4%B8%8E--1 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>$*</code> 与 <code>$@</code></h3><pre><code data-query={} data-lang> IFS=\\\";\\\"\\n set x y z\\n echo $*    # x y z\\n echo \\\"$*\\\"  # x;y;z\\n echo \\\"$@\\\"  # x y z\\n</code></pre>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/advanced-bash-scripting-guide-1.md\n// module id = 1153\n// module chunks = 110"],"sourceRoot":""}