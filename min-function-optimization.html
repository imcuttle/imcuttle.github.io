<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> imCuttle </title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="1225236872"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">迭代=&gt;递归=&gt;尾递归</h1><div class="post-info" data-reactid="12"><time datetime="2017-03-18T15:31:21+00:00" data-reactid="13">Mar 18, 2017 3:31 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><blockquote data-reactid="16"><!-- react-text: 17 -->
<!-- /react-text --><p data-reactid="18">几周没有更新文章了，因为在忙着其他事，最近又是春招时期，又到了笔试面试刷题的时候，我就来讲讲常用算法中的 迭代与递归，甚至于延伸至尾递归。</p><!-- react-text: 19 -->
<!-- /react-text --></blockquote><!-- react-text: 20 -->
<!-- /react-text --><h2 id="问题提出" data-reactid="21"><a href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA" aria-hidden="true" data-reactid="22"><span class="icon icon-link" data-reactid="23"></span></a><!-- react-text: 24 -->问题提出<!-- /react-text --></h2><!-- react-text: 25 -->
<!-- /react-text --><blockquote data-reactid="26"><!-- react-text: 27 -->
<!-- /react-text --><p data-reactid="28">用 JavaScript 实现一个类 Math.min 的方法。</p><!-- react-text: 29 -->
<!-- /react-text --><p data-reactid="30"><!-- react-text: 31 -->   min(1, 2, -3, 100, 7)<!-- /react-text --><br data-reactid="32"/><!-- react-text: 33 -->
=&gt; -3<!-- /react-text --></p><!-- react-text: 34 -->
<!-- /react-text --></blockquote><!-- react-text: 35 -->
<!-- /react-text --><h2 id="方法一：迭代" data-reactid="36"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3" aria-hidden="true" data-reactid="37"><span class="icon icon-link" data-reactid="38"></span></a><!-- react-text: 39 -->方法一：迭代<!-- /react-text --></h2><!-- react-text: 40 -->
<!-- /react-text --><pre data-reactid="41"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="42"><span class="hljs-function" data-reactid="43"><span class="hljs-keyword" data-reactid="44">function</span><!-- react-text: 45 --> <!-- /react-text --><span class="hljs-title" data-reactid="46">min_0</span><!-- react-text: 47 --> (<!-- /react-text --><span class="hljs-params" data-reactid="48"></span><!-- react-text: 49 -->) <!-- /react-text --></span><!-- react-text: 50 -->{
    <!-- /react-text --><span class="hljs-keyword" data-reactid="51">var</span><!-- react-text: 52 --> min = <!-- /react-text --><span class="hljs-built_in" data-reactid="53">arguments</span><!-- react-text: 54 -->[<!-- /react-text --><span class="hljs-number" data-reactid="55">0</span><!-- react-text: 56 -->];
    <!-- /react-text --><span class="hljs-keyword" data-reactid="57">for</span><!-- react-text: 58 --> (<!-- /react-text --><span class="hljs-keyword" data-reactid="59">var</span><!-- react-text: 60 --> i = <!-- /react-text --><span class="hljs-number" data-reactid="61">1</span><!-- react-text: 62 -->; i &lt; <!-- /react-text --><span class="hljs-built_in" data-reactid="63">arguments</span><!-- react-text: 64 -->.length; i++) {
        min = min &gt; <!-- /react-text --><span class="hljs-built_in" data-reactid="65">arguments</span><!-- react-text: 66 -->[i] ? <!-- /react-text --><span class="hljs-built_in" data-reactid="67">arguments</span><!-- react-text: 68 -->[i] : min;
    }
    <!-- /react-text --><span class="hljs-keyword" data-reactid="69">return</span><!-- react-text: 70 --> min;
}<!-- /react-text --></code></pre><!-- react-text: 71 -->
<!-- /react-text --><p data-reactid="72">当然有些同学喜欢用些“高级”的 api，于是出现下面的方法：</p><!-- react-text: 73 -->
<!-- /react-text --><pre data-reactid="74"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="75"><span class="hljs-function" data-reactid="76"><span class="hljs-keyword" data-reactid="77">function</span><!-- react-text: 78 --> <!-- /react-text --><span class="hljs-title" data-reactid="79">min_1</span><!-- react-text: 80 --> (<!-- /react-text --><span class="hljs-params" data-reactid="81"></span><!-- react-text: 82 -->) <!-- /react-text --></span><!-- react-text: 83 -->{
    <!-- /react-text --><span class="hljs-keyword" data-reactid="84">var</span><!-- react-text: 85 --> numbers = [].slice.call(<!-- /react-text --><span class="hljs-built_in" data-reactid="86">arguments</span><!-- react-text: 87 -->)
    <!-- /react-text --><span class="hljs-keyword" data-reactid="88">return</span><!-- react-text: 89 --> numbers.slice(<!-- /react-text --><span class="hljs-number" data-reactid="90">1</span><!-- react-text: 91 -->).reduce(<!-- /react-text --><span class="hljs-function" data-reactid="92"><!-- react-text: 93 -->(<!-- /react-text --><span class="hljs-params" data-reactid="94">p, n</span><!-- react-text: 95 -->) =&gt;<!-- /react-text --></span><!-- react-text: 96 --> {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="97">return</span><!-- react-text: 98 --> p &gt; n ? n : p;
    }, numbers[<!-- /react-text --><span class="hljs-number" data-reactid="99">0</span><!-- react-text: 100 -->]);
}<!-- /react-text --></code></pre><!-- react-text: 101 -->
<!-- /react-text --><p data-reactid="102"><!-- react-text: 103 -->这种方法很直观地就可以想到，面试官肯定是不会善罢甘休的，继续延伸下去问<!-- /react-text --><br data-reactid="104"/><!-- react-text: 105 -->
“用递归方式怎么实现呢？”<!-- /react-text --></p><!-- react-text: 106 -->
<!-- /react-text --><h2 id="方法二：递归" data-reactid="107"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92" aria-hidden="true" data-reactid="108"><span class="icon icon-link" data-reactid="109"></span></a><!-- react-text: 110 -->方法二：递归<!-- /react-text --></h2><!-- react-text: 111 -->
<!-- /react-text --><p data-reactid="112"> 诚然，递归往往会占用更多的系统资源，还可能会导致栈溢出等问题，但递归也是很能考察一个程序员，良好逻辑思维能力的知识点。</p><!-- react-text: 113 -->
<!-- /react-text --><pre data-reactid="114"><code data-query="{}" data-lang="data-lang" data-reactid="115">function min_2 () {
    var numbers = [].slice.call(arguments);
    if (numbers.length === 1) {
        return numbers[0];
    } else {
        var min = min_2.apply(null, numbers.slice(1));
        return min &gt; numbers[0] ? numbers[0] : min;
    }
}
</code></pre><!-- react-text: 116 -->
<!-- /react-text --><p data-reactid="117">此题也不难写成递归算法，但是面试官可能还是会深究下去，可能会比较其中不同方式的差异。</p><!-- react-text: 118 -->
<!-- /react-text --><h2 id="延伸问题" data-reactid="119"><a href="#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98" aria-hidden="true" data-reactid="120"><span class="icon icon-link" data-reactid="121"></span></a><em data-reactid="122">延伸问题</em></h2><!-- react-text: 123 -->
<!-- /react-text --><ol data-reactid="124"><!-- react-text: 125 -->
<!-- /react-text --><li data-reactid="126"><!-- react-text: 127 -->
<!-- /react-text --><p data-reactid="128"><code data-reactid="129">min0()</code><!-- react-text: 130 -->方法与 <!-- /react-text --><code data-reactid="131">min1()</code><!-- react-text: 132 -->方法比较，哪个效率会更高些（时间复杂度更低）呢？<!-- /react-text --></p><!-- react-text: 133 -->
<!-- /react-text --><p data-reactid="134"><!-- react-text: 135 -->很显然，min0 效率更高，其不仅多了一步 <!-- /react-text --><code data-reactid="136">slice</code><!-- react-text: 137 -->，而且还额外用 <!-- /react-text --><code data-reactid="138">reduce</code><!-- react-text: 139 --> 方法创建了一个闭包，显然底层调用会更多<!-- /react-text --></p><!-- react-text: 140 -->
<!-- /react-text --></li><!-- react-text: 141 -->
<!-- /react-text --><li data-reactid="142"><!-- react-text: 143 -->
<!-- /react-text --><p data-reactid="144"><!-- react-text: 145 -->如果把 <!-- /react-text --><code data-reactid="146">arguments</code><!-- react-text: 147 --> 转化成普通数组的 <!-- /react-text --><code data-reactid="148">slice</code><!-- react-text: 149 --> 方法用 <!-- /react-text --><code data-reactid="150">Array.from</code><!-- react-text: 151 --> 替换，哪个效率更高呢？<!-- /react-text --></p><!-- react-text: 152 -->
<!-- /react-text --><p data-reactid="153">关于该问题，则需要用事实来说话了：  </p><!-- react-text: 154 -->
<!-- /react-text --><pre data-reactid="155"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="156"><span class="hljs-function" data-reactid="157"><span class="hljs-keyword" data-reactid="158">function</span><!-- react-text: 159 --> <!-- /react-text --><span class="hljs-title" data-reactid="160">slice_time</span><!-- react-text: 161 --> (<!-- /react-text --><span class="hljs-params" data-reactid="162"></span><!-- react-text: 163 -->) <!-- /react-text --></span><!-- react-text: 164 -->{
    <!-- /react-text --><span class="hljs-built_in" data-reactid="165">console</span><!-- react-text: 166 -->.time(<!-- /react-text --><span class="hljs-string" data-reactid="167">&#x27;slice&#x27;</span><!-- react-text: 168 -->);
    [].slice.call(<!-- /react-text --><span class="hljs-built_in" data-reactid="169">arguments</span><!-- react-text: 170 -->);
    <!-- /react-text --><span class="hljs-built_in" data-reactid="171">console</span><!-- react-text: 172 -->.timeEnd(<!-- /react-text --><span class="hljs-string" data-reactid="173">&#x27;slice&#x27;</span><!-- react-text: 174 -->);
}

<!-- /react-text --><span class="hljs-function" data-reactid="175"><span class="hljs-keyword" data-reactid="176">function</span><!-- react-text: 177 --> <!-- /react-text --><span class="hljs-title" data-reactid="178">from_time</span><!-- react-text: 179 --> (<!-- /react-text --><span class="hljs-params" data-reactid="180"></span><!-- react-text: 181 -->) <!-- /react-text --></span><!-- react-text: 182 -->{
    <!-- /react-text --><span class="hljs-built_in" data-reactid="183">console</span><!-- react-text: 184 -->.time(<!-- /react-text --><span class="hljs-string" data-reactid="185">&#x27;from&#x27;</span><!-- react-text: 186 -->);
    <!-- /react-text --><span class="hljs-built_in" data-reactid="187">Array</span><!-- react-text: 188 -->.from(<!-- /react-text --><span class="hljs-built_in" data-reactid="189">arguments</span><!-- react-text: 190 -->);
    <!-- /react-text --><span class="hljs-built_in" data-reactid="191">console</span><!-- react-text: 192 -->.timeEnd(<!-- /react-text --><span class="hljs-string" data-reactid="193">&#x27;from&#x27;</span><!-- react-text: 194 -->);
}

<!-- /react-text --><span class="hljs-keyword" data-reactid="195">var</span><!-- react-text: 196 --> arr = <!-- /react-text --><span class="hljs-keyword" data-reactid="197">new</span><!-- react-text: 198 --> <!-- /react-text --><span class="hljs-built_in" data-reactid="199">Array</span><!-- react-text: 200 -->(<!-- /react-text --><span class="hljs-number" data-reactid="201">10000</span><!-- react-text: 202 -->).fill(<!-- /react-text --><span class="hljs-number" data-reactid="203">1</span><!-- react-text: 204 -->);
slice_time.apply(<!-- /react-text --><span class="hljs-literal" data-reactid="205">null</span><!-- react-text: 206 -->, arr);
from_time.apply(<!-- /react-text --><span class="hljs-literal" data-reactid="207">null</span><!-- react-text: 208 -->, arr);

<!-- /react-text --><span class="hljs-comment" data-reactid="209">// slice: 0.267ms</span><!-- react-text: 210 -->
<!-- /react-text --><span class="hljs-comment" data-reactid="211">// from: 5.787ms</span></code></pre><!-- react-text: 212 -->
<!-- /react-text --><p data-reactid="213"><!-- react-text: 214 -->结果很明显，所以我们应该尽量不用<!-- /react-text --><code data-reactid="215">Array.from</code></p><!-- react-text: 216 -->
<!-- /react-text --></li><!-- react-text: 217 -->
<!-- /react-text --><li data-reactid="218"><!-- react-text: 219 -->
<!-- /react-text --><p data-reactid="220"><code data-reactid="221">min(1, 3, 4, 5)</code><!-- react-text: 222 --> 和 <!-- /react-text --><code data-reactid="223">min([1, 3, 4, 5])</code><!-- react-text: 224 -->的两种传参方式，各有什么优劣？<!-- /react-text --></p><!-- react-text: 225 -->
<!-- /react-text --><p data-reactid="226"><!-- react-text: 227 -->借用问题2的代码，如果数组大小设置的足够大，很有可能会看到 <!-- /react-text --><code data-reactid="228">Maximum call stack size exceeded</code><!-- react-text: 229 --> 错误，也就是栈溢出。但是方法中并没有递归调用啊，为什么会存在栈溢出呢？<!-- /react-text --><br data-reactid="230"/><!-- react-text: 231 -->
回答该问题，就需要对编译原理的知识有所了解了，函数中的参数也是会压入栈中的，一般是参数从右往左开始，依次压入（还分为值传递和引用传递等），所以如果参数列表过长，也是会导致栈溢出的。<!-- /react-text --></p><!-- react-text: 232 -->
<!-- /react-text --><p data-reactid="233">那第一种传参方式有什么好的呢？本人觉得除了书写更方便以外，还会把本来是（数组）引用传递的，更改为值传递（该例中是数字）</p><!-- react-text: 234 -->
<!-- /react-text --></li><!-- react-text: 235 -->
<!-- /react-text --><li data-reactid="236"><!-- react-text: 237 -->
<!-- /react-text --><p data-reactid="238"><!-- react-text: 239 -->如何改造递归方法中的 <!-- /react-text --><code data-reactid="240">min_2</code><!-- react-text: 241 --> 方法，使其成为尾递归，有效避免栈溢出的问题？<!-- /react-text --></p><!-- react-text: 242 -->
<!-- /react-text --><p data-reactid="243">首先我们知道递归最大的问题就是容易导致栈溢出，因为每次调用，内存中都需要保存调用记录。
那么尾递归则是递归的一种特殊形式，可以通过尾递归，来覆盖当前的调用环境(主要是参数)，成为自己的调用环境。
具体如下代码：</p><!-- react-text: 244 -->
<!-- /react-text --><pre data-reactid="245"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="246"><span class="hljs-function" data-reactid="247"><span class="hljs-keyword" data-reactid="248">function</span><!-- react-text: 249 --> <!-- /react-text --><span class="hljs-title" data-reactid="250">min_3</span><!-- react-text: 251 --> (<!-- /react-text --><span class="hljs-params" data-reactid="252"></span><!-- react-text: 253 -->) <!-- /react-text --></span><!-- react-text: 254 -->{
    <!-- /react-text --><span class="hljs-keyword" data-reactid="255">var</span><!-- react-text: 256 --> numbers = [].slice.call(<!-- /react-text --><span class="hljs-built_in" data-reactid="257">arguments</span><!-- react-text: 258 -->);
    <!-- /react-text --><span class="hljs-function" data-reactid="259"><span class="hljs-keyword" data-reactid="260">function</span><!-- react-text: 261 --> <!-- /react-text --><span class="hljs-title" data-reactid="262">inner</span><!-- react-text: 263 --> (<!-- /react-text --><span class="hljs-params" data-reactid="264">arr, min_pos, pos</span><!-- react-text: 265 -->) <!-- /react-text --></span><!-- react-text: 266 -->{
<!-- /react-text --><span class="hljs-meta" data-reactid="267">        &#x27;use strict&#x27;</span><!-- react-text: 268 -->;
        <!-- /react-text --><span class="hljs-keyword" data-reactid="269">var</span><!-- react-text: 270 --> min = arr[min_pos], val = arr[pos];
        <!-- /react-text --><span class="hljs-keyword" data-reactid="271">if</span><!-- react-text: 272 --> (pos === arr.length<!-- /react-text --><span class="hljs-number" data-reactid="273">-1</span><!-- react-text: 274 -->) {
            <!-- /react-text --><span class="hljs-keyword" data-reactid="275">return</span><!-- react-text: 276 --> min;
        } <!-- /react-text --><span class="hljs-keyword" data-reactid="277">else</span><!-- react-text: 278 --> {
            <!-- /react-text --><span class="hljs-keyword" data-reactid="279">if</span><!-- react-text: 280 --> (val &lt; min) {
                min_pos = pos;
            }
            <!-- /react-text --><span class="hljs-keyword" data-reactid="281">return</span><!-- react-text: 282 --> inner(arr, min_pos, pos+<!-- /react-text --><span class="hljs-number" data-reactid="283">1</span><!-- react-text: 284 -->);
        }
    }
    <!-- /react-text --><span class="hljs-keyword" data-reactid="285">return</span><!-- react-text: 286 --> inner(numbers, <!-- /react-text --><span class="hljs-number" data-reactid="287">0</span><!-- react-text: 288 -->, <!-- /react-text --><span class="hljs-number" data-reactid="289">1</span><!-- react-text: 290 -->);
}<!-- /react-text --></code></pre><!-- react-text: 291 -->
<!-- /react-text --><p data-reactid="292"><!-- react-text: 293 -->可以看到，在 inner 递归方法中，在最后 <!-- /react-text --><strong data-reactid="294"><code data-reactid="295">return inner(...)</code></strong><!-- react-text: 296 -->，没有其他的参数，所以调用该方法是可以覆盖掉当前调用环境的，所以并没有爆栈。<!-- /react-text --><br data-reactid="297"/><!-- react-text: 298 -->
chrome中默认未开启尾递归优化，需要在函数中加上<!-- /react-text --><code data-reactid="299">&#x27;use strict&#x27;;</code><!-- react-text: 300 -->
同时需要在 <!-- /react-text --><code data-reactid="301">chrome://flags/#enable-javascript-harmony</code><!-- react-text: 302 --> 中开启<!-- /react-text --></p><!-- react-text: 303 -->
<!-- /react-text --></li><!-- react-text: 304 -->
<!-- /react-text --></ol><!-- react-text: 305 -->
<!-- /react-text --><h2 id="其他资料" data-reactid="306"><a href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99" aria-hidden="true" data-reactid="307"><span class="icon icon-link" data-reactid="308"></span></a><!-- react-text: 309 -->其他资料<!-- /react-text --></h2><!-- react-text: 310 -->
<!-- /react-text --><p data-reactid="311"><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" data-reactid="312">尾调用优化</a></p><!-- react-text: 313 -->
<!-- /react-text --></article></div><div class="gitment-container" data-reactid="314"></div><div class="paginator" data-reactid="315"><a title="支付宝第三方支付，App支付教程" class="prev" href="/ali-app-pay" data-reactid="316">Prev</a><a title="zhishiq-backend-api-doc" class="next" href="/zhishiq-backend-api-doc" data-reactid="317">Next</a></div></div></main><footer data-reactid="318"><div class="copyright" data-reactid="319"><p data-reactid="320"><!-- react-text: 321 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="322">Picidae</a></p></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>