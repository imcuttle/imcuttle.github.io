webpackJsonp([8,113],{1258:function(s,a){s.exports={content:'<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=背景><a href=#%E8%83%8C%E6%99%AF aria-hidden=true><span class="icon icon-link"></span></a>背景</h2><p>有一个需求，希望一个输入框的字数统计功能进行优化，优化成与 Microsoft word 一致的统计字数的逻辑。</p><h2 id=研究调查><a href=#%E7%A0%94%E7%A9%B6%E8%B0%83%E6%9F%A5 aria-hidden=true><span class="icon icon-link"></span></a>研究调查</h2><p>Word 中的词数统计规则如下：</p><ol><li>连续的非空 ascii 字符认为是一个词：如 <code>hello world</code> 为 2 个词</li><li>一个非 ascii 字符认为是一个词：如 <code>你好啊！</code> 为 4 个词</li><li>空格不认为是一个词，只是词的分隔符</li></ol><p>如 <code>你好！</code> 为 3 个词， <code>hello world~</code> 为 2 个词</p><h2 id=算法实现><a href=#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0 aria-hidden=true><span class="icon icon-link"></span></a>算法实现</h2><p>虽然算法最终结果是希望我们得到最后的词数，但是我们应该输出的是把一个字符串分割后的数组，如 <code>你好！</code> 应该分割为 <code>[\' 你\', \'好\', \'！ \']</code>，这样不仅通过该数组得到词数，还可以通过该数组做字符串 slice 操作，同时没有空格字符的丢失。</p><h3 id=流程形算法><a href=#%E6%B5%81%E7%A8%8B%E5%BD%A2%E7%AE%97%E6%B3%95 aria-hidden=true><span class="icon icon-link"></span></a>流程形算法</h3><p>我们很容易想到的一种思路是，遍历字符串，进行直线式的逻辑处理</p><pre><code class="hljs language-javascript"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>isWordString</span>(<span class=hljs-params>str</span>) </span>{\n    <span class=hljs-keyword>return</span> <span class=hljs-regexp>/^[\\x00-\\xff]+$/</span>.test(str) &amp&amp !isSpaceString(str);\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>isSpaceString</span>(<span class=hljs-params>str</span>) </span>{\n    <span class=hljs-keyword>return</span> <span class=hljs-regexp>/^\\s+$/</span>.test(str);\n}\n\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>wordChunks</span>(<span class=hljs-params>string</span>) </span>{\n    <span class=hljs-keyword>let</span> word = string.replace(<span class=hljs-regexp>/^(\\s*)([^]*)$/</span>, <span class=hljs-string>\'$1\'</span>);\n    <span class=hljs-comment>// Trim left</span>\n    string = string.replace(<span class=hljs-regexp>/^(\\s*)([^]*)$/</span>, <span class=hljs-string>\'$2\'</span>);\n    <span class=hljs-keyword>let</span> chunks = [];\n\n    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; string.length; i++) {\n        <span class=hljs-keyword>const</span> ch = string[i];\n        <span class=hljs-keyword>const</span> nextCh = string[i + <span class=hljs-number>1</span>];\n\n        <span class=hljs-keyword>if</span> (isSpaceString(ch)) {\n            word += ch;\n        } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (isWordString(ch)) {\n            <span class=hljs-keyword>if</span> (word) {\n                <span class=hljs-keyword>if</span> (isSpaceString(word[word.length - <span class=hljs-number>1</span>]) &amp&amp !isSpaceString(word)) {\n                    chunks.push(word);\n                    word = <span class=hljs-string>\'\'</span>;\n                }\n            }\n\n            word += ch;\n        } <span class=hljs-keyword>else</span> {\n            <span class=hljs-keyword>if</span> (nextCh &amp&amp isSpaceString(nextCh)) {\n                word += ch;\n            } <span class=hljs-keyword>else</span> {\n                <span class=hljs-keyword>if</span> (word &amp&amp isSpaceString(word)) {\n                    chunks.push(word + ch);\n                } <span class=hljs-keyword>else</span> {\n                    word &amp&amp chunks.push(word);\n                    chunks.push(ch);\n                }\n                word = <span class=hljs-string>\'\'</span>;\n            }\n        }\n    }\n\n    word &amp&amp chunks.push(word);\n    <span class=hljs-keyword>return</span> chunks;\n}</code></pre><p>可以看到以上代码有很多的判断分支，维护起来也比较麻烦，像是想到哪里就写到哪里，漏了哪里补哪里的思路，维护成本高。</p><p>其实对于这种问题，我们可以把其使用<a href=https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA>有限状态机</a>进行抽象</p><h3 id=状态机思路><a href=#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%80%9D%E8%B7%AF aria-hidden=true><span class="icon icon-link"></span></a>状态机思路</h3><p>如下图所示，分别有5个状态：<code>none/space/ascii-word/ready/end</code>, 其中</p><ul><li><code>none</code>: 初始状态，表示 word 为空</li><li><code>space</code>: 表示 word 只包含空格</li><li><code>ascii-word</code>: 表示 word 包含非空 ascii 字符，不包含汉字等其他字符，但可以包含空格</li><li><code>ready</code>: 表示 word 是一个独立的词，如 <code>"你"</code> 或者 <code>"hello "</code></li><li><code>end</code>: 表示结束状态</li></ul><p>其中通过不同的字符可以到达不同的状态，其中随着状态的变换，带着操作的执行，如 <code>append/push/reset</code>，其中图中右下角为操作动作的代码。</p><p><img src=https://raw.githubusercontent.com/imcuttle/split-word/master/split-word.svg?sanitize=true></p><p><strong>所以有了状态转换图后，实现算法起来就更加明确有底气了！，更加有据可依！</strong></p><p>在这里我使用<a href=https://github.com/jakesgordon/javascript-state-machine>表驱动方式</a>来<a href=https://github.com/imcuttle/split-word/blob/master/index.js>实现该状态机</a></p>',extra:{"_image-loader_":[],_progressive_:[]}}}});
//# sourceMappingURL=统计有效词数算法的几点思考.js.map