webpackJsonp([12,90],{1051:function(s,n){s.exports={content:'<h1 id="前言"><a href="#%E5%89%8D%E8%A8%80" aria-hidden="true"><span class="icon icon-link"></span></a>前言</h1>\n<p>在2015年寒假期间，我完成了考友无忧项目的考友互动板块模块，主要是基于websocket实现的公共聊天室/一对一好友聊天/实时消息推送，基于websql实现的历史聊天纪录存取。\n<em>项目地址 <a href="http://moyuyc.xyz/autoexam/">http://moyuyc.xyz/autoexam/</a></em> 测试用户 moyumoyu，密码 moyumoyu</p>\n<!--more-->\n<h1 id="关于websocket"><a href="#%E5%85%B3%E4%BA%8Ewebsocket" aria-hidden="true"><span class="icon icon-link"></span></a>关于websocket</h1>\n<p>通过websocket，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。\nwebsocket数据传输不是采用的http协议，而是自己定义的协议。具有传输数据量少的特点。\nchrome控制台中可以查看到这一次握手动作\n<img src="http://obu9je6ng.bkt.clouddn.com/FnzzOxFxWO3ml_rhjA3NjPJuMrDw?imageslim" alt="ClipboardImage" width="1077" height="206" /></p>\n<h1 id="预览"><a href="#%E9%A2%84%E8%A7%88" aria-hidden="true"><span class="icon icon-link"></span></a>预览</h1>\n<ol>\n<li>实时好友聊天\n<img src="http://obu9je6ng.bkt.clouddn.com/FqwbKy8OiMXzzRWhgsGueOHt1nem?imageslim" alt="ClipboardImage" width="1191" height="824" /></li>\n<li>实时消息推送\n<img src="http://obu9je6ng.bkt.clouddn.com/FoEmG9UGsrhr_ZlRC1VGjhYPReKV?imageslim" alt="ClipboardImage" width="422" height="286" /></li>\n</ol>\n<h1 id="实现"><a href="#%E5%AE%9E%E7%8E%B0" aria-hidden="true"><span class="icon icon-link"></span></a>实现</h1>\n<h2 id="前端"><a href="#%E5%89%8D%E7%AB%AF" aria-hidden="true"><span class="icon icon-link"></span></a>前端</h2>\n<ul>\n<li>利用jQuery封装的 websocket 接口</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>{\n    $.websocket = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{\n        <span class="hljs-keyword">var</span> defaults = {\n            <span class="hljs-attr">domain</span>: top.location.hostname,\n            <span class="hljs-attr">port</span>:<span class="hljs-number">80</span>,\n            <span class="hljs-attr">path</span>: <span class="hljs-string">""</span>\n        };\n        <span class="hljs-keyword">var</span> opts = $.extend(defaults,options);\n        <span class="hljs-comment">// 注意：必须为绝对url，websocket不支持同源策略。</span>\n        <span class="hljs-keyword">var</span> szServer = (top.location.protocol == <span class="hljs-string">\'http:\'</span> ? <span class="hljs-string">"ws://"</span> : <span class="hljs-string">"wss://"</span>)\n                        + opts.domain + <span class="hljs-string">":"</span> + opts.port + <span class="hljs-string">"/"</span> + opts.path ;\n        <span class="hljs-keyword">var</span> socket = <span class="hljs-literal">null</span>;\n        <span class="hljs-keyword">var</span> bOpen = <span class="hljs-literal">false</span>;\n        <span class="hljs-keyword">var</span> t1 = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">var</span> t2 = <span class="hljs-number">0</span>;\n        <span class="hljs-keyword">var</span> messageevent = {\n            <span class="hljs-attr">onInit</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n                <span class="hljs-keyword">if</span>(!(<span class="hljs-string">"WebSocket"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>) &#x26;&#x26; !(<span class="hljs-string">"MozWebSocket"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)){\n                    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Boolean</span>($.cookie(<span class="hljs-string">\'session\'</span>))) {\n                        $.moyuAlert(<span class="hljs-string">\'您的浏览器不支持websocket，将不能使用好友功能。\'</span>);\n                        $.cookie(<span class="hljs-string">\'session\'</span>, <span class="hljs-literal">true</span>);\n                    }\n                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n                }\n                <span class="hljs-keyword">if</span>((<span class="hljs-string">"MozWebSocket"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)){\n                    socket = <span class="hljs-keyword">new</span> MozWebSocket(szServer);\n                }<span class="hljs-keyword">else</span>{\n                    socket = <span class="hljs-keyword">new</span> WebSocket(szServer);\n                }\n                <span class="hljs-keyword">if</span>(opts.onInit){\n                    opts.onInit();\n                }\n                <span class="hljs-comment">// 成功建立连接时触发</span>\n                socket.onopen = messageevent.onOpen;\n                <span class="hljs-comment">// 接受到服务器的数据触发</span>\n                socket.onmessage = messageevent.onReceive;\n                <span class="hljs-comment">// 发生错误时触发</span>\n                socket.onerror = messageevent.onError;\n                <span class="hljs-comment">// 连接关闭时触发</span>\n                socket.onclose = messageevent.onClose;\n            },\n            <span class="hljs-attr">onOpen</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{\n                bOpen = <span class="hljs-literal">true</span>;\n                <span class="hljs-keyword">if</span>(opts.onOpen){\n                    opts.onOpen(event);\n                }\n            },\n            <span class="hljs-attr">onSend</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>{\n                t1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();\n                <span class="hljs-keyword">if</span>(opts.onSend){\n                    opts.onSend(msg);\n                }\n                <span class="hljs-comment">// 发送数据至服务器</span>\n                socket.send(msg);\n            },\n            <span class="hljs-attr">onReceive</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>{\n                t2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();\n                <span class="hljs-keyword">if</span>(opts.onReceive){\n                    opts.onReceive(msg.data,t2 - t1);\n                }\n            },\n            <span class="hljs-attr">onError</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{\n                <span class="hljs-keyword">if</span>(opts.onError){\n                    opts.onError(event);\n                }\n            },\n            <span class="hljs-attr">onClose</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>{\n                <span class="hljs-keyword">if</span>(opts.onClose){\n                    opts.onClose(event);\n                }\n                <span class="hljs-comment">// 关闭连接</span>\n                <span class="hljs-keyword">if</span>(socket.close() != <span class="hljs-literal">null</span>){\n                    socket = <span class="hljs-literal">null</span>;\n                }\n            }\n        }\n        messageevent.onInit();\n        <span class="hljs-keyword">this</span>.send = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pData</span>)</span>{\n            <span class="hljs-keyword">if</span>(bOpen == <span class="hljs-literal">false</span>){\n                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;\n            }\n            messageevent.onSend(pData);\n            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;\n        }\n        <span class="hljs-comment">//</span>\n        <span class="hljs-keyword">this</span>.close = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{\n            messageevent.onClose();\n        }\n        <span class="hljs-keyword">this</span>.bOpen=bOpen;\n        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;\n    };\n})(jQuery);</code></pre>\n<ul>\n<li>利用封装好的 <code>jquery.websocket</code> 建立websocket对象，建立与服务器的长连接</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">ws = $.websocket({\n        <span class="hljs-comment">// 服务器的连接的url</span>\n    path: <span class="hljs-string">\'autoexam/websocket/chat?tag=\'</span>+<span class="hljs-built_in">window</span>.axTag,\n    <span class="hljs-attr">onReceive</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, time</span>) </span>{\n        <span class="hljs-comment">/**\n         * data : 服务器来的数据\n         * time : 接受数据的时间戳\n         */</span>\n    },\n    <span class="hljs-attr">onClose</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}\n});</code></pre>\n<ul>\n<li>发送数据至服务器和关闭连接</li>\n</ul>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript">ws.send(<span class="hljs-built_in">JSON</span>.stringify({\n    <span class="hljs-attr">to</span>:<span class="hljs-string">\'\'</span>, <span class="hljs-comment">//\'common\'->公共聊天室; 用户名->好友聊天</span>\n    content: um.getContent() <span class="hljs-comment">// 发送的内容</span>\n}));\nws.close();</code></pre>\n<h2 id="后端-java"><a href="#%E5%90%8E%E7%AB%AF-java" aria-hidden="true"><span class="icon icon-link"></span></a>后端 (Java)</h2>\n<h3 id="基本数据集"><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%9B%86" aria-hidden="true"><span class="icon icon-link"></span></a>基本数据集</h3>\n<pre><code class="hljs language-java" data-query="{}" data-lang="java"><span class="hljs-meta">@ServerEndpoint</span>(value = <span class="hljs-string">"/websocket/chat"</span>,configurator=GetHttpSessionConfigurator.class)<span class="hljs-comment">//configurator是为了得到HttpSession</span>\n<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>{\n    <span class="hljs-comment">// 当前存在的所有websocket连接(被封装在ChatServer对象中)</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&#x3C;String,List&#x3C;ChatServer>> connections = Collections.synchronizedMap(<span class="hljs-keyword">new</span> HashMap&#x3C;>());\n\n    <span class="hljs-comment">// 下面4个Map对象是为了实现</span>\n    <span class="hljs-comment">// 发送添加好友请求/被拒绝添加好友/被通过添加好友/发送消息接受 接受人当时不在线。</span>\n    <span class="hljs-comment">// 当下次这4个Map中的key上线时，再发送相关的信息。 ...比较拗口</span>\n\n    <span class="hljs-comment">// 暂时存放添加好友请求(未被处理)的Map，key->待接受人，value->发送请求人集合</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&#x3C;String,Set&#x3C;String>> rev_sender = <span class="hljs-keyword">new</span> ConcurrentHashMap();\n    <span class="hljs-comment">// 暂时存放添加好友求被拒绝的Map，key->被拒绝人(发添加请求人)，value->拒绝人集合</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&#x3C;String,Set&#x3C;String>> ignore_rev_sender = <span class="hljs-keyword">new</span> ConcurrentHashMap();\n    <span class="hljs-comment">// 暂时存放添加好友求被允许的Map，key->被允许人(发添加请求人)，value->允许人集合</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&#x3C;String,Set&#x3C;String>> pass_rev_sender= <span class="hljs-keyword">new</span> ConcurrentHashMap();\n    <span class="hljs-comment">// 暂时存放好友聊天内容的Map，key->接受消息人，value->消息内容(包括时间/内容/发送人)</span>\n    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&#x3C;String,List&#x3C;JSONObject>> remain_msgs = <span class="hljs-keyword">new</span> ConcurrentHashMap();\n\n    <span class="hljs-keyword">private</span> String name;\n    <span class="hljs-comment">// websocket会话对象</span>\n    <span class="hljs-keyword">public</span> Session session;\n    <span class="hljs-comment">// httpsession会话对象</span>\n    <span class="hljs-keyword">public</span> HttpSession httpSession;\n\n}</code></pre>\n<h3 id="细节考虑"><a href="#%E7%BB%86%E8%8A%82%E8%80%83%E8%99%91" aria-hidden="true"><span class="icon icon-link"></span></a>细节考虑</h3>\n<ol>\n<li>为了防止服务器重启/关闭导致数据丢失，所以在服务器关闭时触发的事件中，将必要的数据写入文件中；在服务器启动时触发的事件中，再将数据写回内存。</li>\n</ol>\n<pre><code class="hljs language-java" data-query="{}" data-lang="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException </span>{\n    ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(path));\n    oos.writeObject(rev_sender);\n    oos.writeObject(ignore_rev_sender);\n    oos.writeObject(pass_rev_sender);\n    <span class="hljs-comment">// 因为JSONObject类没有implements Serializable，所以只好将JSONObject转换为String对象写入文件</span>\n    Map&#x3C;String,List&#x3C;Object>> new_remain_msgs = <span class="hljs-keyword">new</span> ConcurrentHashMap&#x3C;>();\n    <span class="hljs-keyword">for</span>(String key:remain_msgs.keySet()){\n        List&#x3C;JSONObject> l = remain_msgs.get(key);\n        List newl = <span class="hljs-keyword">new</span> LinkedList&#x3C;>();\n        <span class="hljs-keyword">for</span>(JSONObject jo:l)\n            newl.add(jo.toString());\n        new_remain_msgs.put(key,newl);\n    }\n    oos.writeObject(new_remain_msgs);\n\n    oos.flush();\n    oos.close();\n}\n<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>{\n    ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(path));\n    rev_sender = (Map&#x3C;String, Set&#x3C;String>>) ois.readObject();\n    ignore_rev_sender = (Map&#x3C;String, Set&#x3C;String>>) ois.readObject();\n    pass_rev_sender = (Map&#x3C;String, Set&#x3C;String>>) ois.readObject();\n    Map&#x3C;String,List> new_remain_msgs = (Map&#x3C;String, List>) ois.readObject();\n    ois.close();\n    <span class="hljs-keyword">for</span>(String key : new_remain_msgs.keySet()){\n        List newl = new_remain_msgs.get(key);\n        List&#x3C;JSONObject> l = <span class="hljs-keyword">new</span> LinkedList&#x3C;>();\n        <span class="hljs-keyword">for</span>(Object o:newl)\n            l.add(JSONObject.fromObject(o));\n        remain_msgs.put(key,l);\n    }\n}</code></pre>\n<ol start="2">\n<li>\n<p>用户在未进入考友互动模块时，应该也能实时地接受相关的添加好友请求，新的消息请求。\n<img src="http://obu9je6ng.bkt.clouddn.com/FpumBNDxUXAbs0Segq64KtgrQBk5?imageslim" alt="ClipboardImage" width="1572" height="869" />\n首先，在其他非聊天界面，设置\nwindow.axTag="login";\n而在聊天界面中设置\nwindow.axTag=\'chat\';\n回到上面的建立websocket连接的代码\npath: \'autoexam/websocket/chat?tag=\'+window.axTag\n这下就明白了，通过连接的url串传递是当前用户在哪类页面，然后进行不同的数据传输。</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ol>\n<h1 id="小结与源码地址"><a href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80" aria-hidden="true"><span class="icon icon-link"></span></a>小结与源码地址</h1>\n<p>该在线考试交友系统是我独自花费了较大心血完成的项目，\n我也从中获取了许多，包括技术细节上的，项目规划上的。\n再推荐下该项目 <a href="http://moyuyc.xyz/autoexam">http://moyuyc.xyz/autoexam</a>\n还可以 <a href="https://github.com/moyuyc/autoexam_system">Fork It</a>\n最后做下功能总结\n1. 发送邮件\n2. 考卷Word导出\n3. 图像上传切割与旋转\n4. 聊天图片可放缩\n5. 聊天历史记录\n6. 新消息提示与跳转\n7. 后台题库excel批量导入\n8. ...</p>\n',extra:{}}}});