{"version":3,"sources":["webpack:///sync-request-in-nodejs.js","webpack:///./source/_articles/sync-request-in-nodejs.md"],"names":["webpackJsonp","1236","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,4rYACAC,OACAC,oBACAC","file":"sync-request-in-nodejs.js","sourcesContent":["webpackJsonp([29,113],{\n\n/***/ 1236:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>node.js 以异步方式、事件队列为标准，基本每一套与网络、IO 相关的 API 都会设计成异步的。</p><p>如，一段很平常的请求代码，用 node.js 只能用异步方式。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> https = <span class=hljs-built_in>require</span>(<span class=hljs-string>'https'</span>);\\n\\nhttps.get(<span class=hljs-string>\\\"https://nodejs.org/api/https.html\\\"</span>, res => res.pipe(process.stdout))</code></pre><p>异步方式不会阻塞进程，充分利用 CPU。</p><p>但是，对于一些一次性的脚本、批处理，我们希望使用同步的方式。因为以上情形，对于效率要求不是十分迫切，更多的是需要清晰的代码结构，简明的代码逻辑。</p><p>本人在之前的 <a href=https://github.com/moyuyc/node-markdown-image-size>markdown-image-size</a> 中，有这么个需求：</p><blockquote><p>浏览器在未加载完图片数据的时候，浏览器是不知道其大小的 所以，默认大小都是 0，除非通过 style 设置了大小 之后的某个时候，图片加载完成，浏览器得到图片大小，文章就会有跳动的感觉，阅读体验不佳</p><p>解决该问题，将 markdown 文本中的 <code>![](src)</code> 和 <code>&lt;img src=\\\"src\\\" /></code> 中的 <code>src</code> 匹配出来，如果是本地文件则读文件，得到图片大小；或者发送请求，得到图片数据进而得到图片大小，最后进行字符串 替换/插入，成为如下的 HTML 格式文本。</p><p><code>&lt;img width=\\\"100\\\" height=\\\"100\\\" src=\\\"url\\\" /></code></p></blockquote><p>在这种情况下，同步的网络请求比异步的请求会更加合适，代码更加清晰，逻辑更简单，而且对代码效率要求不高。如下，便是简化后的同步请求，文本替换的代码。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>content.replace(<span class=hljs-regexp>/!\\\\[(.*)\\\\]\\\\((.*?[^\\\\\\\\])\\\\)/g</span>, (matched, alt, src) => {\\n    <span class=hljs-comment>// get image data from src synchronously</span>\\n    <span class=hljs-keyword>const</span> data = getData(src);\\n    <span class=hljs-keyword>const</span> size = sizeOf(data);\\n    <span class=hljs-keyword>return</span> <span class=hljs-string>`&lt;img alt=<span class=hljs-subst>${alt}</span> src=<span class=hljs-subst>${src}</span> width=<span class=hljs-subst>${size.width}</span> height=<span class=hljs-subst>${size.height}</span> />`</span>\\n})</code></pre><p>如果使用的是异步，则不能在第二个参数中直接 return 替换后的文本了，就需要更加复杂的代码逻辑（如标记文本的位置和长度，待请求结束后，进行替换）。</p><p>那么具体应该如何实现 node.js 的同步请求呢？</p><!--more--><p>谷歌 \\\"sync request in nodejs\\\"</p><p>搜索结果中出来一个 <a href=https://www.npmjs.com/package/sync-request>sync-request</a>，<code>npm install</code> 后果然能够同步网络请求，这顿时勾起了我的兴趣：在一个官方没有提供同步请求 api 的情况下，该第三方包是怎么实现请求的同步的呢？</p><p>阅读源码之后才发现作者十分巧妙的将异步问题转化成了同步问题，分析如下。</p><h2 id=sync-request><a href=#sync-request aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>sync-request</code></h2><p>在 <a href=https://github.com/ForbesLindesay/sync-request#how-is-this-possible>readme</a> 中，作者有这样一段话：</p><blockquote><h3 id=how-is-this-possible><a href=#how-is-this-possible aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>How is this possible?</h3><p>Internally, this uses a separate worker process that is run using childProcess.spawnSync.</p><p>The worker then makes the actual request using then-request so this has almost exactly the same API as that.</p><p>This can also be used in a web browser via browserify because xhr has built in support for synchronous execution. Note that this is not recommended as it will be blocking.</p></blockquote><p>简言之作者实际上发送请求是用的 <a href=https://github.com/then/then-request><code>then-request</code></a>，对官方的异步 API 用 Promise 进行封装，所以其是异步请求方式。</p><p>异步转化同步方式，主要是借助了 <code>childProcess.spawnSync</code> 方法，创建<strong>同步进程</strong>。</p><p>阅读源码之后，基本的流程如下：</p><img src=false width=748 height=453 data-src=http://obu9je6ng.bkt.clouddn.com/FqF0tsO2D-38ngCbsbAbtprHwDH8?imageslim><p>首先需要 <code>nc</code> 指令的作用，以及标准输入输出如何传递字节数组。</p><p>man page 中对 <code>nc</code> 的介绍为：</p><blockquote><p>nc -- arbitrary TCP and UDP connections and listens<br>usage: nc<options>[hostname]port[s]]</options></p></blockquote><p>就是一个底层的系统调用，用于建立 TCP/UDP 连接或者监听某端口的，由于是系统调用，所以速度更快，效率更高。</p><p>标准输入输出如何传递字节数组，就需要将字节数组转化成字符串，然后在处理之前转化成字节数组，默认 nodejs 实现是将 Buffer 序列化为 <code>{\\\"type\\\":\\\"Buffer\\\",\\\"data\\\":[1,2,3,4,5]}</code>，分成2个字段表示，但是这样是不能够反序列化回来的。</p><p>则需要重写 JSON 序列化的方法，主要是对 Buffer 的处理。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>stringify</span> (<span class=hljs-params>o</span>) </span>{\\n    <span class=hljs-keyword>if</span>(o &amp&amp Buffer.isBuffer(o)) <span class=hljs-comment>// hex, ascii 都是可以的</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>':base64:'</span> + o.toString(<span class=hljs-string>'base64'</span>));\\n    <span class=hljs-keyword>if</span> (<span class=hljs-string>'string'</span> === <span class=hljs-keyword>typeof</span> o) {\\n        <span class=hljs-comment>// 避免将 buffer 误认为 string</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-regexp>/^:/</span>.test(o) ? <span class=hljs-string>':'</span> + o : o)\\n    }\\n    <span class=hljs-comment>// 其他维持原样</span>\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>parse</span> (<span class=hljs-params>o</span>) </span>{\\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.parse(s, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>key, value</span>) </span>{\\n        <span class=hljs-keyword>if</span>(<span class=hljs-string>'string'</span> === <span class=hljs-keyword>typeof</span> value) {\\n          <span class=hljs-keyword>if</span>(<span class=hljs-regexp>/^:base64:/</span>.test(value))\\n            <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> Buffer(value.substring(<span class=hljs-number>8</span>), <span class=hljs-string>'hex'</span>)\\n          <span class=hljs-keyword>else</span> <span class=hljs-comment>// string</span>\\n            <span class=hljs-keyword>return</span> <span class=hljs-regexp>/^:/</span>.test(value) ? value.substring(<span class=hljs-number>1</span>) : value\\n        }\\n        <span class=hljs-keyword>return</span> value\\n    })\\n}</code></pre><p>理解了以上之后，再来具体看看代码</p><ul><li>find-port.js<br>得到一个空闲的端口返回，基本原理如下（仅为部分代码）</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>module</span>.exports = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t<span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Promise</span>(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>resolve, reject</span>) </span>{\\n\\t\\t<span class=hljs-keyword>var</span> server = net.createServer();\\n\\n\\t\\tserver.unref();\\n\\t\\tserver.on(<span class=hljs-string>'error'</span>, reject);\\n        <span class=hljs-comment>// port = 0, 绑定可用的端口</span>\\n\\t\\tserver.listen(<span class=hljs-number>0</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t\\t\\t<span class=hljs-keyword>var</span> port = server.address().port;\\n\\n\\t\\t\\tserver.close(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t\\t\\t\\tresolve(port);\\n\\t\\t\\t});\\n\\t\\t});\\n\\t});\\n};</code></pre><ul><li>legacy-work.js<br>使用标准输入输出作为参数的来源和返回的出口，处理网络请求 (then-request)</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> concat = <span class=hljs-built_in>require</span>(<span class=hljs-string>'concat-stream'</span>);\\n<span class=hljs-keyword>const</span> request = <span class=hljs-built_in>require</span>(<span class=hljs-string>'then-request'</span>);\\n<span class=hljs-keyword>const</span> <span class=hljs-built_in>JSON</span> = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./json-buffer'</span>);\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>respond</span>(<span class=hljs-params>data</span>) </span>{\\n  process.stdout.write(<span class=hljs-built_in>JSON</span>.stringify(data), <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    process.exit(<span class=hljs-number>0</span>);\\n  });\\n}\\n\\nprocess.stdin.pipe(concat(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>stdin</span>) </span>{\\n  <span class=hljs-keyword>var</span> req = <span class=hljs-built_in>JSON</span>.parse(stdin.toString());\\n  request(req.method, req.url, req.options).done(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>response</span>) </span>{\\n    respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>response</span>: response});\\n  }, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err</span>) </span>{\\n    respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: err.message }});\\n  });\\n}));</code></pre><ul><li>nc-server.js<br>启动一个 TCP 服务端，为 nc 指令通信</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> net = <span class=hljs-built_in>require</span>(<span class=hljs-string>'net'</span>);\\n<span class=hljs-keyword>const</span> concat = <span class=hljs-built_in>require</span>(<span class=hljs-string>'concat-stream'</span>);\\n<span class=hljs-keyword>const</span> request = <span class=hljs-built_in>require</span>(<span class=hljs-string>'then-request'</span>);\\n<span class=hljs-keyword>const</span> <span class=hljs-built_in>JSON</span> = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./json-buffer'</span>);\\n\\n<span class=hljs-keyword>const</span> server = net.createServer({<span class=hljs-attr>allowHalfOpen</span>: <span class=hljs-literal>true</span>}, c => {\\n  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>respond</span>(<span class=hljs-params>data</span>) </span>{\\n    c.end(<span class=hljs-built_in>JSON</span>.stringify(data));\\n  }\\n\\n  c.pipe(concat(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>stdin</span>) </span>{\\n    <span class=hljs-keyword>try</span> {\\n      <span class=hljs-keyword>const</span> req = <span class=hljs-built_in>JSON</span>.parse(stdin.toString());\\n      request(req.method, req.url, req.options).done(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>response</span>) </span>{\\n        respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>response</span>: response});\\n      }, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err</span>) </span>{\\n        respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: err.message }});\\n      });\\n    } <span class=hljs-keyword>catch</span> (ex) {\\n      respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: ex.message }});\\n    }\\n  }));\\n});\\n\\nserver.listen(+process.argv[<span class=hljs-number>2</span>]);</code></pre><p>其中 <code>{ allowHalfOpen: true }</code> 不可少，因为在执行 <code>spawnSync('nc', [\\\"127.0.0.1\\\", nPort], {input: request})</code> 时，input 是 JSON 序列话后的字符串，输入后就到 EOF 了，相当于在 Shell 中 Ctrl+D 控制键，nc 客户端套接字就关闭了，只有允许半开套接字，客户端才能收到服务器的数据。如下图：对应为客户端的 FIN_WAIT_2 ~ TIME_WAIT 周期之间，服务器依旧可以发送数据。</p><img src=false width=600 height=509 data-src=http://obu9je6ng.bkt.clouddn.com/FnixeQVF2AFq-_T53WvL6Ubvk9WV?imageslim><p>以上，便是对部分源码的解析</p><p>所以，最终的请求还是通过 <code>then-request</code> 来实现的，但是对于 <code>then-request</code> 并不支持 <code>multipart/formdata</code>，因此 <code>sync-request</code> 也是不支持的。 于是本人在 fork 之后，配合 <a href=https://www.npmjs.com/package/form-data#alternative-submission-methods><code>form-data</code></a> 提了 <a href=https://github.com/then/then-request/pull/28>pr</a>，希望作者能够早日 merge 吧。</p><p>最后想说：<em>原来还可以这样实现同步！</em></p>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// sync-request-in-nodejs.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>node.js 以异步方式、事件队列为标准，基本每一套与网络、IO 相关的 API 都会设计成异步的。</p><p>如，一段很平常的请求代码，用 node.js 只能用异步方式。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> https = <span class=hljs-built_in>require</span>(<span class=hljs-string>'https'</span>);\\n\\nhttps.get(<span class=hljs-string>\\\"https://nodejs.org/api/https.html\\\"</span>, res => res.pipe(process.stdout))</code></pre><p>异步方式不会阻塞进程，充分利用 CPU。</p><p>但是，对于一些一次性的脚本、批处理，我们希望使用同步的方式。因为以上情形，对于效率要求不是十分迫切，更多的是需要清晰的代码结构，简明的代码逻辑。</p><p>本人在之前的 <a href=https://github.com/moyuyc/node-markdown-image-size>markdown-image-size</a> 中，有这么个需求：</p><blockquote><p>浏览器在未加载完图片数据的时候，浏览器是不知道其大小的 所以，默认大小都是 0，除非通过 style 设置了大小 之后的某个时候，图片加载完成，浏览器得到图片大小，文章就会有跳动的感觉，阅读体验不佳</p><p>解决该问题，将 markdown 文本中的 <code>![](src)</code> 和 <code>&lt;img src=\\\"src\\\" /></code> 中的 <code>src</code> 匹配出来，如果是本地文件则读文件，得到图片大小；或者发送请求，得到图片数据进而得到图片大小，最后进行字符串 替换/插入，成为如下的 HTML 格式文本。</p><p><code>&lt;img width=\\\"100\\\" height=\\\"100\\\" src=\\\"url\\\" /></code></p></blockquote><p>在这种情况下，同步的网络请求比异步的请求会更加合适，代码更加清晰，逻辑更简单，而且对代码效率要求不高。如下，便是简化后的同步请求，文本替换的代码。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript>content.replace(<span class=hljs-regexp>/!\\\\[(.*)\\\\]\\\\((.*?[^\\\\\\\\])\\\\)/g</span>, (matched, alt, src) => {\\n    <span class=hljs-comment>// get image data from src synchronously</span>\\n    <span class=hljs-keyword>const</span> data = getData(src);\\n    <span class=hljs-keyword>const</span> size = sizeOf(data);\\n    <span class=hljs-keyword>return</span> <span class=hljs-string>`&lt;img alt=<span class=hljs-subst>${alt}</span> src=<span class=hljs-subst>${src}</span> width=<span class=hljs-subst>${size.width}</span> height=<span class=hljs-subst>${size.height}</span> />`</span>\\n})</code></pre><p>如果使用的是异步，则不能在第二个参数中直接 return 替换后的文本了，就需要更加复杂的代码逻辑（如标记文本的位置和长度，待请求结束后，进行替换）。</p><p>那么具体应该如何实现 node.js 的同步请求呢？</p><!--more--><p>谷歌 \\\"sync request in nodejs\\\"</p><p>搜索结果中出来一个 <a href=https://www.npmjs.com/package/sync-request>sync-request</a>，<code>npm install</code> 后果然能够同步网络请求，这顿时勾起了我的兴趣：在一个官方没有提供同步请求 api 的情况下，该第三方包是怎么实现请求的同步的呢？</p><p>阅读源码之后才发现作者十分巧妙的将异步问题转化成了同步问题，分析如下。</p><h2 id=sync-request><a href=#sync-request aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a><code>sync-request</code></h2><p>在 <a href=https://github.com/ForbesLindesay/sync-request#how-is-this-possible>readme</a> 中，作者有这样一段话：</p><blockquote><h3 id=how-is-this-possible><a href=#how-is-this-possible aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>How is this possible?</h3><p>Internally, this uses a separate worker process that is run using childProcess.spawnSync.</p><p>The worker then makes the actual request using then-request so this has almost exactly the same API as that.</p><p>This can also be used in a web browser via browserify because xhr has built in support for synchronous execution. Note that this is not recommended as it will be blocking.</p></blockquote><p>简言之作者实际上发送请求是用的 <a href=https://github.com/then/then-request><code>then-request</code></a>，对官方的异步 API 用 Promise 进行封装，所以其是异步请求方式。</p><p>异步转化同步方式，主要是借助了 <code>childProcess.spawnSync</code> 方法，创建<strong>同步进程</strong>。</p><p>阅读源码之后，基本的流程如下：</p><img src=false width=748 height=453 data-src=http://obu9je6ng.bkt.clouddn.com/FqF0tsO2D-38ngCbsbAbtprHwDH8?imageslim><p>首先需要 <code>nc</code> 指令的作用，以及标准输入输出如何传递字节数组。</p><p>man page 中对 <code>nc</code> 的介绍为：</p><blockquote><p>nc -- arbitrary TCP and UDP connections and listens<br>usage: nc<options>[hostname]port[s]]</options></p></blockquote><p>就是一个底层的系统调用，用于建立 TCP/UDP 连接或者监听某端口的，由于是系统调用，所以速度更快，效率更高。</p><p>标准输入输出如何传递字节数组，就需要将字节数组转化成字符串，然后在处理之前转化成字节数组，默认 nodejs 实现是将 Buffer 序列化为 <code>{\\\"type\\\":\\\"Buffer\\\",\\\"data\\\":[1,2,3,4,5]}</code>，分成2个字段表示，但是这样是不能够反序列化回来的。</p><p>则需要重写 JSON 序列化的方法，主要是对 Buffer 的处理。</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>stringify</span> (<span class=hljs-params>o</span>) </span>{\\n    <span class=hljs-keyword>if</span>(o &amp&amp Buffer.isBuffer(o)) <span class=hljs-comment>// hex, ascii 都是可以的</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-string>':base64:'</span> + o.toString(<span class=hljs-string>'base64'</span>));\\n    <span class=hljs-keyword>if</span> (<span class=hljs-string>'string'</span> === <span class=hljs-keyword>typeof</span> o) {\\n        <span class=hljs-comment>// 避免将 buffer 误认为 string</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.stringify(<span class=hljs-regexp>/^:/</span>.test(o) ? <span class=hljs-string>':'</span> + o : o)\\n    }\\n    <span class=hljs-comment>// 其他维持原样</span>\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>parse</span> (<span class=hljs-params>o</span>) </span>{\\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>JSON</span>.parse(s, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>key, value</span>) </span>{\\n        <span class=hljs-keyword>if</span>(<span class=hljs-string>'string'</span> === <span class=hljs-keyword>typeof</span> value) {\\n          <span class=hljs-keyword>if</span>(<span class=hljs-regexp>/^:base64:/</span>.test(value))\\n            <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> Buffer(value.substring(<span class=hljs-number>8</span>), <span class=hljs-string>'hex'</span>)\\n          <span class=hljs-keyword>else</span> <span class=hljs-comment>// string</span>\\n            <span class=hljs-keyword>return</span> <span class=hljs-regexp>/^:/</span>.test(value) ? value.substring(<span class=hljs-number>1</span>) : value\\n        }\\n        <span class=hljs-keyword>return</span> value\\n    })\\n}</code></pre><p>理解了以上之后，再来具体看看代码</p><ul><li>find-port.js<br>得到一个空闲的端口返回，基本原理如下（仅为部分代码）</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-built_in>module</span>.exports = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t<span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Promise</span>(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>resolve, reject</span>) </span>{\\n\\t\\t<span class=hljs-keyword>var</span> server = net.createServer();\\n\\n\\t\\tserver.unref();\\n\\t\\tserver.on(<span class=hljs-string>'error'</span>, reject);\\n        <span class=hljs-comment>// port = 0, 绑定可用的端口</span>\\n\\t\\tserver.listen(<span class=hljs-number>0</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t\\t\\t<span class=hljs-keyword>var</span> port = server.address().port;\\n\\n\\t\\t\\tserver.close(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n\\t\\t\\t\\tresolve(port);\\n\\t\\t\\t});\\n\\t\\t});\\n\\t});\\n};</code></pre><ul><li>legacy-work.js<br>使用标准输入输出作为参数的来源和返回的出口，处理网络请求 (then-request)</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> concat = <span class=hljs-built_in>require</span>(<span class=hljs-string>'concat-stream'</span>);\\n<span class=hljs-keyword>const</span> request = <span class=hljs-built_in>require</span>(<span class=hljs-string>'then-request'</span>);\\n<span class=hljs-keyword>const</span> <span class=hljs-built_in>JSON</span> = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./json-buffer'</span>);\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>respond</span>(<span class=hljs-params>data</span>) </span>{\\n  process.stdout.write(<span class=hljs-built_in>JSON</span>.stringify(data), <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    process.exit(<span class=hljs-number>0</span>);\\n  });\\n}\\n\\nprocess.stdin.pipe(concat(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>stdin</span>) </span>{\\n  <span class=hljs-keyword>var</span> req = <span class=hljs-built_in>JSON</span>.parse(stdin.toString());\\n  request(req.method, req.url, req.options).done(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>response</span>) </span>{\\n    respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>response</span>: response});\\n  }, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err</span>) </span>{\\n    respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: err.message }});\\n  });\\n}));</code></pre><ul><li>nc-server.js<br>启动一个 TCP 服务端，为 nc 指令通信</li></ul><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> net = <span class=hljs-built_in>require</span>(<span class=hljs-string>'net'</span>);\\n<span class=hljs-keyword>const</span> concat = <span class=hljs-built_in>require</span>(<span class=hljs-string>'concat-stream'</span>);\\n<span class=hljs-keyword>const</span> request = <span class=hljs-built_in>require</span>(<span class=hljs-string>'then-request'</span>);\\n<span class=hljs-keyword>const</span> <span class=hljs-built_in>JSON</span> = <span class=hljs-built_in>require</span>(<span class=hljs-string>'./json-buffer'</span>);\\n\\n<span class=hljs-keyword>const</span> server = net.createServer({<span class=hljs-attr>allowHalfOpen</span>: <span class=hljs-literal>true</span>}, c => {\\n  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>respond</span>(<span class=hljs-params>data</span>) </span>{\\n    c.end(<span class=hljs-built_in>JSON</span>.stringify(data));\\n  }\\n\\n  c.pipe(concat(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>stdin</span>) </span>{\\n    <span class=hljs-keyword>try</span> {\\n      <span class=hljs-keyword>const</span> req = <span class=hljs-built_in>JSON</span>.parse(stdin.toString());\\n      request(req.method, req.url, req.options).done(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>response</span>) </span>{\\n        respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>response</span>: response});\\n      }, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>err</span>) </span>{\\n        respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: err.message }});\\n      });\\n    } <span class=hljs-keyword>catch</span> (ex) {\\n      respond({<span class=hljs-attr>success</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>error</span>: { <span class=hljs-attr>message</span>: ex.message }});\\n    }\\n  }));\\n});\\n\\nserver.listen(+process.argv[<span class=hljs-number>2</span>]);</code></pre><p>其中 <code>{ allowHalfOpen: true }</code> 不可少，因为在执行 <code>spawnSync('nc', [\\\"127.0.0.1\\\", nPort], {input: request})</code> 时，input 是 JSON 序列话后的字符串，输入后就到 EOF 了，相当于在 Shell 中 Ctrl+D 控制键，nc 客户端套接字就关闭了，只有允许半开套接字，客户端才能收到服务器的数据。如下图：对应为客户端的 FIN_WAIT_2 ~ TIME_WAIT 周期之间，服务器依旧可以发送数据。</p><img src=false width=600 height=509 data-src=http://obu9je6ng.bkt.clouddn.com/FnixeQVF2AFq-_T53WvL6Ubvk9WV?imageslim><p>以上，便是对部分源码的解析</p><p>所以，最终的请求还是通过 <code>then-request</code> 来实现的，但是对于 <code>then-request</code> 并不支持 <code>multipart/formdata</code>，因此 <code>sync-request</code> 也是不支持的。 于是本人在 fork 之后，配合 <a href=https://www.npmjs.com/package/form-data#alternative-submission-methods><code>form-data</code></a> 提了 <a href=https://github.com/then/then-request/pull/28>pr</a>，希望作者能够早日 merge 吧。</p><p>最后想说：<em>原来还可以这样实现同步！</em></p>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/sync-request-in-nodejs.md\n// module id = 1236\n// module chunks = 29"],"sourceRoot":""}