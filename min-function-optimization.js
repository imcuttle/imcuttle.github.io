webpackJsonp([47,90],{1016:function(s,n){s.exports={content:'<blockquote>\n<p>几周没有更新文章了，因为在忙着其他事，最近又是春招时期，又到了笔试面试刷题的时候，我就来讲讲常用算法中的 迭代与递归，甚至于延伸至尾递归。</p>\n</blockquote>\n<h2 id="问题提出"><a href="#%E9%97%AE%E9%A2%98%E6%8F%90%E5%87%BA" aria-hidden="true"><span class="icon icon-link"></span></a>问题提出</h2>\n<blockquote>\n<p>用 JavaScript 实现一个类 Math.min 的方法。</p>\n<p>   min(1, 2, -3, 100, 7)<br>\n=> -3</p>\n</blockquote>\n<h2 id="方法一：迭代"><a href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E8%BF%AD%E4%BB%A3" aria-hidden="true"><span class="icon icon-link"></span></a>方法一：迭代</h2>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min_0</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> min = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];\n    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &#x3C; <span class="hljs-built_in">arguments</span>.length; i++) {\n        min = min > <span class="hljs-built_in">arguments</span>[i] ? <span class="hljs-built_in">arguments</span>[i] : min;\n    }\n    <span class="hljs-keyword">return</span> min;\n}</code></pre>\n<p>当然有些同学喜欢用些“高级”的 api，于是出现下面的方法：</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min_1</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> numbers = [].slice.call(<span class="hljs-built_in">arguments</span>)\n    <span class="hljs-keyword">return</span> numbers.slice(<span class="hljs-number">1</span>).reduce(<span class="hljs-function">(<span class="hljs-params">p, n</span>) =></span> {\n        <span class="hljs-keyword">return</span> p > n ? n : p;\n    }, numbers[<span class="hljs-number">0</span>]);\n}</code></pre>\n<p>这种方法很直观地就可以想到，面试官肯定是不会善罢甘休的，继续延伸下去问<br>\n“用递归方式怎么实现呢？”</p>\n<h2 id="方法二：递归"><a href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%80%92%E5%BD%92" aria-hidden="true"><span class="icon icon-link"></span></a>方法二：递归</h2>\n<p> 诚然，递归往往会占用更多的系统资源，还可能会导致栈溢出等问题，但递归也是很能考察一个程序员，良好逻辑思维能力的知识点。</p>\n<pre><code data-query="{}" data-lang="">function min_2 () {\n    var numbers = [].slice.call(arguments);\n    if (numbers.length === 1) {\n        return numbers[0];\n    } else {\n        var min = min_2.apply(null, numbers.slice(1));\n        return min > numbers[0] ? numbers[0] : min;\n    }\n}\n</code></pre>\n<p>此题也不难写成递归算法，但是面试官可能还是会深究下去，可能会比较其中不同方式的差异。</p>\n<h2 id="延伸问题"><a href="#%E5%BB%B6%E4%BC%B8%E9%97%AE%E9%A2%98" aria-hidden="true"><span class="icon icon-link"></span></a><em>延伸问题</em></h2>\n<ol>\n<li>\n<p><code>min0()</code>方法与 <code>min1()</code>方法比较，哪个效率会更高些（时间复杂度更低）呢？</p>\n<p>很显然，min0 效率更高，其不仅多了一步 <code>slice</code>，而且还额外用 <code>reduce</code> 方法创建了一个闭包，显然底层调用会更多</p>\n</li>\n<li>\n<p>如果把 <code>arguments</code> 转化成普通数组的 <code>slice</code> 方法用 <code>Array.from</code> 替换，哪个效率更高呢？</p>\n<p>关于该问题，则需要用事实来说话了：  </p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">slice_time</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">\'slice\'</span>);\n    [].slice.call(<span class="hljs-built_in">arguments</span>);\n    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">\'slice\'</span>);\n}\n\n<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">from_time</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">\'from\'</span>);\n    <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>);\n    <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">\'from\'</span>);\n}\n\n<span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10000</span>).fill(<span class="hljs-number">1</span>);\nslice_time.apply(<span class="hljs-literal">null</span>, arr);\nfrom_time.apply(<span class="hljs-literal">null</span>, arr);\n\n<span class="hljs-comment">// slice: 0.267ms</span>\n<span class="hljs-comment">// from: 5.787ms</span></code></pre>\n<p>结果很明显，所以我们应该尽量不用<code>Array.from</code></p>\n</li>\n<li>\n<p><code>min(1, 3, 4, 5)</code> 和 <code>min([1, 3, 4, 5])</code>的两种传参方式，各有什么优劣？</p>\n<p>借用问题2的代码，如果数组大小设置的足够大，很有可能会看到 <code>Maximum call stack size exceeded</code> 错误，也就是栈溢出。但是方法中并没有递归调用啊，为什么会存在栈溢出呢？<br>\n回答该问题，就需要对编译原理的知识有所了解了，函数中的参数也是会压入栈中的，一般是参数从右往左开始，依次压入（还分为值传递和引用传递等），所以如果参数列表过长，也是会导致栈溢出的。</p>\n<p>那第一种传参方式有什么好的呢？本人觉得除了书写更方便以外，还会把本来是（数组）引用传递的，更改为值传递（该例中是数字）</p>\n</li>\n<li>\n<p>如何改造递归方法中的 <code>min_2</code> 方法，使其成为尾递归，有效避免栈溢出的问题？</p>\n<p>首先我们知道递归最大的问题就是容易导致栈溢出，因为每次调用，内存中都需要保存调用记录。\n那么尾递归则是递归的一种特殊形式，可以通过尾递归，来覆盖当前的调用环境(主要是参数)，成为自己的调用环境。\n具体如下代码：</p>\n<pre><code class="hljs language-javascript" data-query="{}" data-lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">min_3</span> (<span class="hljs-params"></span>) </span>{\n    <span class="hljs-keyword">var</span> numbers = [].slice.call(<span class="hljs-built_in">arguments</span>);\n    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span> (<span class="hljs-params">arr, min_pos, pos</span>) </span>{\n<span class="hljs-meta">        \'use strict\'</span>;\n        <span class="hljs-keyword">var</span> min = arr[min_pos], val = arr[pos];\n        <span class="hljs-keyword">if</span> (pos === arr.length<span class="hljs-number">-1</span>) {\n            <span class="hljs-keyword">return</span> min;\n        } <span class="hljs-keyword">else</span> {\n            <span class="hljs-keyword">if</span> (val &#x3C; min) {\n                min_pos = pos;\n            }\n            <span class="hljs-keyword">return</span> inner(arr, min_pos, pos+<span class="hljs-number">1</span>);\n        }\n    }\n    <span class="hljs-keyword">return</span> inner(numbers, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);\n}</code></pre>\n<p>可以看到，在 inner 递归方法中，在最后 <strong><code>return inner(...)</code></strong>，没有其他的参数，所以调用该方法是可以覆盖掉当前调用环境的，所以并没有爆栈。<br>\nchrome中默认未开启尾递归优化，需要在函数中加上<code>\'use strict\';</code>\n同时需要在 <code>chrome://flags/#enable-javascript-harmony</code> 中开启</p>\n</li>\n</ol>\n<h2 id="其他资料"><a href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%96%99" aria-hidden="true"><span class="icon icon-link"></span></a>其他资料</h2>\n<p><a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html">尾调用优化</a></p>\n',extra:{}}}});