{"version":3,"sources":["webpack:///how-to-write-component-demo.js","webpack:///./source/_articles/how-to-write-component-demo.md"],"names":["webpackJsonp","1184","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,oqJACAC,OACAC,oBACAC","file":"how-to-write-component-demo.js","sourcesContent":["webpackJsonp([80,113],{\n\n/***/ 1184:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>目前前端开发都推崇一致组件化的开发思想，即看到业务页面之后，先不着急写页面；而是先观察，把一些具有共性的UI控件包装成组件（如 React/Vue/Web Component）。这样做的好处不言而喻，提供组件复用率，团队开发效率提升明显。</p><p>既然组件化的思想这么重要，那么对于某个组件单元，它本身是不依赖外部环境（如外部静态资源）的；同时它内部也需要有它自己的单元测试、文档，甚至包含 DEMO 代码。</p><p>对于单元测试、文档的意义不属于该文讨论范畴，下面展开说说组件 DEMO 的意义</p><h2 id=组件-demo-的意义><a href=#%E7%BB%84%E4%BB%B6-demo-%E7%9A%84%E6%84%8F%E4%B9%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>组件 DEMO 的意义</h2><h3 id=沟通、共享><a href=#%E6%B2%9F%E9%80%9A%E3%80%81%E5%85%B1%E4%BA%AB aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>沟通、共享</h3><p>项目开发人数一般为多人，多人开发的情境下，多了一份沟通的开销。</p><p>在没有 DEMO 的情景下，项目成员都是交叉沟通的（如该组件具体怎么用），而且这种沟通大都是低效的（无沉淀）； 而 组件 DEMO 的出现将内容聚合起来，项目成员都是面向 DEMO，去除了项目成员冗余沟通，表现方式也更为直观。</p><p>如果 DEMO 可以可视化集成文档，那么体验则更美妙。</p><h3 id=集成测试><a href=#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>集成测试</h3><p>组件 DEMO 另一个更为重要的意义则是方便 “集成测试”。拥有 DEMO 之后，我们可以直接使用 DEMO 服务去进行集成测试，而不需要额外搭建环境。</p><h2 id=实现组件-demo><a href=#%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6-demo aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现组件 DEMO</h2><p>不同组件有不同的 DEMO，一个组件还可能拥有多个 DEMO case，所以 DEMO 服务应该是有多路由的，</p><p>基于添加路由的方式不同，我将实现组件 DEMO 的方式划为两种方式：静态添加路由、动态添加路由。</p><h3 id=静态（不推荐）><a href=#%E9%9D%99%E6%80%81%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>静态（不推荐）</h3><p>通过模板去自动生成各个组件的 DEMO 路由代码；触发流程应该为：新建 demo 后，执行命令去写入静态路由</p><p>这种方法相对简单、不优雅，本文不展开说明</p><h3 id=运行时，动态路由匹配><a href=#%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>运行时，动态路由匹配</h3><p>其实市面上已经有一些现场的 DEMO 服务解决方案，如 <a href=https://github.com/storybooks/storybook>storybook</a> 和 <a href=https://github.com/styleguidist/react-styleguidist>react-styleguidist</a> 它们的共同点是他们都是独立的 webpack 环境，生态都很全面；</p><p>但是对于有些情况下，我们组件代码和 DEMO 是依赖我们项目环境的（如 webpack 配置，或者其他老项目依赖外部的静态资源），所以以上的方案可能不太适合，这时候就需要我们自己动手写一个 DEMO 架子了。</p><h4 id=demo-架子><a href=#demo-%E6%9E%B6%E5%AD%90 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>DEMO 架子</h4><p>其实动态路由添加的实现是基于 Webpack 中的 <code>require.context</code> 方法的</p><p><code>require.context(path, useSubdirectories, regExp)</code> 方法有三个参数</p><ul><li><code>path</code>: 要搜索的文件夹目录</li><li><code>useSubdirectories</code>: 是否还应该搜索它的子目录</li><li><code>regExp</code> 一个匹配文件的正则表达式</li></ul><p><code>require.context</code> 返回一个（require）函数，这个函数可以接收一个参数：<code>path</code> （这个 path 是基于要搜索的文件夹目录的）</p><p>实际上 <code>require.context</code> 是一个 Webpack 编译阶段用到的语法，而不是前端代码，所以如果执行 <code>console.log(require.context)</code> 打印的是 <code>undefined</code></p><p>如果我们组件的文件结构为:</p><pre><code data-query={} data-lang>components/\\n    Button/\\n        ...\\n        demo/  # 对应不同 case 的 demo 代码\\n            caseA.js\\n            caseB.js\\n</code></pre><p>使用该方法，我们可以使用如下代码来动态选择加载 DEMO 代码</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> req = <span class=hljs-built_in>require</span>.context(<span class=hljs-string>'components'</span>, <span class=hljs-literal>true</span>, /\\\\/demo\\\\/.+?\\\\.js$/)\\n<span class=hljs-comment>// 加载 DEMO</span>\\nreq.keys().map(<span class=hljs-function><span class=hljs-params>filename</span> =></span> req(filename))</code></pre><p>基于以上代码，我们可以动态的生成路由，从而渲染组件 DEMO</p><p>同时安利一个 React 高阶组件 <a href=https://github.com/m-cuttlefish/react-mhoc>react-hoc/editable</a>，使用这个高阶组件可以<strong>可视化操作更新组件数据</strong>，使我们更方便的修改组件内部的数据，从而更了解组件的使用。</p><p><a href=https://m-cuttlefish.github.io/react-mhoc/page/>react-hoc/editable DEMO 地址</a></p><p>你觉得你只有 DEMO 视图还不够，还需要 DEMO 源码展示？</p><h5 id=加上-demo-源码展示><a href=#%E5%8A%A0%E4%B8%8A-demo-%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>加上 DEMO 源码展示</h5><p>使用 webpack 的 <code>raw-loader</code>，即可加载 DEMO 为源码文本</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> rawReq = <span class=hljs-built_in>require</span>.context(<span class=hljs-string>'!raw-loader!dulife-ui'</span>, <span class=hljs-literal>true</span>, /\\\\/demo\\\\/.+?\\\\.js$/)</code></pre><p>最终效果如下： <img src=https://i.loli.net/2018/06/30/5b3741de4ed1e.png></p><h2 id=结尾><a href=#%E7%BB%93%E5%B0%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>结尾</h2><p>本人还是推荐动态添加路由方式中的 <a href=https://github.com/storybooks/storybook>storybook</a> 和 <a href=https://github.com/styleguidist/react-styleguidist>react-styleguidist</a> 生态！</p>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// how-to-write-component-demo.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><p>目前前端开发都推崇一致组件化的开发思想，即看到业务页面之后，先不着急写页面；而是先观察，把一些具有共性的UI控件包装成组件（如 React/Vue/Web Component）。这样做的好处不言而喻，提供组件复用率，团队开发效率提升明显。</p><p>既然组件化的思想这么重要，那么对于某个组件单元，它本身是不依赖外部环境（如外部静态资源）的；同时它内部也需要有它自己的单元测试、文档，甚至包含 DEMO 代码。</p><p>对于单元测试、文档的意义不属于该文讨论范畴，下面展开说说组件 DEMO 的意义</p><h2 id=组件-demo-的意义><a href=#%E7%BB%84%E4%BB%B6-demo-%E7%9A%84%E6%84%8F%E4%B9%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>组件 DEMO 的意义</h2><h3 id=沟通、共享><a href=#%E6%B2%9F%E9%80%9A%E3%80%81%E5%85%B1%E4%BA%AB aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>沟通、共享</h3><p>项目开发人数一般为多人，多人开发的情境下，多了一份沟通的开销。</p><p>在没有 DEMO 的情景下，项目成员都是交叉沟通的（如该组件具体怎么用），而且这种沟通大都是低效的（无沉淀）； 而 组件 DEMO 的出现将内容聚合起来，项目成员都是面向 DEMO，去除了项目成员冗余沟通，表现方式也更为直观。</p><p>如果 DEMO 可以可视化集成文档，那么体验则更美妙。</p><h3 id=集成测试><a href=#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>集成测试</h3><p>组件 DEMO 另一个更为重要的意义则是方便 “集成测试”。拥有 DEMO 之后，我们可以直接使用 DEMO 服务去进行集成测试，而不需要额外搭建环境。</p><h2 id=实现组件-demo><a href=#%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6-demo aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>实现组件 DEMO</h2><p>不同组件有不同的 DEMO，一个组件还可能拥有多个 DEMO case，所以 DEMO 服务应该是有多路由的，</p><p>基于添加路由的方式不同，我将实现组件 DEMO 的方式划为两种方式：静态添加路由、动态添加路由。</p><h3 id=静态（不推荐）><a href=#%E9%9D%99%E6%80%81%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>静态（不推荐）</h3><p>通过模板去自动生成各个组件的 DEMO 路由代码；触发流程应该为：新建 demo 后，执行命令去写入静态路由</p><p>这种方法相对简单、不优雅，本文不展开说明</p><h3 id=运行时，动态路由匹配><a href=#%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>运行时，动态路由匹配</h3><p>其实市面上已经有一些现场的 DEMO 服务解决方案，如 <a href=https://github.com/storybooks/storybook>storybook</a> 和 <a href=https://github.com/styleguidist/react-styleguidist>react-styleguidist</a> 它们的共同点是他们都是独立的 webpack 环境，生态都很全面；</p><p>但是对于有些情况下，我们组件代码和 DEMO 是依赖我们项目环境的（如 webpack 配置，或者其他老项目依赖外部的静态资源），所以以上的方案可能不太适合，这时候就需要我们自己动手写一个 DEMO 架子了。</p><h4 id=demo-架子><a href=#demo-%E6%9E%B6%E5%AD%90 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>DEMO 架子</h4><p>其实动态路由添加的实现是基于 Webpack 中的 <code>require.context</code> 方法的</p><p><code>require.context(path, useSubdirectories, regExp)</code> 方法有三个参数</p><ul><li><code>path</code>: 要搜索的文件夹目录</li><li><code>useSubdirectories</code>: 是否还应该搜索它的子目录</li><li><code>regExp</code> 一个匹配文件的正则表达式</li></ul><p><code>require.context</code> 返回一个（require）函数，这个函数可以接收一个参数：<code>path</code> （这个 path 是基于要搜索的文件夹目录的）</p><p>实际上 <code>require.context</code> 是一个 Webpack 编译阶段用到的语法，而不是前端代码，所以如果执行 <code>console.log(require.context)</code> 打印的是 <code>undefined</code></p><p>如果我们组件的文件结构为:</p><pre><code data-query={} data-lang>components/\\n    Button/\\n        ...\\n        demo/  # 对应不同 case 的 demo 代码\\n            caseA.js\\n            caseB.js\\n</code></pre><p>使用该方法，我们可以使用如下代码来动态选择加载 DEMO 代码</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> req = <span class=hljs-built_in>require</span>.context(<span class=hljs-string>'components'</span>, <span class=hljs-literal>true</span>, /\\\\/demo\\\\/.+?\\\\.js$/)\\n<span class=hljs-comment>// 加载 DEMO</span>\\nreq.keys().map(<span class=hljs-function><span class=hljs-params>filename</span> =></span> req(filename))</code></pre><p>基于以上代码，我们可以动态的生成路由，从而渲染组件 DEMO</p><p>同时安利一个 React 高阶组件 <a href=https://github.com/m-cuttlefish/react-mhoc>react-hoc/editable</a>，使用这个高阶组件可以<strong>可视化操作更新组件数据</strong>，使我们更方便的修改组件内部的数据，从而更了解组件的使用。</p><p><a href=https://m-cuttlefish.github.io/react-mhoc/page/>react-hoc/editable DEMO 地址</a></p><p>你觉得你只有 DEMO 视图还不够，还需要 DEMO 源码展示？</p><h5 id=加上-demo-源码展示><a href=#%E5%8A%A0%E4%B8%8A-demo-%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>加上 DEMO 源码展示</h5><p>使用 webpack 的 <code>raw-loader</code>，即可加载 DEMO 为源码文本</p><pre><code class=\\\"hljs language-javascript\\\"data-query={} data-lang=javascript><span class=hljs-keyword>const</span> rawReq = <span class=hljs-built_in>require</span>.context(<span class=hljs-string>'!raw-loader!dulife-ui'</span>, <span class=hljs-literal>true</span>, /\\\\/demo\\\\/.+?\\\\.js$/)</code></pre><p>最终效果如下： <img src=https://i.loli.net/2018/06/30/5b3741de4ed1e.png></p><h2 id=结尾><a href=#%E7%BB%93%E5%B0%BE aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>结尾</h2><p>本人还是推荐动态添加路由方式中的 <a href=https://github.com/storybooks/storybook>storybook</a> 和 <a href=https://github.com/styleguidist/react-styleguidist>react-styleguidist</a> 生态！</p>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/how-to-write-component-demo.md\n// module id = 1184\n// module chunks = 80"],"sourceRoot":""}