<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> 告别庞大 PSD，轻松测量尺寸 - Grass </title>
    <link rel="stylesheet" href="/style.css">
    <style>
        #music {
            position: fixed;
            top: 10px;
            left: 10px;
        }
    </style>
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="-1418100268"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">告别庞大 PSD，轻松测量尺寸</h1><div class="post-info" data-reactid="12"><time datetime="2018-09-18T22:37:29+00:00" data-reactid="13">Sep 18, 2018 10:37 PM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><style data-reactid="16">.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container&gt;pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container&gt;pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id="起因" data-reactid="17"><a href="#%E8%B5%B7%E5%9B%A0" aria-hidden="true" data-reactid="18"><span class="icon icon-link" data-reactid="19"></span></a><!-- react-text: 20 -->起因<!-- /react-text --></h2><p data-reactid="21">作为前端工程师，日常开发离不开 psd 文件。</p><p data-reactid="22"><!-- react-text: 23 -->但是日常开发的一个小弹窗页面，它的 psd 居然需要 <!-- /react-text --><strong data-reactid="24">30+Mb</strong><!-- react-text: 25 -->，所以经常得定期清理 psd...<!-- /react-text --></p><p data-reactid="26">对于我一个 PS 小菜鸡来说，用 PSD 无非只是需要用来度量元素大小（元素间距），查看属性等简单的功能。</p><h2 id="思考，对比" data-reactid="27"><a href="#%E6%80%9D%E8%80%83%EF%BC%8C%E5%AF%B9%E6%AF%94" aria-hidden="true" data-reactid="28"><span class="icon icon-link" data-reactid="29"></span></a><!-- react-text: 30 -->思考，对比<!-- /react-text --></h2><p data-reactid="31"><!-- react-text: 32 -->相对比于 sketch，sketch 具有 <!-- /react-text --><a href="https://github.com/utom/sketch-measure" data-reactid="33">sketch-measure</a><!-- react-text: 34 -->，设计师导出成静态资源给前端即可。<!-- /react-text --></p><p data-reactid="35"><img src="https://i.loli.net/2018/09/18/5ba0be21d368f.png" data-reactid="36"/></p><p data-reactid="37">对于 PSD 来说，市面上已经有如 pxcook / lanhuapp，体验也很不错，但是需要下载 U 同学提供的 (庞大的) psd 才能进行标注体验。</p><p data-reactid="38">而且有时候还是需要 U 同学给(庞大的) PSD 文件，我们才能在 pxcook / lanhuapp 中自动标注。</p><p data-reactid="39">于是鉴于以上，考虑做一个开源项目，类似于 sketch-measure， 定位为 psd-measure。</p><h2 id="效果展示" data-reactid="40"><a href="#%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA" aria-hidden="true" data-reactid="41"><span class="icon icon-link" data-reactid="42"></span></a><!-- react-text: 43 -->效果展示<!-- /react-text --></h2><p data-reactid="44"><a href="https://imcuttle.github.io/measure/" data-reactid="45">DEMO</a></p><p data-reactid="46"><img src="http://obu9je6ng.bkt.clouddn.com//1537411054.png?imageMogr2/thumbnail/!100p" data-reactid="47"/></p><p data-reactid="48"><a href="https://github.com/imcuttle/measure" data-reactid="49">源码</a></p><h3 id="命令行" data-reactid="50"><a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C" aria-hidden="true" data-reactid="51"><span class="icon icon-link" data-reactid="52"></span></a><!-- react-text: 53 -->命令行<!-- /react-text --></h3><p data-reactid="54">我们也可以使用命令行来导出页面标注</p><p data-reactid="55">bash</p><pre data-reactid="56"><code data-query="{}" data-lang="data-lang" data-reactid="57">npm i measure-export-cli -g
# 开启服务，在线预览 `path/to/psdDir` 下的 psd
measure-export start path/to/psdDir
# 构建 `path/to/psdDir` 下的 psd 至 `dist` 文件目录
measure-export build path/to/psdDir
</code></pre><h3 id="chrome-插件" data-reactid="58"><a href="#chrome-%E6%8F%92%E4%BB%B6" aria-hidden="true" data-reactid="59"><span class="icon icon-link" data-reactid="60"></span></a><!-- react-text: 61 -->Chrome 插件<!-- /react-text --></h3><p data-reactid="62">提供 Chrome 插件，当我们点击 psd 链接时候跳出 Measure UI，而不是下载 PSD，当然我们也可以点击右上方的下载进行下载。</p><p data-reactid="63"><img src="https://i.loli.net/2018/09/24/5ba8bd6ba8f09.png" data-reactid="64"/></p><h4 id="安装" data-reactid="65"><a href="#%E5%AE%89%E8%A3%85" aria-hidden="true" data-reactid="66"><span class="icon icon-link" data-reactid="67"></span></a><!-- react-text: 68 -->安装<!-- /react-text --></h4><ol data-reactid="69"><li data-reactid="70"><!-- react-text: 71 -->下载扩展，<!-- /react-text --><a href="https://github.com/imcuttle/measure/raw/master/packages/chrome-extension-measure-viewer/measure-viewer.zip" data-reactid="72">点击下载</a></li><li data-reactid="73">打开 Chrome 扩展页面： chrome://extensions/</li><li data-reactid="74"><!-- react-text: 75 -->拖拽下载的包至页面中进行安装 <!-- /react-text --><img src="https://i.loli.net/2018/09/24/5ba8bdd4c9096.png" data-reactid="76"/></li><li data-reactid="77"><!-- react-text: 78 -->出现该图标表示安装完成 <!-- /react-text --><img src="https://i.loli.net/2018/09/24/5ba8be05d9f9a.png" data-reactid="79"/></li></ol><h2 id="设计与实现" data-reactid="80"><a href="#%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0" aria-hidden="true" data-reactid="81"><span class="icon icon-link" data-reactid="82"></span></a><!-- react-text: 83 -->设计与实现<!-- /react-text --></h2><p data-reactid="84">流程如下：</p><p data-reactid="85"><img src="http://obu9je6ng.bkt.clouddn.com/psd-measure.svg" data-reactid="86"/></p><h3 id="psd-文件格式介绍" data-reactid="87"><a href="#psd-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D" aria-hidden="true" data-reactid="88"><span class="icon icon-link" data-reactid="89"></span></a><!-- react-text: 90 -->PSD 文件格式介绍<!-- /react-text --></h3><p data-reactid="91"><img src="https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/images/PhotoshopFileFormatsStructure.gif" data-reactid="92"/></p><ul data-reactid="93"><li data-reactid="94">File Header（定长） 主要包括这个 psd 文件整体的数据，如版本，尺寸大小，图片通道数，使用的颜色类别（rgb、cmyk...）</li><li data-reactid="95">Color Mode Data Section（变长） 主要是部分颜色类型图片需要用到</li><li data-reactid="96">Image Resources（变长） 放置一些外部的图片资源</li><li data-reactid="97">Layer and Mask（变长） 放置图层和蒙层的各种信息，大小位置，字体，描边等等</li><li data-reactid="98">Image Data（变长） 放置图像像素数据</li></ul><h3 id="psdjs" data-reactid="99"><a href="#psdjs" aria-hidden="true" data-reactid="100"><span class="icon icon-link" data-reactid="101"></span></a><!-- react-text: 102 -->PSD.js<!-- /react-text --></h3><p data-reactid="103">使用 psd.js 便是解析上述文件结构，得到可读的数据结构。 其中 psd.js 使用 getter 得到懒解析数据，即如下代码：</p><pre data-reactid="104"><code class="hljs language-javascipt" data-query="{}" data-lang="javascipt" data-reactid="105"><span class="hljs-keyword" data-reactid="106">const</span><!-- react-text: 107 --> obj = <!-- /react-text --><span class="hljs-built_in" data-reactid="108">Object</span><!-- react-text: 109 -->.defineProperty({}, <!-- /react-text --><span class="hljs-string" data-reactid="110">&#x27;someParsedVal&#x27;</span><!-- react-text: 111 -->, {
  <!-- /react-text --><span class="hljs-attr" data-reactid="112">get</span><!-- react-text: 113 -->: <!-- /react-text --><span class="hljs-function" data-reactid="114"><span class="hljs-keyword" data-reactid="115">function</span><!-- react-text: 116 --> (<!-- /react-text --><span class="hljs-params" data-reactid="117"></span><!-- react-text: 118 -->) <!-- /react-text --></span><!-- react-text: 119 -->{
    <!-- /react-text --><span class="hljs-keyword" data-reactid="120">if</span><!-- react-text: 121 --> (!<!-- /react-text --><span class="hljs-keyword" data-reactid="122">this</span><!-- react-text: 123 -->._someParsedVal) {
      <!-- /react-text --><span class="hljs-keyword" data-reactid="124">const</span><!-- react-text: 125 --> afterMs = <!-- /react-text --><span class="hljs-built_in" data-reactid="126">Date</span><!-- react-text: 127 -->.now() + <!-- /react-text --><span class="hljs-number" data-reactid="128">3000</span><!-- react-text: 129 -->
      <!-- /react-text --><span class="hljs-keyword" data-reactid="130">while</span><!-- react-text: 131 --> (<!-- /react-text --><span class="hljs-literal" data-reactid="132">true</span><!-- react-text: 133 -->) {
        <!-- /react-text --><span class="hljs-keyword" data-reactid="134">if</span><!-- react-text: 135 --> (<!-- /react-text --><span class="hljs-built_in" data-reactid="136">Date</span><!-- react-text: 137 -->.now() &gt;= afterMs) {
          <!-- /react-text --><span class="hljs-keyword" data-reactid="138">this</span><!-- react-text: 139 -->._someParsedVal = <!-- /react-text --><span class="hljs-string" data-reactid="140">&#x27;ok&#x27;</span><!-- react-text: 141 -->
          <!-- /react-text --><span class="hljs-keyword" data-reactid="142">break</span><!-- react-text: 143 -->
        }
      }
    }
    <!-- /react-text --><span class="hljs-keyword" data-reactid="144">return</span><!-- react-text: 145 --> <!-- /react-text --><span class="hljs-keyword" data-reactid="146">this</span><!-- react-text: 147 -->._someParsedVal
  }
})

obj.someParsedVal <!-- /react-text --><span class="hljs-comment" data-reactid="148">// 3s 后出来</span><!-- react-text: 149 -->
obj.someParsedVal <!-- /react-text --><span class="hljs-comment" data-reactid="150">// 很快</span></code></pre><p data-reactid="151">在 mobx3 中也有类似的设计（LazyInitializer）</p><h3 id="psd-html" data-reactid="152"><a href="#psd-html" aria-hidden="true" data-reactid="153"><span class="icon icon-link" data-reactid="154"></span></a><!-- react-text: 155 -->psd-html<!-- /react-text --></h3><p data-reactid="156"><!-- react-text: 157 -->将 PSD 解析为 <!-- /react-text --><a href="https://github.com/syntax-tree/hast" data-reactid="158">HAST</a><!-- react-text: 159 -->，进而转换为 HTML<!-- /react-text --></p><h4 id="hast-html-抽象语法树" data-reactid="160"><a href="#hast-html-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91" aria-hidden="true" data-reactid="161"><span class="icon icon-link" data-reactid="162"></span></a><!-- react-text: 163 -->HAST (HTML 抽象语法树)<!-- /react-text --></h4><p data-reactid="164">如下 html：</p><pre data-reactid="165"><code class="hljs language-html" data-query="{}" data-lang="html" data-reactid="166"><span class="hljs-tag" data-reactid="167"><!-- react-text: 168 -->&lt;<!-- /react-text --><span class="hljs-name" data-reactid="169">a</span><!-- react-text: 170 --> <!-- /react-text --><span class="hljs-attr" data-reactid="171">href</span><!-- react-text: 172 -->=<!-- /react-text --><span class="hljs-string" data-reactid="173">&quot;http://alpha.com&quot;</span><!-- react-text: 174 --> <!-- /react-text --><span class="hljs-attr" data-reactid="175">class</span><!-- react-text: 176 -->=<!-- /react-text --><span class="hljs-string" data-reactid="177">&quot;bravo&quot;</span><!-- react-text: 178 --> <!-- /react-text --><span class="hljs-attr" data-reactid="179">download</span><!-- react-text: 180 -->&gt;<!-- /react-text --></span><span class="hljs-tag" data-reactid="181"><!-- react-text: 182 -->&lt;/<!-- /react-text --><span class="hljs-name" data-reactid="183">a</span><!-- react-text: 184 -->&gt;<!-- /react-text --></span></code></pre><p data-reactid="185">对应 HAST 为</p><pre data-reactid="186"><code class="hljs language-json" data-query="{}" data-lang="json" data-reactid="187"><!-- react-text: 188 -->{
  <!-- /react-text --><span class="hljs-attr" data-reactid="189">&quot;type&quot;</span><!-- react-text: 190 -->: <!-- /react-text --><span class="hljs-string" data-reactid="191">&quot;element&quot;</span><!-- react-text: 192 -->,
  <!-- /react-text --><span class="hljs-attr" data-reactid="193">&quot;tagName&quot;</span><!-- react-text: 194 -->: <!-- /react-text --><span class="hljs-string" data-reactid="195">&quot;a&quot;</span><!-- react-text: 196 -->,
  <!-- /react-text --><span class="hljs-attr" data-reactid="197">&quot;properties&quot;</span><!-- react-text: 198 -->: {
    <!-- /react-text --><span class="hljs-attr" data-reactid="199">&quot;href&quot;</span><!-- react-text: 200 -->: <!-- /react-text --><span class="hljs-string" data-reactid="201">&quot;http://alpha.com&quot;</span><!-- react-text: 202 -->,
    <!-- /react-text --><span class="hljs-attr" data-reactid="203">&quot;id&quot;</span><!-- react-text: 204 -->: <!-- /react-text --><span class="hljs-string" data-reactid="205">&quot;bravo&quot;</span><!-- react-text: 206 -->,
    <!-- /react-text --><span class="hljs-attr" data-reactid="207">&quot;className&quot;</span><!-- react-text: 208 -->: [<!-- /react-text --><span class="hljs-string" data-reactid="209">&quot;bravo&quot;</span><!-- react-text: 210 -->],
    <!-- /react-text --><span class="hljs-attr" data-reactid="211">&quot;download&quot;</span><!-- react-text: 212 -->: <!-- /react-text --><span class="hljs-literal" data-reactid="213">true</span><!-- react-text: 214 -->
  },
  <!-- /react-text --><span class="hljs-attr" data-reactid="215">&quot;children&quot;</span><!-- react-text: 216 -->: []
}<!-- /react-text --></code></pre><h4 id="前后端同构" data-reactid="217"><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%8C%E6%9E%84" aria-hidden="true" data-reactid="218"><span class="icon icon-link" data-reactid="219"></span></a><!-- react-text: 220 -->前后端同构<!-- /react-text --></h4><p data-reactid="221">前后端同构的意思：同时运行在客户端和服务端，具体便是同时执行在浏览器环境和 nodejs 环境</p><p data-reactid="222">实现前后端同构的一些常用方式，借助构建工具 browserify / rollup / webpack 来分别打包不同环境的 js</p><h5 id="模拟环境" data-reactid="223"><a href="#%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83" aria-hidden="true" data-reactid="224"><span class="icon icon-link" data-reactid="225"></span></a><!-- react-text: 226 -->模拟环境<!-- /react-text --></h5><ul data-reactid="227"><li data-reactid="228"><!-- react-text: 229 -->在 nodejs 环境，对于 <!-- /react-text --><a href="https://www.w3schools.com/nodejs/ref_modules.asp" data-reactid="230">nodejs built-in modules</a><!-- react-text: 231 --> 不进行打包<!-- /react-text --></li><li data-reactid="232"><!-- react-text: 233 -->在 browser 环境，则将预设的 built-in modules 打包进去，以及一些 global 变量（如 <!-- /react-text --><code data-reactid="234">process.env / __dirname</code><!-- react-text: 235 -->）也会进行 mock<!-- /react-text --></li></ul><h5 id="利用-变量替换--treeshake-区分不同环境的代码" data-reactid="236"><a href="#%E5%88%A9%E7%94%A8-%E5%8F%98%E9%87%8F%E6%9B%BF%E6%8D%A2--treeshake-%E5%8C%BA%E5%88%86%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E4%BB%A3%E7%A0%81" aria-hidden="true" data-reactid="237"><span class="icon icon-link" data-reactid="238"></span></a><!-- react-text: 239 -->利用 变量替换 + treeshake 区分不同环境的代码<!-- /react-text --></h5><ul data-reactid="240"><li data-reactid="241"><p data-reactid="242"><!-- react-text: 243 -->如 webpack 配置 <!-- /react-text --><code data-reactid="244">DefinePlugin</code></p><pre data-reactid="245"><code data-query="{}" data-lang="data-lang" data-reactid="246">{
  plugins: [
    new webpack.DefinePlugin({
      &#x27;process.env.RUN_ENV&#x27;: JSON.stringify(&#x27;browser&#x27;)
    })
  ]
}
</code></pre></li><li data-reactid="247"><p data-reactid="248">在代码中对不同环境打包进行区分</p><pre data-reactid="249"><code class="hljs language-javascript" data-query="{}" data-lang="javascript" data-reactid="250"><span class="hljs-built_in" data-reactid="251">module</span><!-- react-text: 252 -->.exports =
  process.env.RUN_ENV === <!-- /react-text --><span class="hljs-string" data-reactid="253">&#x27;browser&#x27;</span><!-- react-text: 254 -->
    ? {
        psdToHtml,
        psdToHtmlFromBuffer,
        psdToHtmlFromURL,
        psdToHAST,
        psdToHASTFromBuffer
      }
    : {
        psdToHtml,
        psdToHtmlFromPath,
        psdToHtmlFromBuffer,
        psdToHAST,
        psdToHASTFromBuffer,
        psdToHASTFromPath
      }<!-- /react-text --></code></pre></li><li data-reactid="255"><p data-reactid="256"><!-- react-text: 257 -->最终打包出来的 js 则会剔除掉 <!-- /react-text --><code data-reactid="258">psdToHASTFromPath</code><!-- react-text: 259 --> 相关代码<!-- /react-text --></p></li></ul><h5 id="packagejson-配置" data-reactid="260"><a href="#packagejson-%E9%85%8D%E7%BD%AE" aria-hidden="true" data-reactid="261"><span class="icon icon-link" data-reactid="262"></span></a><code data-reactid="263">package.json</code><!-- react-text: 264 --> 配置<!-- /react-text --></h5><p data-reactid="265">如下：</p><pre data-reactid="266"><code class="hljs language-json" data-query="{}" data-lang="json" data-reactid="267"><!-- react-text: 268 -->{
  <!-- /react-text --><span class="hljs-attr" data-reactid="269">&quot;main&quot;</span><!-- react-text: 270 -->: <!-- /react-text --><span class="hljs-string" data-reactid="271">&quot;dist/psd-html.cjs.js&quot;</span><!-- react-text: 272 -->,
  <!-- /react-text --><span class="hljs-attr" data-reactid="273">&quot;browser&quot;</span><!-- react-text: 274 -->: <!-- /react-text --><span class="hljs-string" data-reactid="275">&quot;dist/psd-html.browser.cjs.js&quot;</span><!-- react-text: 276 -->,
  <!-- /react-text --><span class="hljs-attr" data-reactid="277">&quot;cdn&quot;</span><!-- react-text: 278 -->: <!-- /react-text --><span class="hljs-string" data-reactid="279">&quot;dist/psd-html.browser.umd.min.js&quot;</span><!-- react-text: 280 -->,
  <!-- /react-text --><span class="hljs-attr" data-reactid="281">&quot;unpkg&quot;</span><!-- react-text: 282 -->: <!-- /react-text --><span class="hljs-string" data-reactid="283">&quot;dist/psd-html.browser.umd.min.js&quot;</span><!-- react-text: 284 -->
}<!-- /react-text --></code></pre><ul data-reactid="285"><li data-reactid="286"><code data-reactid="287">main</code><!-- react-text: 288 -->: nodejs 环境加载的 js<!-- /react-text --></li><li data-reactid="289"><code data-reactid="290">browser</code><!-- react-text: 291 -->: browser 环境加载的 js<!-- /react-text --></li><li data-reactid="292"><code data-reactid="293">cdn</code><!-- react-text: 294 -->: 部分 cdn 服务加载的 js<!-- /react-text --></li><li data-reactid="295"><code data-reactid="296">unpkg</code><!-- react-text: 297 -->: unpkg cdn 服务加载的 js （主要使用 UMD 规范打包）<!-- /react-text --></li></ul><p data-reactid="298"><!-- react-text: 299 -->直接访问 <!-- /react-text --><a href="https://unpkg.com/@moyuyc/psd-html" data-reactid="300">https://unpkg.com/@moyuyc/psd-html</a><!-- react-text: 301 --> 则会重定向至 <!-- /react-text --><a href="https://unpkg.com/@moyuyc/psd-html@%7Blatest-version%7D/dist/psd-html.browser.umd.min.js" data-reactid="302">https://unpkg.com/@moyuyc/psd-html@{latest-version}/dist/psd-html.browser.umd.min.js</a></p><h3 id="html-measure-交互" data-reactid="303"><a href="#html-measure-%E4%BA%A4%E4%BA%92" aria-hidden="true" data-reactid="304"><span class="icon icon-link" data-reactid="305"></span></a><!-- react-text: 306 -->html-measure 交互<!-- /react-text --></h3><h4 id="布局定位" data-reactid="307"><a href="#%E5%B8%83%E5%B1%80%E5%AE%9A%E4%BD%8D" aria-hidden="true" data-reactid="308"><span class="icon icon-link" data-reactid="309"></span></a><!-- react-text: 310 -->布局定位<!-- /react-text --></h4><p data-reactid="311"><img src="https://i.loli.net/2018/09/18/5ba0c06942981.png" data-reactid="312"/></p><p data-reactid="313">将 psd 导出成整个图片，利用每一个图层的定位和大小来自动标注。</p><h4 id="其他" data-reactid="314"><a href="#%E5%85%B6%E4%BB%96" aria-hidden="true" data-reactid="315"><span class="icon icon-link" data-reactid="316"></span></a><!-- react-text: 317 -->其他<!-- /react-text --></h4><p data-reactid="318">2 个 div，相对与同一个父级的绝对定位，如何判断他们是否相交？</p><p data-reactid="319">. . . . . . . . . .</p><p data-reactid="320">正面直接判断是很费力的，要考虑各种情况，这时候需要逆向思维，考虑不相交的情况。 这时候就简单了</p><p data-reactid="321">不相交只要满足下面四种情况之一就可以</p><p data-reactid="322"><img src="https://i.loli.net/2018/09/20/5ba2fd9e30a0b.png" data-reactid="323"/></p><p data-reactid="324"><img src="https://i.loli.net/2018/09/20/5ba2fe0ac7cd4.png" data-reactid="325"/></p><pre data-reactid="326"><code data-query="{}" data-lang="data-lang" data-reactid="327">function isIntersect(node1, node2) {
  const rect1 = node1.getBoundingClientRect()
  const rect2 = node2.getBoundingClientRect()
  return !(
    rect1.right &lt; rect2.left ||
    rect1.left &gt; rect2.right ||
    rect1.bottom &lt; rect2.top ||
    rect1.top &gt; rect2.bottom
  )
}
</code></pre><h3 id="measure-export-cli" data-reactid="328"><a href="#measure-export-cli" aria-hidden="true" data-reactid="329"><span class="icon icon-link" data-reactid="330"></span></a><!-- react-text: 331 -->measure-export(-cli)<!-- /react-text --></h3><p data-reactid="332"><!-- react-text: 333 -->输入 psd / html 导出 <!-- /react-text --><code data-reactid="334">meas-ui</code><!-- react-text: 335 --> 静态资源，流程如图（区分 prod 和 dev 环境）<!-- /react-text --></p><p data-reactid="336"><img src="http://obu9je6ng.bkt.clouddn.com//measure-export(-cli).svg" data-reactid="337"/></p><h2 id="todo" data-reactid="338"><a href="#todo" aria-hidden="true" data-reactid="339"><span class="icon icon-link" data-reactid="340"></span></a><!-- react-text: 341 -->Todo<!-- /react-text --></h2><ul data-reactid="342"><li class="task-list-item" data-reactid="343"><input type="checkbox" disabled="" data-reactid="344"/><!-- react-text: 345 --> 提供 chrome 插件：当浏览器打开 psd 时候，渲染测量尺寸 UI<!-- /react-text --></li></ul><h2 id="相关项目" data-reactid="346"><a href="#%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE" aria-hidden="true" data-reactid="347"><span class="icon icon-link" data-reactid="348"></span></a><!-- react-text: 349 -->相关项目<!-- /react-text --></h2><ul data-reactid="350"><li data-reactid="351"><a href="https://github.com/imcuttle/psd.js" data-reactid="352">@moyuyc/psd.js</a><!-- react-text: 353 --> - 解析 psd 文件，格式化 (Forked from <!-- /react-text --><a href="https://github.com/meltingice/psd.js" data-reactid="354">psd.js</a><!-- react-text: 355 -->)<!-- /react-text --></li><li data-reactid="356"><a href="https://github.com/imcuttle/measure/tree/master/packages/psd-html" data-reactid="357">@moyuyc/psd-html</a><!-- react-text: 358 --> - psd -&gt; hast -&gt; html<!-- /react-text --></li><li data-reactid="359"><a href="https://github.com/imcuttle/measure/tree/master/packages/html-measure" data-reactid="360">html-measure</a><!-- react-text: 361 --> - 标注交互<!-- /react-text --></li><li data-reactid="362"><a href="https://github.com/imcuttle/measure/tree/master/packages/meas-ui" data-reactid="363">meas-ui</a><!-- react-text: 364 --> - 前端 UI 展示，包含标注交互<!-- /react-text --></li><li data-reactid="365"><a href="https://github.com/imcuttle/measure/tree/master/packages/measure-export-cli" data-reactid="366">measure-export(-cli)</a><!-- react-text: 367 --> - 输入 psd / html 导出 <!-- /react-text --><code data-reactid="368">meas-ui</code><!-- react-text: 369 --> 静态资源<!-- /react-text --></li></ul><h2 id="参考资料" data-reactid="370"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" data-reactid="371"><span class="icon icon-link" data-reactid="372"></span></a><!-- react-text: 373 -->参考资料<!-- /react-text --></h2><ul data-reactid="374"><li data-reactid="375"><a href="https://www.adobe.com/devnet-apps/photoshop/fileformatashtml" data-reactid="376">Adobe Photoshop File Formats Specification</a><!-- react-text: 377 --> PS 文件格式官方标准<!-- /react-text --></li><li data-reactid="378"><a href="https://www.tonton-pixel.com/Photoshop%20Additional%20File%20Formats/styles-file-format.html#toc-parsing-styles-files" data-reactid="379">Photoshop Styles File Format</a></li><li data-reactid="380"><a href="https://zhuanlan.zhihu.com/p/29704064" data-reactid="381">JS. 如何判断两个矩形是否相交</a></li><li data-reactid="382"><a href="https://github.com/syntax-tree/hast" data-reactid="383">HAST</a></li></ul></article></div><div class="gitment-container" data-reactid="384"></div><div class="paginator" data-reactid="385"><a title="本地实时书写 markdown + 同步定位修改节点" class="prev" href="/talk-about-live-markd" data-reactid="386">Prev</a><a title="书写组件 DEMO 的一些方案" class="next" href="/how-to-write-component-demo" data-reactid="387">Next</a></div></div></main><footer data-reactid="388"><div class="copyright" data-reactid="389"><p data-reactid="390"><!-- react-text: 391 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="392">Picidae</a></p></div></footer></div>
</div>
<audio id="music" controls autoplay src="http://www.170mv.com/kw/other.web.ri01.sycdn.kuwo.cn/resource/n3/25/67/3891786006.mp3"></audio>
<script>
  !function () {
    var a = document.getElementById("music")
    a && (a.volume = 1)
  }()
</script>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>
