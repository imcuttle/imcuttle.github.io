<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/favicon.png" />
    <title> imCuttle </title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
<div id="root">
    <div class="wrap" data-reactroot="" data-reactid="1" data-react-checksum="-511262396"><header data-reactid="2"><a class="logo-link" href="/" data-reactid="3"><img src="/favicon.png" data-reactid="4"/></a><ul class="nav nav-list" data-reactid="5"><li class="nav-list-item" data-reactid="6"><a class="nav-list-link" href="/posts/1" data-reactid="7">Posts</a></li></ul></header><main data-reactid="8"><div class="post" data-reactid="9"><article class="post-block" data-reactid="10"><h1 class="post-title" data-reactid="11">markdown导入doc核心算法剖析</h1><div class="post-info" data-reactid="12"><time datetime="2017-08-22T09:32:02+00:00" data-reactid="13">Aug 22, 2017 9:32 AM</time></div></article><div class="post-content" data-reactid="14"><article data-reactid="15"><h2 id="算法需要做什么事情" data-reactid="16"><a href="#%E7%AE%97%E6%B3%95%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85" aria-hidden="true" data-reactid="17"><span class="icon icon-link" data-reactid="18"></span></a><!-- react-text: 19 -->算法需要做什么事情<!-- /react-text --></h2><!-- react-text: 20 -->
<!-- /react-text --><ul data-reactid="21"><!-- react-text: 22 -->
<!-- /react-text --><li data-reactid="23"><!-- react-text: 24 -->
<!-- /react-text --><p data-reactid="25"><!-- react-text: 26 -->Input -&gt; Output<!-- /react-text --><br data-reactid="27"/><!-- react-text: 28 -->
将原始的markdown文本解析成为一颗树形结构。<!-- /react-text --></p><!-- react-text: 29 -->
<!-- /react-text --><pre data-reactid="30"><code class="hljs language-markdown" data-query="{}" data-lang="markdown" data-reactid="31"><span class="hljs-section" data-reactid="32"># A               -&gt;  # A --- i&#x27;m an apple.</span><!-- react-text: 33 -->
i&#x27;m an apple.             |-- i&#x27;m an egg.
i&#x27;m an egg.               |-- &gt; <!-- /react-text --><span class="hljs-code" data-reactid="34">```
&gt; ```                     |   &gt; code A
&gt; code A                  |   &gt; ``` 
&gt; ```                     \-- ## A-1 --- text in A-1 
                                    |-- 1. A-1-1
## A-1                               |      |-- description1 in A-1-1 
                                    |      \-- description2 in A-1-1
text in A-1                          |-- 2. A-1-2
                                    |-- 3. A-1-3
1. A-1-1                             |-- not description 
description1 in A-1-1                \-- ~~~\ncode\n~~~
description2 in A-1-1
2. A-1-2

3. A-1-3

not description

~~~
code B
~~~</span></code></pre><!-- react-text: 35 -->
<!-- /react-text --></li><!-- react-text: 36 -->
<!-- /react-text --></ul><!-- react-text: 37 -->
<!-- /react-text --><h2 id="树形数据结构的储存方式" data-reactid="38"><a href="#%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F" aria-hidden="true" data-reactid="39"><span class="icon icon-link" data-reactid="40"></span></a><!-- react-text: 41 -->树形数据结构的储存方式<!-- /react-text --></h2><!-- react-text: 42 -->
<!-- /react-text --><p data-reactid="43"><!-- react-text: 44 -->简单的有两种(Java 代码，针对于<!-- /react-text --><strong data-reactid="45">单棵树</strong><!-- react-text: 46 -->)<!-- /react-text --></p><!-- react-text: 47 -->
<!-- /react-text --><ol data-reactid="48"><!-- react-text: 49 -->
<!-- /react-text --><li data-reactid="50"><!-- react-text: 51 -->
<!-- /react-text --><p data-reactid="52">多叉树  </p><!-- react-text: 53 -->
<!-- /react-text --><pre data-reactid="54"><code data-query="{}" data-lang="data-lang" data-reactid="55">    root
/   |  \
a1   a2   a3
|    / \    \
null b1  b2   b3
    |     \     \
    null   null   null
</code></pre><!-- react-text: 56 -->
<!-- /react-text --><pre data-reactid="57"><code class="hljs language-java" data-query="{}" data-lang="java" data-reactid="58"><span class="hljs-class" data-reactid="59"><span class="hljs-keyword" data-reactid="60">class</span><!-- react-text: 61 --> <!-- /react-text --><span class="hljs-title" data-reactid="62">TreeNode</span><!-- react-text: 63 --> <!-- /react-text --></span><!-- react-text: 64 -->{
    TreeNode[] children;
    Object value;
    <!-- /react-text --><span class="hljs-comment" data-reactid="65">// 可有可无</span><!-- react-text: 66 -->
    TreeNode parent;
}

<!-- /react-text --><span class="hljs-class" data-reactid="67"><span class="hljs-keyword" data-reactid="68">class</span><!-- react-text: 69 --> <!-- /react-text --><span class="hljs-title" data-reactid="70">Tree</span><!-- react-text: 71 --> <!-- /react-text --></span><!-- react-text: 72 -->{
    TreeNode root;
}<!-- /react-text --></code></pre><!-- react-text: 73 -->
<!-- /react-text --></li><!-- react-text: 74 -->
<!-- /react-text --><li data-reactid="75"><!-- react-text: 76 -->
<!-- /react-text --><p data-reactid="77">一维数组  </p><!-- react-text: 78 -->
<!-- /react-text --><pre data-reactid="79"><code data-query="{}" data-lang="data-lang" data-reactid="80">{}:          {}:        {}:        {}:        {}:        {}:         ...
pid: null    pid: 0;    pid: 0;    pid: 0;    pid: 2;    pid: 2;
val: root;   val: a1;   val: a2;   val: a3;   val: b1;   val: b2;   
</code></pre><!-- react-text: 81 -->
<!-- /react-text --><p data-reactid="82"><!-- react-text: 83 -->其中节点id是数组中的索引位置。<!-- /react-text --><br data-reactid="84"/><!-- react-text: 85 -->
这种方式相比于多叉树方法，逻辑更简单，但是对于父子之间的关系联系没有多叉树&quot;密切&quot;。<!-- /react-text --></p><!-- react-text: 86 -->
<!-- /react-text --><pre data-reactid="87"><code class="hljs language-java" data-query="{}" data-lang="java" data-reactid="88"><span class="hljs-class" data-reactid="89"><span class="hljs-keyword" data-reactid="90">class</span><!-- react-text: 91 --> <!-- /react-text --><span class="hljs-title" data-reactid="92">Node</span><!-- react-text: 93 --> <!-- /react-text --></span><!-- react-text: 94 -->{
    Object value;
    <!-- /react-text --><span class="hljs-keyword" data-reactid="95">int</span><!-- react-text: 96 --> parentId;
}<!-- /react-text --></code></pre><!-- react-text: 97 -->
<!-- /react-text --></li><!-- react-text: 98 -->
<!-- /react-text --></ol><!-- react-text: 99 -->
<!-- /react-text --><h2 id="思考" data-reactid="100"><a href="#%E6%80%9D%E8%80%83" aria-hidden="true" data-reactid="101"><span class="icon icon-link" data-reactid="102"></span></a><!-- react-text: 103 -->思考<!-- /react-text --></h2><!-- react-text: 104 -->
<!-- /react-text --><p data-reactid="105"><!-- react-text: 106 -->最后树的存储方式使用的是<!-- /react-text --><strong data-reactid="107">一维数组</strong><!-- react-text: 108 -->，更多的原因是doc本身用的就是这种方式传参。<!-- /react-text --></p><!-- react-text: 109 -->
<!-- /react-text --><p data-reactid="110">下面较为详细地解释解析markdown文本的算法。  </p><!-- react-text: 111 -->
<!-- /react-text --><p data-reactid="112"><strong data-reactid="113">注意：以下语法解析单元均是以行为单位</strong><!-- react-text: 114 -->
1. 首先需要&quot;拎出&quot;会产生父子关系的语法<!-- /react-text --><br data-reactid="115"/><!-- react-text: 116 -->
形如:<!-- /react-text --></p><!-- react-text: 117 -->
<!-- /react-text --><pre data-reactid="118"><code data-query="{}" data-lang="data-lang" data-reactid="119">```
# Head

## child of Head

- Disorder  Item A
    child of Item A
- Disorder  Item B

1. Order Item 1
    child of Item 1
2. Order Item 2
```
</code></pre><!-- react-text: 120 -->
<!-- /react-text --><ol start="2" data-reactid="121"><!-- react-text: 122 -->
<!-- /react-text --><li data-reactid="123"><!-- react-text: 124 -->
<!-- /react-text --><p data-reactid="125"><!-- react-text: 126 -->&quot;拎出&quot;多行的语法块<!-- /react-text --><br data-reactid="127"/><!-- react-text: 128 -->
形如:<!-- /react-text --></p><!-- react-text: 129 -->
<!-- /react-text --><pre data-reactid="130"><code data-query="{}" data-lang="data-lang" data-reactid="131">```
int a = 123;
```

&gt; BlockQuote line1
&gt; BlockQuote line2
</code></pre><!-- react-text: 132 -->
<!-- /react-text --></li><!-- react-text: 133 -->
<!-- /react-text --><li data-reactid="134"><!-- react-text: 135 -->
<!-- /react-text --><p data-reactid="136"><!-- react-text: 137 -->&quot;拎出&quot;空行<!-- /react-text --><br data-reactid="138"/><!-- react-text: 139 -->
因为空行可能是区分父子关系的依据  <!-- /react-text --></p><!-- react-text: 140 -->
<!-- /react-text --><pre data-reactid="141"><code data-query="{}" data-lang="data-lang" data-reactid="142"> - item a

     child of a

   i&#x27;m child of a

 i&#x27;m not child of a

 - item b
     child of b

     i&#x27;m child of b
</code></pre><!-- react-text: 143 -->
<!-- /react-text --></li><!-- react-text: 144 -->
<!-- /react-text --></ol><!-- react-text: 145 -->
<!-- /react-text --><pre data-reactid="146"><code data-query="{}" data-lang="data-lang" data-reactid="147">i&#x27;m not child of b
</code></pre><!-- react-text: 148 -->
<!-- /react-text --><pre data-reactid="149"><code data-query="{}" data-lang="data-lang" data-reactid="150">4. 匹配一些无关的语法行

### 一些特殊情况

1. 列表的父子关系区分  
 ```
 - a                a
 - b                b 
  - c         -&gt;     \- c
   - d               |   \- d
  - e                |- e
 ```

 ```
 - c                c
   - d        -&gt;     \- d
  - e                    \- e
 ```

2. 标题的父子关系区别（较列表简单）  
 ```
 # a           a
 ### b          \- b
 ## c     -&gt;    |- c
 ## d           |- d
 # e           e  
 ```

[源码实现](https://github.com/imcuttle/doc-md-import/blob/master/lib/parser-factory/md-to-tree.js)
</code></pre><!-- react-text: 151 -->
<!-- /react-text --></article></div><div class="gitment-container" data-reactid="152"></div><div class="paginator" data-reactid="153"><a title="doc-pipe - 管理/同步 树状文档本地/服务器文章 解决方案" class="prev" href="/doc-pipe-boom" data-reactid="154">Prev</a><a title="导入markdown至树状文档" class="next" href="/doc-import-from-markdown" data-reactid="155">Next</a></div></div></main><footer data-reactid="156"><div class="copyright" data-reactid="157"><p data-reactid="158"><!-- react-text: 159 -->© 2017. Powered By <!-- /react-text --><a href="https://github.com/picidaejs/picidae" data-reactid="160">Picidae</a></p></div></footer></div>
</div>
<script src="/PICIDAE_COMMON.js"></script>
<script src="/PICIDAE_ENTRY.js"></script>
</body>
</html>