webpackJsonp([29,90],{1034:function(e,d){e.exports={content:'<h2 id="问题重现"><a href="#%E9%97%AE%E9%A2%98%E9%87%8D%E7%8E%B0" aria-hidden="true"><span class="icon icon-link"></span></a>问题重现</h2>\n<p>不知道各位旁友在<code>webpack</code>的使用中，有没有碰到下面的问题情景：\n1. 在使用了<code>css Module</code>的情况下，同时又希望用一些<code>global</code>的布局，其实在<code>css Module</code>中直接用</p>\n<pre><code data-query="{}" data-lang="">:global(.title) {\n    color: green;\n}\n</code></pre>\n<p>也是可以实现的，但是如果需要引入第三方css，如<code>Animate.css</code>，如果对每一个<code>classname</code>都进行手动的全局定义，工作量可不小。</p>\n<ol start="2">\n<li>关于<code>css</code>的打包问题，对于一些组件的样式，可以将<code>css</code>打包在<code>js</code>文件中，但是一些全局的<code>css</code>，或者一些需要第一时间加载的<code>css</code> (如<code>pace.css</code>，在页面加载过程中就需要第一时间解析出样式)，就需要使用<code>ExtractTextPlugin</code>打包成为单独的<code>css</code>文件了。</li>\n</ol>\n<p>以上都是需要对于同一类型文件的不同处理。在<code>webpack</code>中就体现成用正则表达式进行文件名匹配。</p>\n<p>为了更优雅的命名，第一种情景来举例，我将全局的样式文件命名成<code>foo.global.less</code>，其他需要进行<code>css module</code>处理的则正常命名，如<code>bar.less</code>。</p>\n<h2 id="思路"><a href="#%E6%80%9D%E8%B7%AF" aria-hidden="true"><span class="icon icon-link"></span></a>思路</h2>\n<p>在进入主题之前，我先分享一个实用的在线正则网站<a href="http://refiddle.com/">refiddle</a>，包含了不仅仅<code>Javascript</code>的正则</p>\n<p>下面的重头戏便是<br>\n<strong>如何正则匹配<code>*.global.less</code>和<code>*.less</code>(不包括<code>*.global.less</code>)？</strong></p>\n<p>众所周知，<code>webpack</code>中是不存在多次正则匹配的，所以需要分别使用2个正则表达式来解决上面两种字符串的匹配。</p>\n<p><code>*.global.less</code>字符串匹配？恩, so easy，<code>/\\.global\\.less$/</code>, 那么<code>*.less</code>(不包括<code>*.global.less</code>)呢？</p>\n<p>显然，这就需要用到正则的位置匹配了(<code>(^\\.global)</code>和<code>[^\\.global]</code>都是不正确的)，匹配前面不是<code>.global</code>的的位置。</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>语法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>捕获</td>\n<td><code>(exp)</code></td>\n<td>匹配exp,并捕获文本到自动命名的组里</td>\n</tr>\n<tr>\n<td>捕获</td>\n<td><code>(?&#x3C;name>exp)</code></td>\n<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?\'name\'exp)</td>\n</tr>\n<tr>\n<td>捕获</td>\n<td><code>(?:exp)</code></td>\n<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>\n</tr>\n<tr>\n<td>位置匹配</td>\n<td><code>(?=exp)</code></td>\n<td>匹配exp前面的位置</td>\n</tr>\n<tr>\n<td>位置匹配</td>\n<td><code>(?&#x3C;=exp)</code></td>\n<td>匹配exp后面的位置</td>\n</tr>\n<tr>\n<td>位置匹配</td>\n<td><code>(?!exp)</code></td>\n<td>匹配后面跟的不是exp的位置</td>\n</tr>\n<tr>\n<td>位置匹配</td>\n<td><code>(?&#x3C;!exp)</code></td>\n<td>匹配前面不是exp的位置</td>\n</tr>\n<tr>\n<td>注释</td>\n<td><code>(?#comment)</code></td>\n<td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td>\n</tr>\n</tbody>\n</table>\n<p>如上表，很显然需要使用<code>(?&#x3C;!exp)</code>，所以正则表达式是<code>/(?&#x3C;!global)\\.less$/</code>，完结撒花！</p>\n<p>但是！真的就这样可以了吗？？很不幸的是在js中并没有实现<code>(?&#x3C;=exp)</code>和<code>(?&#x3C;!exp)</code>的位置匹配。（可能是大家伙都没想到Js能走到今天这个地步，以为只是在浏览器上耍耍，数据验证没必要太复杂吧 ）<br>\n参看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>.</p>\n<p>经过一番查找和头脑风暴，最终得到了Js中不包含某子串的正则匹配<br>\n<strong><code>/^(.(?!\\.global))+\\.less$/</code></strong></p>\n<p><code>(?!\\.global)</code>匹配的是后面不是<code>.global</code>的位置<br>\n<code>(.(?!\\.global))+</code>匹配的就是若干个后面跟着不是<code>.global</code>的字符<br>\n<code>^</code>字符串首位置不能丢！，如果丢了，<code>/(.(?!\\.global))+\\.less$/</code>也能够匹配<code>foo.global.less</code>，因为从<code>foo</code>后面的<code>.</code>开始，后面跟着的就不是<code>.global</code>了。</p>\n<p>但是对于<code>.global.less</code>字符串，该正则也无能为力了。</p>\n<h2 id="参考"><a href="#%E5%8F%82%E8%80%83" aria-hidden="true"><span class="icon icon-link"></span></a>参考</h2>\n<ol>\n<li><a href="http://deerchao.net/tutorials/regex/regex.htm">正则表达式30分钟入门教程</a></li>\n<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">JavaScript RegExp</a></li>\n<li><a href="http://www.cnblogs.com/bvbook/archive/2010/11/03/1867775.html">正则表达式匹配“不包含某个字符串” (通俗易懂还有图！)</a></li>\n</ol>\n',extra:{}}}});