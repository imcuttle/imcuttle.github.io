{"version":3,"sources":["webpack:///i18n-live-edit.js","webpack:///./source/_articles/i18n-live-edit.md"],"names":["webpackJsonp","1186","module","exports","content","extra","_image-loader_","_progressive_"],"mappings":"AAAAA,cAAc,GAAG,MAEXC,KACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,+1LACAC,OACAC,oBACAC","file":"i18n-live-edit.js","sourcesContent":["webpackJsonp([78,113],{\n\n/***/ 1186:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=痛点><a href=#%E7%97%9B%E7%82%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>痛点</h2><p>前端技术栈：React + Mobx 国际化解决方案：通过一个全局的 translate 方法输入对应翻译译文的 key</p><p>如：现在的中文的英文翻译字典数据有，</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-comment>// zh-CN</span>\\n{\\n    <span class=hljs-attr>cuttle</span>: <span class=hljs-string>'墨鱼'</span>\\n}\\n\\n<span class=hljs-comment>// en-US</span>\\n{\\n    <span class=hljs-attr>cuttle</span>: <span class=hljs-string>'imcuttle'</span>\\n}</code></pre><p>依次在中英文环境下调用 <code>translate('cuttle')</code> 会分别返回 <code>'墨鱼'</code> <code>'imcuttle'</code> 字符串，所以如果需要修改中文环境中可见文本 <code>墨鱼</code> 的译文，则需要：</p><ol><li>js 源码中找到 Key：<code>cuttle</code></li><li>在中英文字典数据文件中修改 <code>cuttle</code> 对应的 value</li></ol><p><strong>而我们会在步骤 1 花费比较多的时间！</strong></p><p>其次：目前部分的国际化字典由前端来维护，添加 FE 的（无意义）工作量</p><h2 id=解决方案><a href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>解决方案</h2><p>考虑一种可以在线编辑的模式，既方便前端修改，又方便 PM 对国际化文本进行修改；同时这种在线编辑模式的实现又需要兼容 <code>translate</code> API 的使用</p><img src=false width=1193 height=461 data-src=https://i.loli.net/2017/12/21/5a3bb22977eed.jpg> <img src=false width=1069 height=543 data-src=https://i.loli.net/2017/12/21/5a3bb24eb7359.jpg><h3 id=思路一：输出-react-element><a href=#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E8%BE%93%E5%87%BA-react-element aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思路一：输出 React Element</h3><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newTranslate</span>(<span class=hljs-params>key</span>) </span>{\\n    <span class=hljs-keyword>const</span> raw = translate(key)\\n    <span class=hljs-keyword>const</span> ele = <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>i18n</span>></span>{raw}<span class=hljs-tag>&lt;/<span class=hljs-name>i18n</span>></span></span>\\n    <span class=hljs-comment>// ele.toString = function () {return raw}</span>\\n    <span class=hljs-comment>// 不能扩展 toString 方法</span>\\n    \\n    \\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Proxy</span>(ele, {\\n        get() {\\n            <span class=hljs-comment>// 拦截 toString</span>\\n            ...\\n        }\\n    })\\n}</code></pre><p>这种方式够简单明了，但是有一个致命的缺陷：破坏了原有的 DOM 结构</p><h3 id=思路二：输出带数据的特殊-object><a href=#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E8%BE%93%E5%87%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E6%AE%8A-object aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思路二：输出带数据的特殊 Object</h3><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newTranslate</span>(<span class=hljs-params>key</span>) </span>{\\n    <span class=hljs-keyword>const</span> rlt = <span class=hljs-keyword>new</span> <span class=hljs-built_in>String</span>(key)\\n    <span class=hljs-comment>// typeof rlt === 'object'</span>\\n    rlt[<span class=hljs-string>'__i18n__'</span>] = { raw, key }\\n    <span class=hljs-keyword>return</span> rlt\\n}</code></pre><p>该方法不会破坏原有的 DOM 结构；同时需要拦截 React.createElement 方法</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-keyword>const</span> createElement = React.createElement\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newCreateElement</span> (<span class=hljs-params>name, props, ...children</span>) </span>{\\n    <span class=hljs-comment>// DOM Component</span>\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> name === <span class=hljs-string>'string'</span>) {\\n        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> key <span class=hljs-keyword>in</span> props) {\\n            <span class=hljs-keyword>const</span> value = props[key]\\n            <span class=hljs-keyword>if</span> (value <span class=hljs-keyword>instanceof</span> <span class=hljs-built_in>String</span> &amp&amp value[<span class=hljs-string>'__i18n__'</span>]) {\\n                <span class=hljs-comment>// 检查到经过 translate 处理</span>\\n                <span class=hljs-comment>// 记录 value['__i18n__'] 中的 id</span>\\n                ...\\n            }\\n        }\\n        \\n        children.forEach(<span class=hljs-function><span class=hljs-params>child</span> =></span> {\\n            <span class=hljs-comment>// 对 child 处理逻辑同上</span>\\n        })\\n        \\n        <span class=hljs-comment>// 之前检查到了有 translated </span>\\n        <span class=hljs-keyword>if</span> (validate) {\\n            props.className =  props.className + <span class=hljs-string>' i18n-badge'</span>\\n            \\n            <span class=hljs-keyword>const</span> onMouseEnter = props.onMouseEnter\\n            props.onMouseEnter = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n                <span class=hljs-comment>// ... 交互逻辑</span>\\n                \\n                <span class=hljs-keyword>return</span> onMouseEnter.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>)\\n            }\\n        }\\n    }\\n    \\n    <span class=hljs-keyword>return</span> createElement(name, props, ...children)\\n}</code></pre><p>最后效果参考: <a href=https://demo.crowdin.com/profile/demo>https://demo.crowdin.com/profile/demo</a></p><h2 id=提问环节><a href=#%E6%8F%90%E9%97%AE%E7%8E%AF%E8%8A%82 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>提问环节</h2><ul><li>前端页面修改结果，在不刷新页面的情况下，如何同步至页面？</li><li>怎么解决 <code>translate('a') + translate('b')</code> 的检测</li></ul>\",\n\t  \"extra\": {\n\t    \"_image-loader_\": [],\n\t    \"_progressive_\": []\n\t  }\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// i18n-live-edit.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<style>.transformer-react-render{border:1px dashed #959da5;border-radius:5px;display:block}.transformer-react-render-container>pre{max-height:400px;transition:all .2s ease}.transformer-react-render-container>pre.focused{max-height:none;box-shadow:0 0 6px rgba(0,0,0,.2)}</style><h2 id=痛点><a href=#%E7%97%9B%E7%82%B9 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>痛点</h2><p>前端技术栈：React + Mobx 国际化解决方案：通过一个全局的 translate 方法输入对应翻译译文的 key</p><p>如：现在的中文的英文翻译字典数据有，</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-comment>// zh-CN</span>\\n{\\n    <span class=hljs-attr>cuttle</span>: <span class=hljs-string>'墨鱼'</span>\\n}\\n\\n<span class=hljs-comment>// en-US</span>\\n{\\n    <span class=hljs-attr>cuttle</span>: <span class=hljs-string>'imcuttle'</span>\\n}</code></pre><p>依次在中英文环境下调用 <code>translate('cuttle')</code> 会分别返回 <code>'墨鱼'</code> <code>'imcuttle'</code> 字符串，所以如果需要修改中文环境中可见文本 <code>墨鱼</code> 的译文，则需要：</p><ol><li>js 源码中找到 Key：<code>cuttle</code></li><li>在中英文字典数据文件中修改 <code>cuttle</code> 对应的 value</li></ol><p><strong>而我们会在步骤 1 花费比较多的时间！</strong></p><p>其次：目前部分的国际化字典由前端来维护，添加 FE 的（无意义）工作量</p><h2 id=解决方案><a href=#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>解决方案</h2><p>考虑一种可以在线编辑的模式，既方便前端修改，又方便 PM 对国际化文本进行修改；同时这种在线编辑模式的实现又需要兼容 <code>translate</code> API 的使用</p><img src=false width=1193 height=461 data-src=https://i.loli.net/2017/12/21/5a3bb22977eed.jpg> <img src=false width=1069 height=543 data-src=https://i.loli.net/2017/12/21/5a3bb24eb7359.jpg><h3 id=思路一：输出-react-element><a href=#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E8%BE%93%E5%87%BA-react-element aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思路一：输出 React Element</h3><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newTranslate</span>(<span class=hljs-params>key</span>) </span>{\\n    <span class=hljs-keyword>const</span> raw = translate(key)\\n    <span class=hljs-keyword>const</span> ele = <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>i18n</span>></span>{raw}<span class=hljs-tag>&lt;/<span class=hljs-name>i18n</span>></span></span>\\n    <span class=hljs-comment>// ele.toString = function () {return raw}</span>\\n    <span class=hljs-comment>// 不能扩展 toString 方法</span>\\n    \\n    \\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Proxy</span>(ele, {\\n        get() {\\n            <span class=hljs-comment>// 拦截 toString</span>\\n            ...\\n        }\\n    })\\n}</code></pre><p>这种方式够简单明了，但是有一个致命的缺陷：破坏了原有的 DOM 结构</p><h3 id=思路二：输出带数据的特殊-object><a href=#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E8%BE%93%E5%87%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%B9%E6%AE%8A-object aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>思路二：输出带数据的特殊 Object</h3><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newTranslate</span>(<span class=hljs-params>key</span>) </span>{\\n    <span class=hljs-keyword>const</span> rlt = <span class=hljs-keyword>new</span> <span class=hljs-built_in>String</span>(key)\\n    <span class=hljs-comment>// typeof rlt === 'object'</span>\\n    rlt[<span class=hljs-string>'__i18n__'</span>] = { raw, key }\\n    <span class=hljs-keyword>return</span> rlt\\n}</code></pre><p>该方法不会破坏原有的 DOM 结构；同时需要拦截 React.createElement 方法</p><pre><code class=\\\"hljs language-js\\\"data-query={} data-lang=js><span class=hljs-keyword>const</span> createElement = React.createElement\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>newCreateElement</span> (<span class=hljs-params>name, props, ...children</span>) </span>{\\n    <span class=hljs-comment>// DOM Component</span>\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> name === <span class=hljs-string>'string'</span>) {\\n        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> key <span class=hljs-keyword>in</span> props) {\\n            <span class=hljs-keyword>const</span> value = props[key]\\n            <span class=hljs-keyword>if</span> (value <span class=hljs-keyword>instanceof</span> <span class=hljs-built_in>String</span> &amp&amp value[<span class=hljs-string>'__i18n__'</span>]) {\\n                <span class=hljs-comment>// 检查到经过 translate 处理</span>\\n                <span class=hljs-comment>// 记录 value['__i18n__'] 中的 id</span>\\n                ...\\n            }\\n        }\\n        \\n        children.forEach(<span class=hljs-function><span class=hljs-params>child</span> =></span> {\\n            <span class=hljs-comment>// 对 child 处理逻辑同上</span>\\n        })\\n        \\n        <span class=hljs-comment>// 之前检查到了有 translated </span>\\n        <span class=hljs-keyword>if</span> (validate) {\\n            props.className =  props.className + <span class=hljs-string>' i18n-badge'</span>\\n            \\n            <span class=hljs-keyword>const</span> onMouseEnter = props.onMouseEnter\\n            props.onMouseEnter = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params></span>) </span>{\\n                <span class=hljs-comment>// ... 交互逻辑</span>\\n                \\n                <span class=hljs-keyword>return</span> onMouseEnter.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>)\\n            }\\n        }\\n    }\\n    \\n    <span class=hljs-keyword>return</span> createElement(name, props, ...children)\\n}</code></pre><p>最后效果参考: <a href=https://demo.crowdin.com/profile/demo>https://demo.crowdin.com/profile/demo</a></p><h2 id=提问环节><a href=#%E6%8F%90%E9%97%AE%E7%8E%AF%E8%8A%82 aria-hidden=true><span class=\\\"icon icon-link\\\"></span></a>提问环节</h2><ul><li>前端页面修改结果，在不刷新页面的情况下，如何同步至页面？</li><li>怎么解决 <code>translate('a') + translate('b')</code> 的检测</li></ul>\",\n  \"extra\": {\n    \"_image-loader_\": [],\n    \"_progressive_\": []\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./source/_articles/i18n-live-edit.md\n// module id = 1186\n// module chunks = 78"],"sourceRoot":""}